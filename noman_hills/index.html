<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Scene with Walkthrough</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            font-family: Arial, sans-serif;
        }
    </style>
</head>
<body>
    <div id="instructions">Click to lock camera controls<br>WASD to move, drag to look around</div>
    <script src="https://threejs.org/build/three.js"></script>
    <script src="https://threejs.org/examples/js/controls/PointerLockControls.js"></script>
    <script>
        // Scene Setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Camera Controls
        const controls = new THREE.PointerLockControls(camera, renderer.domElement);
        document.addEventListener('click', () => controls.lock());

        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;

        document.addEventListener('keydown', (event) => {
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyD': moveRight = true; break;
            }
        });

        document.addEventListener('keyup', (event) => {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyD': moveRight = false; break;
            }
        });

        let prevTime = performance.now();
        function updateControls() {
            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;
            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.normalize();
            if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
            if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;
            controls.moveRight(-velocity.x * delta);
            controls.moveForward(-velocity.z * delta);
            prevTime = time;
        }

        // Perlin Noise for Terrain
        const p = new Array(512);
        const permutation = [...Array(256).keys()];
        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
        shuffle(permutation);
        for (let i = 0; i < 256; i++) p[i] = p[i + 256] = permutation[i];

        const gradients = [
            [1, 0], [-1, 0], [0, 1], [0, -1],
            [0.707, 0.707], [-0.707, 0.707], [0.707, -0.707], [-0.707, -0.707]
        ];

        function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
        function lerp(t, a, b) { return a + t * (b - a); }
        function grad(hash, x, z) {
            const h = hash % 8;
            const g = gradients[h];
            return g[0] * x + g[1] * z;
        }

        function noise(x, z) {
            const X = Math.floor(x) & 255;
            const Z = Math.floor(z) & 255;
            x -= Math.floor(x);
            z -= Math.floor(z);
            const u = fade(x);
            const v = fade(z);
            const aa = p[p[X] + Z], ab = p[p[X] + Z + 1],
                  ba = p[p[X + 1] + Z], bb = p[p[X + 1] + Z + 1];
            return lerp(v,
                lerp(u, grad(aa, x, z), grad(ba, x - 1, z)),
                lerp(u, grad(ab, x, z - 1), grad(bb, x - 1, z - 1))
            );
        }

        const frequency = 0.01;
        const amplitude = 20;
        const riverWidth = 10;
        const riverDepth = 5;

        function getHeight(x, z) {
            let nx = x * frequency;
            let nz = z * frequency;
            let height = 0;
            let amp = 1;
            let freq = 1;
            for (let i = 0; i < 3; i++) {
                height += amp * noise(nx * freq, nz * freq);
                amp *= 0.5;
                freq *= 2;
            }
            height = height / (1 + 0.5 + 0.25) * amplitude;
            const riverFactor = Math.exp(-(z / riverWidth) ** 2);
            height -= riverDepth * riverFactor;
            return height;
        }

        // Chunk Management
        const chunkSize = 64;
        const loadedChunks = new Map();

        function generateChunk(chunkX, chunkZ) {
            // Terrain
            const geometry = new THREE.PlaneGeometry(chunkSize, chunkSize, 32, 32);
            const positions = geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i] + chunkX * chunkSize;
                const z = positions[i + 2] + chunkZ * chunkSize;
                positions[i + 1] = getHeight(x, z);
            }
            geometry.computeVertexNormals();
            const material = new THREE.MeshPhongMaterial({ color: 0x888888 });
            const terrainMesh = new THREE.Mesh(geometry, material);
            terrainMesh.position.set(chunkX * chunkSize, 0, chunkZ * chunkSize);
            terrainMesh.rotation.x = -Math.PI / 2;
            terrainMesh.castShadow = true;
            terrainMesh.receiveShadow = true;
            scene.add(terrainMesh);

            // Grass
            const grassGeometry = new THREE.BufferGeometry();
            const vertices = new Float32Array([
                -0.05, 0, 0, 0.05, 0, 0, -0.05, 0.5, 0, 0.05, 0.5, 0,
                0, 0, -0.05, 0, 0, 0.05, 0, 0.5, -0.05, 0, 0.5, 0.05
            ]);
            const indices = [0, 1, 2, 1, 3, 2, 4, 5, 6, 5, 7, 6];
            grassGeometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            grassGeometry.setIndex(indices);
            const grassMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
            const grassCount = 1000;
            const grassMesh = new THREE.InstancedMesh(grassGeometry, grassMaterial, grassCount);
            const dummy = new THREE.Object3D();
            for (let i = 0; i < grassCount; i++) {
                const x = (Math.random() - 0.5) * chunkSize + chunkX * chunkSize;
                const z = (Math.random() - 0.5) * chunkSize + chunkZ * chunkSize;
                const y = getHeight(x, z);
                dummy.position.set(x, y, z);
                dummy.rotation.y = Math.random() * Math.PI * 2;
                const scale = 0.5 + Math.random() * 0.5;
                dummy.scale.set(scale, scale, scale);
                dummy.updateMatrix();
                grassMesh.setMatrixAt(i, dummy.matrix);
            }
            grassMesh.instanceMatrix.needsUpdate = true;
            grassMesh.receiveShadow = true;
            scene.add(grassMesh);

            return { terrain: terrainMesh, grass: grassMesh };
        }

        function updateChunks() {
            const chunkX = Math.floor(camera.position.x / chunkSize);
            const chunkZ = Math.floor(camera.position.z / chunkSize);
            const neededChunks = [];
            for (let dx = -1; dx <= 1; dx++) {
                for (let dz = -1; dz <= 1; dz++) {
                    neededChunks.push(`${chunkX + dx},${chunkZ + dz}`);
                }
            }
            for (let key of [...loadedChunks.keys()]) {
                if (!neededChunks.includes(key)) {
                    const chunk = loadedChunks.get(key);
                    scene.remove(chunk.terrain);
                    scene.remove(chunk.grass);
                    chunk.terrain.geometry.dispose();
                    chunk.grass.geometry.dispose();
                    loadedChunks.delete(key);
                }
            }
            for (let key of neededChunks) {
                if (!loadedChunks.has(key)) {
                    const [cx, cz] = key.split(',').map(Number);
                    loadedChunks.set(key, generateChunk(cx, cz));
                }
            }
        }

        // Water (River)
        const waterGeometry = new THREE.PlaneGeometry(1000, 20, 1, 1);
        const waterMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff, transparent: true, opacity: 0.5 });
        const water = new THREE.Mesh(waterGeometry, waterMaterial);
        water.position.set(0, 0, 0);
        water.rotation.x = -Math.PI / 2;
        water.receiveShadow = true;
        scene.add(water);

        // Lighting
        const sun = new THREE.DirectionalLight(0xffffff, 1);
        sun.position.set(50, 100, 50);
        sun.castShadow = true;
        sun.shadow.mapSize.width = 1024;
        sun.shadow.mapSize.height = 1024;
        sun.shadow.camera.left = -50;
        sun.shadow.camera.right = 50;
        sun.shadow.camera.top = 50;
        sun.shadow.camera.bottom = -50;
        sun.shadow.camera.near = 0.5;
        sun.shadow.camera.far = 200;
        scene.add(sun);

        const ambient = new THREE.AmbientLight(0x404040);
        scene.add(ambient);

        // Animation Loop
        function animate() {
            requestAnimationFrame(animate);
            updateControls();
            updateChunks();
            camera.position.y = getHeight(camera.position.x, camera.position.z) + 2;
            renderer.render(scene, camera);
        }
        animate();

        // Handle Window Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​