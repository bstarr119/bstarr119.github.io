<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Interactive Scene</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        // Simple Perlin Noise Implementation (adapted from public domain sources)
        const Noise = (function() {
            const p = [];
            for (let i = 0; i < 256; i++) p[i] = p[i + 256] = Math.floor(Math.random() * 256);
            function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
            function lerp(t, a, b) { return a + t * (b - a); }
            function grad(hash, x, y) {
                const h = hash & 15;
                const u = h < 8 ? x : y;
                const v = h < 4 ? y : h === 12 || h === 14 ? x : 0;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            }
            return {
                noise: function(x, y) {
                    const X = Math.floor(x) & 255;
                    const Y = Math.floor(y) & 255;
                    x -= Math.floor(x);
                    y -= Math.floor(y);
                    const u = fade(x);
                    const v = fade(y);
                    const A = p[X] + Y, B = p[X + 1] + Y;
                    return lerp(v, lerp(u, grad(p[A], x, y), grad(p[B], x - 1, y)),
                                   lerp(u, grad(p[A + 1], x, y - 1), grad(p[B + 1], x - 1, y - 1)));
                }
            };
        })();

        function fractalNoise(x, y, octaves = 4, persistence = 0.5) {
            let total = 0;
            let frequency = 0.02; // Adjusted for terrain scale
            let amplitude = 20;   // Max height of terrain
            let maxValue = 0;
            for (let i = 0; i < octaves; i++) {
                total += Noise.noise(x * frequency, y * frequency) * amplitude;
                maxValue += amplitude;
                amplitude *= persistence;
                frequency *= 2;
            }
            return total / maxValue;
        }

        function getHeight(worldX, worldZ) {
            const baseHeight = fractalNoise(worldX, worldZ);
            const riverWidth = 10;
            const riverDepth = 2;
            if (Math.abs(worldX) < riverWidth / 2) {
                return Math.min(baseHeight, -riverDepth);
            }
            return baseHeight;
        }

        // Scene Setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Lighting
        const sunLight = new THREE.DirectionalLight(0xffffff, 1);
        sunLight.position.set(100, 100, 100);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.set(1024, 1024);
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 500;
        sunLight.shadow.camera.left = -500;
        sunLight.shadow.camera.right = 500;
        sunLight.shadow.camera.top = 500;
        sunLight.shadow.camera.bottom = -500;
        scene.add(sunLight);

        const hemiLight = new THREE.HemisphereLight(0x87ceeb, 0x964b00, 0.3);
        scene.add(hemiLight);

        // Terrain Chunk Class
        class TerrainChunk {
            constructor(x, z, size, segments) {
                this.x = x;
                this.z = z;
                this.size = size;
                this.segments = segments;
                this.geometry = new THREE.PlaneGeometry(size, size, segments, segments);
                this.geometry.rotateX(-Math.PI / 2);
                this.material = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 1, metalness: 0 });
                this.mesh = new THREE.Mesh(this.geometry, this.material);
                this.mesh.receiveShadow = true;
                this.mesh.position.set(x * size, 0, z * size);
                scene.add(this.mesh);
                this.updateHeightmap();
            }

            updateHeightmap() {
                const positions = this.geometry.attributes.position;
                for (let i = 0; i < positions.count; i++) {
                    const x = positions.getX(i) + this.x * this.size;
                    const z = positions.getZ(i) + this.z * this.size;
                    const y = getHeight(x, z);
                    positions.setY(i, y);
                }
                positions.needsUpdate = true;
                this.geometry.computeVertexNormals();

                if (this.grassMesh) this.mesh.remove(this.grassMesh);
                this.generateGrass();

                if (this.waterMesh) this.mesh.remove(this.waterMesh);
                if (this.x === 0) {
                    const waterGeometry = new THREE.PlaneGeometry(10, this.size, 1, 1);
                    waterGeometry.rotateX(-Math.PI / 2);
                    const waterMaterial = new THREE.MeshStandardMaterial({
                        color: 0x0000ff,
                        transparent: true,
                        opacity: 0.5,
                        roughness: 0.1,
                        metalness: 0
                    });
                    this.waterMesh = new THREE.Mesh(waterGeometry, waterMaterial);
                    this.waterMesh.position.set(0, 0, 0);
                    this.mesh.add(this.waterMesh);
                }
            }

            generateGrass() {
                const bladeWidth = 0.1;
                const bladeHeight = 0.5;
                const grassGeometry = new THREE.PlaneGeometry(bladeWidth, bladeHeight);
                grassGeometry.translate(0, bladeHeight / 2, 0);
                if (!this.grassMaterial) {
                    this.grassMaterial = new THREE.MeshStandardMaterial({
                        color: 0x00ff00,
                        side: THREE.DoubleSide,
                        roughness: 0.8,
                        metalness: 0
                    });
                    this.grassMaterial.onBeforeCompile = (shader) => {
                        shader.uniforms.time = { value: 0 };
                        shader.vertexShader = `
                            uniform float time;
                            ${shader.vertexShader}
                        `.replace(
                            `#include <begin_vertex>`,
                            `#include <begin_vertex>
                            vec3 pos = position;
                            if (pos.y > 0.0) {
                                pos.x += sin(time + instanceMatrix[3].x) * 0.05;
                            }
                            transformed = pos;
                            `
                        );
                        this.grassShader = shader;
                    };
                }
                const count = 5000; // Reduced for mobile performance
                const dummy = new THREE.Object3D();
                this.grassMesh = new THREE.InstancedMesh(grassGeometry, this.grassMaterial, count);
                for (let i = 0; i < count; i++) {
                    const x = (Math.random() - 0.5) * this.size;
                    const z = (Math.random() - 0.5) * this.size;
                    const worldX = x + this.x * this.size;
                    const worldZ = z + this.z * this.size;
                    if (Math.abs(worldX) < 5) continue; // Skip river area
                    const y = getHeight(worldX, worldZ);
                    dummy.position.set(x, y, z);
                    dummy.updateMatrix();
                    this.grassMesh.setMatrixAt(i, dummy.matrix);
                }
                this.mesh.add(this.grassMesh);
            }
        }

        // Chunk Management
        const chunkSize = 100;
        const chunkSegments = 64;
        const viewDistance = 1;
        const chunkPool = [];
        for (let i = 0; i < 9; i++) {
            chunkPool.push(new TerrainChunk(0, 0, chunkSize, chunkSegments));
        }
        let currentCamI = 0;
        let currentCamJ = 0;

        function updateChunks() {
            const requiredChunks = [];
            for (let di = -viewDistance; di <= viewDistance; di++) {
                for (let dj = -viewDistance; dj <= viewDistance; dj++) {
                    requiredChunks.push({ i: currentCamI + di, j: currentCamJ + dj });
                }
            }
            requiredChunks.forEach((req, index) => {
                const chunk = chunkPool[index];
                if (chunk.x !== req.i || chunk.z !== req.j) {
                    chunk.x = req.i;
                    chunk.z = req.j;
                    chunk.mesh.position.set(req.i * chunkSize, 0, req.j * chunkSize);
                    chunk.updateHeightmap();
                }
            });
        }
        updateChunks();

        function checkCameraChunk() {
            const camI = Math.floor(camera.position.x / chunkSize);
            const camJ = Math.floor(camera.position.z / chunkSize);
            if (camI !== currentCamI || camJ !== currentCamJ) {
                currentCamI = camI;
                currentCamJ = camJ;
                updateChunks();
            }
        }

        // Touch Controls
        let isTouchingLeft = false;
        let isTouchingRight = false;
        let lastTouchX = 0;
        let lastTouchY = 0;
        let initialTouchX = 0;
        let initialTouchY = 0;
        let currentTouchX = 0;
        let currentTouchY = 0;

        renderer.domElement.addEventListener('touchstart', (event) => {
            event.preventDefault();
            const touch = event.touches[0];
            const x = touch.clientX;
            if (x < window.innerWidth / 2) {
                isTouchingLeft = true;
                lastTouchX = x;
                lastTouchY = touch.clientY;
            } else {
                isTouchingRight = true;
                initialTouchX = x;
                initialTouchY = touch.clientY;
                currentTouchX = x;
                currentTouchY = touch.clientY;
            }
        }, { passive: false });

        renderer.domElement.addEventListener('touchmove', (event) => {
            event.preventDefault();
            const touch = event.touches[0];
            const x = touch.clientX;
            const y = touch.clientY;
            if (isTouchingLeft) {
                const dx = x - lastTouchX;
                const dy = y - lastTouchY;
                const sensitivity = 0.005;
                camera.rotation.y -= dx * sensitivity;
                camera.rotation.x -= dy * sensitivity;
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
                lastTouchX = x;
                lastTouchY = y;
            } else if (isTouchingRight) {
                currentTouchX = x;
                currentTouchY = y;
            }
        }, { passive: false });

        renderer.domElement.addEventListener('touchend', (event) => {
            if (event.touches.length === 0) {
                isTouchingLeft = false;
                isTouchingRight = false;
            }
        });

        // Animation Loop
        function animate() {
            requestAnimationFrame(animate);
            if (chunkPool[0].grassShader) {
                chunkPool[0].grassShader.uniforms.time.value += 0.01;
            }
            if (isTouchingRight) {
                const dx = (currentTouchX - initialTouchX) * 0.01;
                const dy = (currentTouchY - initialTouchY) * 0.01;
                camera.translateX(dx);
                camera.translateZ(dy);
            }
            const camWorldX = camera.position.x;
            const camWorldZ = camera.position.z;
            camera.position.y = getHeight(camWorldX, camWorldZ) + 1.6;
            checkCameraChunk();
            renderer.render(scene, camera);
        }
        animate();

        // Handle Window Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​