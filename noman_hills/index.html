<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Walkthrough Scene</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/simplex-noise@2.4.0/simplex-noise.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(0, 5, 0);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xfff8e1, 1);
        sunLight.position.set(500, 500, 500);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 1500;
        sunLight.shadow.camera.left = -1000;
        sunLight.shadow.camera.right = 1000;
        sunLight.shadow.camera.top = 1000;
        sunLight.shadow.camera.bottom = -1000;
        scene.add(sunLight);

        // Lens flare (simplified, requires texture)
        const textureLoader = new THREE.TextureLoader();
        const flareTexture = textureLoader.load('https://threejs.org/examples/textures/lensflare/lensflare0.png');
        const lensflare = new THREE.Lensflare();
        lensflare.addElement(new THREE.LensflareElement(flareTexture, 700, 0, sunLight.color));
        const sunPos = sunLight.position.clone().normalize().multiplyScalar(1000);
        lensflare.position.copy(sunPos);
        scene.add(lensflare);

        // Terrain and chunks
        const chunkSize = 1000;
        const segments = 128; // Reduced for mobile performance
        const noise = new SimplexNoise();
        const chunks = {};
        const grassMeshes = {};

        function generateTerrainChunk(i, j) {
            const geometry = new THREE.PlaneGeometry(chunkSize, chunkSize, segments, segments);
            geometry.rotateX(-Math.PI / 2);
            const positions = geometry.attributes.position;
            const heights = new Float32Array((segments + 1) * (segments + 1));

            for (let k = 0; k < positions.count; k++) {
                const x = positions.getX(k) + i * chunkSize;
                const z = positions.getZ(k) + j * chunkSize;
                let y = noise.noise2D(x / 200, z / 200) * 20; // Rolling hills
                y += noise.noise2D(x / 500, z / 500) * 50; // Mountains
                y += noise.noise2D(x / 50, z / 50) * 5; // Small variations
                positions.setY(k, y);
                heights[k] = y;
            }

            geometry.computeVertexNormals();
            const material = new THREE.MeshStandardMaterial({
                color: 0x8b4513, // Dirt color placeholder
                roughness: 0.9,
                metalness: 0.1,
                // map: textureLoader.load('dirt_texture.jpg'),
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(i * chunkSize, 0, j * chunkSize);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            chunks[`${i},${j}`] = { mesh, heights };
            generateGrassForChunk(i, j);
        }

        function getTerrainHeight(x, z) {
            const cx = Math.floor(x / chunkSize);
            const cz = Math.floor(z / chunkSize);
            const chunk = chunks[`${cx},${cz}`];
            if (!chunk) return 0;

            const localX = x - cx * chunkSize + chunkSize / 2;
            const localZ = z - cz * chunkSize + chunkSize / 2;
            const gridX = (localX / chunkSize) * segments;
            const gridZ = (localZ / chunkSize) * segments;
            const i0 = Math.floor(gridX);
            const j0 = Math.floor(gridZ);
            const i1 = Math.min(i0 + 1, segments);
            const j1 = Math.min(j0 + 1, segments);

            if (i0 < 0 || i1 > segments || j0 < 0 || j1 > segments) return 0;

            const dx = gridX - i0;
            const dz = gridZ - j0;
            const idx00 = i0 + j0 * (segments + 1);
            const idx10 = i1 + j0 * (segments + 1);
            const idx01 = i0 + j1 * (segments + 1);
            const idx11 = i1 + j1 * (segments + 1);

            const h00 = chunk.heights[idx00];
            const h10 = chunk.heights[idx10];
            const h01 = chunk.heights[idx01];
            const h11 = chunk.heights[idx11];

            const h0 = h00 + (h10 - h00) * dx;
            const h1 = h01 + (h11 - h01) * dx;
            return h0 + (h1 - h0) * dz;
        }

        // Grass generation
        const bladeWidth = 0.1;
        const bladeHeight = 0.5;
        const bladeGeometry = new THREE.PlaneGeometry(bladeWidth, bladeHeight, 1, 1);
        const grassMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                grassColor: { value: new THREE.Color(0x228b22) },
            },
            vertexShader: `
                uniform float time;
                attribute vec3 instancePosition;
                varying vec2 vUv;
                void main() {
                    vec3 pos = position;
                    if (pos.y > 0.0) {
                        float wind = sin(time + instancePosition.x * 0.1 + instancePosition.z * 0.1) * 0.05;
                        pos.x += wind;
                        pos.z += wind;
                    }
                    vec4 mvPosition = modelViewMatrix * instanceMatrix * vec4(pos, 1.0);
                    gl_Position = projectionMatrix * mvPosition;
                    vUv = uv;
                }
            `,
            fragmentShader: `
                uniform vec3 grassColor;
                varying vec2 vUv;
                void main() {
                    gl_FragColor = vec4(grassColor, 1.0);
                    if (vUv.y < 0.1) gl_FragColor.a *= vUv.y / 0.1; // Fade base
                }
            `,
            side: THREE.DoubleSide,
        });

        function generateGrassForChunk(i, j) {
            const grassCount = 50000; // Per chunk
            const grassMesh = new THREE.InstancedMesh(bladeGeometry, grassMaterial, grassCount);
            grassMesh.castShadow = true;
            grassMesh.receiveShadow = true;
            scene.add(grassMesh);

            const dummy = new THREE.Object3D();
            for (let k = 0; k < grassCount; k++) {
                const x = (Math.random() - 0.5) * chunkSize + i * chunkSize;
                const z = (Math.random() - 0.5) * chunkSize + j * chunkSize;
                const density = noise.noise2D(x / 100, z / 100);
                if (density < -0.2) continue; // Sparse regions

                const y = getTerrainHeight(x, z) + bladeHeight / 2;
                dummy.position.set(x, y, z);
                dummy.rotation.y = Math.random() * Math.PI;
                dummy.scale.set(1, 1 + Math.random() * 0.5, 1);
                dummy.updateMatrix();
                grassMesh.setMatrixAt(k, dummy.matrix);
            }
            grassMesh.instanceMatrix.needsUpdate = true;
            grassMeshes[`${i},${j}`] = grassMesh;
        }

        // Initial chunk
        generateTerrainChunk(0, 0);

        // Touch controls
        let lookingTouchId = null;
        let movingTouchId = null;
        let previousX, previousY, startX, startY;
        let velocityX = 0, velocityZ = 0;
        const maxSpeed = 20;
        const rotationSpeed = 0.005;
        const cameraHeight = 1.7;

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            for (let touch of e.touches) {
                const x = touch.clientX;
                if (x < window.innerWidth / 2 && lookingTouchId === null) {
                    lookingTouchId = touch.identifier;
                    previousX = x;
                    previousY = touch.clientY;
                } else if (x >= window.innerWidth / 2 && movingTouchId === null) {
                    movingTouchId = touch.identifier;
                    startX = x;
                    startY = touch.clientY;
                }
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            for (let touch of e.touches) {
                if (touch.identifier === lookingTouchId) {
                    const currentX = touch.clientX;
                    const currentY = touch.clientY;
                    const deltaX = currentX - previousX;
                    const deltaY = currentY - previousY;
                    camera.rotation.y -= deltaX * rotationSpeed;
                    camera.rotation.x -= deltaY * rotationSpeed;
                    camera.rotation.x = Math.max(Math.min(camera.rotation.x, Math.PI / 2), -Math.PI / 2);
                    previousX = currentX;
                    previousY = currentY;
                } else if (touch.identifier === movingTouchId) {
                    const currentX = touch.clientX;
                    const currentY = touch.clientY;
                    let dx = currentX - startX;
                    let dy = currentY - startY;
                    const maxDrag = 100;
                    dx = Math.min(Math.max(dx, -maxDrag), maxDrag);
                    dy = Math.min(Math.max(dy, -maxDrag), maxDrag);
                    velocityX = (dx / maxDrag) * maxSpeed;
                    velocityZ = (dy / maxDrag) * maxSpeed;
                }
            }
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            for (let touch of e.changedTouches) {
                if (touch.identifier === lookingTouchId) {
                    lookingTouchId = null;
                } else if (touch.identifier === movingTouchId) {
                    movingTouchId = null;
                    velocityX = 0;
                    velocityZ = 0;
                }
            }
        });

        // Window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation loop
        let lastTime = 0;
        function animate(time) {
            const deltaTime = Math.min((time - lastTime) / 1000, 0.1);
            lastTime = time;

            // Update grass wind
            grassMaterial.uniforms.time.value = time / 1000;

            // Move camera
            if (movingTouchId !== null) {
                camera.translateX(velocityX * deltaTime);
                camera.translateZ(velocityZ * deltaTime);
            }

            // Adjust camera height
            const terrainHeight = getTerrainHeight(camera.position.x, camera.position.z);
            camera.position.y = terrainHeight + cameraHeight;

            // Procedural chunk generation
            const cx = Math.floor(camera.position.x / chunkSize);
            const cz = Math.floor(camera.position.z / chunkSize);
            for (let i = cx - 1; i <= cx + 1; i++) {
                for (let j = cz - 1; j <= cz + 1; j++) {
                    const key = `${i},${j}`;
                    if (!chunks[key]) {
                        generateTerrainChunk(i, j);
                    }
                }
            }

            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }
        requestAnimationFrame(animate);
    </script>
</body>
</html>
​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​