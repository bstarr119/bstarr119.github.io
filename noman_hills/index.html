<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Immersive 3D Scene</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <!-- Three.js Core -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <!-- LensFlare from Three.js examples (for sun effect) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/effects/LensFlare.js"></script>

    <script>
        // Scene Setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 1); // Soft ambient light
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
        sunLight.position.set(100, 100, 100);
        scene.add(sunLight);

        // Sun with Lens Flare
        const textureLoader = new THREE.TextureLoader();
        const flareTexture = textureLoader.load('https://threejs.org/examples/textures/lensflare/lensflare0.png');
        const lensFlare = new THREE.LensFlare();
        lensFlare.addElement(new THREE.LensFlareElement(flareTexture, 700, 0, sunLight.color));
        lensFlare.position.copy(sunLight.position);
        scene.add(lensFlare);

        // Simple Noise Function (for procedural generation)
        function noise(x, y) {
            const n = x + y * 57;
            const nn = (n << 13) ^ n;
            return (1.0 - ((nn * (nn * nn * 15731 + 789221) + 1376312589) & 0x7fffffff) / 1073741824.0);
        }

        // Terrain Generation
        const chunks = {};
        const CHUNK_SIZE = 100;
        const SEGMENTS = 100;

        function generateHeights(chunkX, chunkZ) {
            const heights = new Float32Array((SEGMENTS + 1) * (SEGMENTS + 1));
            for (let zi = 0; zi <= SEGMENTS; zi++) {
                for (let xi = 0; xi <= SEGMENTS; xi++) {
                    const x = chunkX * CHUNK_SIZE + (xi / SEGMENTS - 0.5) * CHUNK_SIZE;
                    const z = chunkZ * CHUNK_SIZE + (zi / SEGMENTS - 0.5) * CHUNK_SIZE;
                    let height = 0;
                    // Multiple octaves for varied terrain
                    for (let octave = 0; octave < 4; octave++) {
                        const freq = 0.01 * Math.pow(2, octave);
                        const amp = 10 / Math.pow(2, octave);
                        height += noise(x * freq, z * freq) * amp;
                    }
                    // Add river valley along z=0
                    height += -10 * Math.exp(-(z / 10) ** 2);
                    // Vary terrain type (mountains, dunes)
                    const regionNoise = noise(chunkX * 0.1, chunkZ * 0.1);
                    if (regionNoise > 0.5) height *= 2; // Mountains
                    else if (regionNoise < -0.5) height *= 0.5; // Dunes
                    heights[zi * (SEGMENTS + 1) + xi] = height;
                }
            }
            return heights;
        }

        function createTerrainChunk(chunkX, chunkZ) {
            const geometry = new THREE.PlaneGeometry(CHUNK_SIZE, CHUNK_SIZE, SEGMENTS, SEGMENTS);
            const heights = generateHeights(chunkX, chunkZ);
            const vertices = geometry.attributes.position.array;
            for (let i = 0, j = 0; i < vertices.length; i += 3, j++) {
                vertices[i + 2] = heights[j];
            }
            geometry.computeVertexNormals();
            const dirtTexture = textureLoader.load('https://threejs.org/examples/textures/terrain/dirt.jpg');
            dirtTexture.wrapS = dirtTexture.wrapT = THREE.RepeatWrapping;
            dirtTexture.repeat.set(10, 10);
            const material = new THREE.MeshStandardMaterial({ map: dirtTexture, roughness: 0.8, metalness: 0.2 });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.rotation.x = -Math.PI / 2;
            mesh.position.set(chunkX * CHUNK_SIZE, 0, chunkZ * CHUNK_SIZE);
            mesh.userData = { heights, segments: SEGMENTS, width: CHUNK_SIZE, height: CHUNK_SIZE };
            return mesh;
        }

        // Grass Generation
        const grassGeometry = new THREE.BufferGeometry();
        const grassVertices = new Float32Array([
            0, 0, 0,    // Bottom left
            0, 1, 0,    // Top left
            0.1, 0, 0,  // Bottom right
            0.1, 1, 0   // Top right
        ]);
        const grassIndices = [0, 1, 2, 2, 1, 3];
        grassGeometry.setAttribute('position', new THREE.BufferAttribute(grassVertices, 3));
        grassGeometry.setIndex(grassIndices);

        const grassMaterial = new THREE.ShaderMaterial({
            uniforms: { time: { value: 0 } },
            vertexShader: `
                uniform float time;
                void main() {
                    vec3 pos = position;
                    pos.x += sin(time + pos.y * 2.0) * 0.05 * (pos.y > 0.5 ? 1.0 : 0.0); // Wind effect
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `,
            fragmentShader: `
                void main() {
                    gl_FragColor = vec4(0.0, 0.8, 0.2, 1.0); // Green grass
                }
            `,
            side: THREE.DoubleSide
        });

        function addGrassToChunk(chunk) {
            const numBlades = 10000; // Dense grass
            const grassMesh = new THREE.InstancedMesh(grassGeometry, grassMaterial, numBlades);
            const dummy = new THREE.Object3D();
            let bladeCount = 0;
            for (let i = 0; i < numBlades; i++) {
                const x = chunk.position.x + (Math.random() - 0.5) * CHUNK_SIZE;
                const z = chunk.position.z + (Math.random() - 0.5) * CHUNK_SIZE;
                const y = getHeightAt(x, z);
                // Skip grass in some areas or if below river level
                if (Math.random() < 0.2 || y < -5) continue;
                dummy.position.set(x, y, z);
                dummy.rotation.y = Math.random() * Math.PI * 2;
                dummy.scale.set(0.5 + Math.random() * 0.5, 0.5 + Math.random() * 0.5, 1);
                dummy.updateMatrix();
                grassMesh.setMatrixAt(bladeCount++, dummy.matrix);
            }
            grassMesh.count = bladeCount; // Adjust count based on actual blades
            scene.add(grassMesh);
            chunk.userData.grassMesh = grassMesh;
        }

        // Height Query Function
        function getHeightAt(x, z) {
            const chunkX = Math.floor(x / CHUNK_SIZE + 0.5);
            const chunkZ = Math.floor(z / CHUNK_SIZE + 0.5);
            const key = `${chunkX},${chunkZ}`;
            const chunk = chunks[key];
            if (!chunk) return 0;
            const localX = x - chunkX * CHUNK_SIZE;
            const localZ = z - chunkZ * CHUNK_SIZE;
            const xi = (localX / CHUNK_SIZE + 0.5) * SEGMENTS;
            const zi = (localZ / CHUNK_SIZE + 0.5) * SEGMENTS;
            const xi0 = Math.floor(xi);
            const xi1 = Math.min(xi0 + 1, SEGMENTS);
            const zi0 = Math.floor(zi);
            const zi1 = Math.min(zi0 + 1, SEGMENTS);
            const heights = chunk.userData.heights;
            const h00 = heights[zi0 * (SEGMENTS + 1) + xi0];
            const h10 = heights[zi0 * (SEGMENTS + 1) + xi1];
            const h01 = heights[zi1 * (SEGMENTS + 1) + xi0];
            const h11 = heights[zi1 * (SEGMENTS + 1) + xi1];
            const tx = xi - xi0;
            const ty = zi - zi0;
            return h00 * (1 - tx) * (1 - ty) + h10 * tx * (1 - ty) + h01 * (1 - tx) * ty + h11 * tx * ty;
        }

        // Initial Terrain
        for (let i = -1; i <= 1; i++) {
            for (let j = -1; j <= 1; j++) {
                const chunk = createTerrainChunk(i, j);
                scene.add(chunk);
                addGrassToChunk(chunk);
                chunks[`${i},${j}`] = chunk;
            }
        }

        // Flowing River
        const waterGeometry = new THREE.PlaneGeometry(2000, 20);
        const waterMaterial = new THREE.MeshStandardMaterial({
            color: 0x1e90ff,
            transparent: true,
            opacity: 0.8,
            roughness: 0.1,
            metalness: 0.2
        });
        const water = new THREE.Mesh(waterGeometry, waterMaterial);
        water.rotation.x = -Math.PI / 2;
        water.position.set(0, -5, 0);
        scene.add(water);

        // Camera Controls
        const activeTouches = new Map();
        const maxDelta = 100;
        const maxYawSpeed = Math.PI;
        const maxPitchSpeed = Math.PI / 2;
        const maxForwardSpeed = 10;

        renderer.domElement.addEventListener('touchstart', (event) => {
            event.preventDefault();
            for (let touch of event.changedTouches) {
                const side = touch.clientX < window.innerWidth / 2 ? 'left' : 'right';
                activeTouches.set(touch.identifier, {
                    side,
                    initialX: touch.clientX,
                    initialY: touch.clientY,
                    currentX: touch.clientX,
                    currentY: touch.clientY
                });
            }
        }, false);

        renderer.domElement.addEventListener('touchmove', (event) => {
            event.preventDefault();
            for (let touch of event.changedTouches) {
                if (activeTouches.has(touch.identifier)) {
                    const touchData = activeTouches.get(touch.identifier);
                    touchData.currentX = touch.clientX;
                    touchData.currentY = touch.clientY;
                }
            }
        }, false);

        renderer.domElement.addEventListener('touchend', (event) => {
            event.preventDefault();
            for (let touch of event.changedTouches) {
                activeTouches.delete(touch.identifier);
            }
        }, false);

        // Animation Loop
        const clock = new THREE.Clock();
        camera.position.set(0, 10, 0);

        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();

            // Update grass wind
            grassMaterial.uniforms.time.value = performance.now() / 1000;

            // Camera controls
            let yawSpeed = 0;
            let pitchSpeed = 0;
            let forwardSpeed = 0;
            for (let [_, touchData] of activeTouches) {
                const deltaX = touchData.currentX - touchData.initialX;
                const deltaY = touchData.currentY - touchData.initialY;
                if (touchData.side === 'left') {
                    yawSpeed += (deltaX / maxDelta) * maxYawSpeed;
                    pitchSpeed += (deltaY / maxDelta) * maxPitchSpeed;
                } else {
                    yawSpeed += (deltaX / maxDelta) * maxYawSpeed;
                    forwardSpeed += (-deltaY / maxDelta) * maxForwardSpeed; // Up = forward
                }
            }

            // Update camera
            camera.rotation.order = 'YXZ'; // Yaw then pitch
            camera.rotation.y += yawSpeed * deltaTime;
            camera.rotation.x += pitchSpeed * deltaTime;
            camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            camera.position.add(forward.multiplyScalar(forwardSpeed * deltaTime));
            camera.position.y = getHeightAt(camera.position.x, camera.position.z) + 1.7;

            // Manage chunks
            const camChunkX = Math.floor(camera.position.x / CHUNK_SIZE + 0.5);
            const camChunkZ = Math.floor(camera.position.z / CHUNK_SIZE + 0.5);
            const radius = 2;
            for (let i = camChunkX - radius; i <= camChunkX + radius; i++) {
                for (let j = camChunkZ - radius; j <= camChunkZ + radius; j++) {
                    const key = `${i},${j}`;
                    if (!chunks[key]) {
                        const chunk = createTerrainChunk(i, j);
                        scene.add(chunk);
                        addGrassToChunk(chunk);
                        chunks[key] = chunk;
                    }
                }
            }

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​