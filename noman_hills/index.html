<html>
<head>
    <title>3D Navigable Scene</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <!-- Include Three.js from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <!-- Include Simplex Noise for procedural generation -->
    <script src="https://cdn.jsdelivr.net/npm/simplex-noise@2.4.0/simplex-noise.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 0); // Eye height at 1.6 units

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows
        document.body.appendChild(renderer.domElement);

        // Lighting
        const sun = new THREE.DirectionalLight(0xffffff, 1);
        sun.position.set(100, 100, 100);
        sun.castShadow = true;
        sun.shadow.mapSize.width = 2048; // Higher resolution shadows
        sun.shadow.mapSize.height = 2048;
        sun.shadow.camera.near = 0.5;
        sun.shadow.camera.far = 500;
        sun.shadow.camera.left = -200;
        sun.shadow.camera.right = 200;
        sun.shadow.camera.top = 200;
        sun.shadow.camera.bottom = -200;
        scene.add(sun);

        const ambient = new THREE.AmbientLight(0x404040); // Soft ambient light
        scene.add(ambient);

        // Simple lens flare effect (using a sprite)
        const flareTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/lensflare/lensflare0.png');
        const flareMaterial = new THREE.SpriteMaterial({ map: flareTexture, color: 0xffffff, transparent: true, blending: THREE.AdditiveBlending });
        const lensFlare = new THREE.Sprite(flareMaterial);
        lensFlare.position.copy(sun.position);
        lensFlare.scale.set(5, 5, 1);
        scene.add(lensFlare);

        // Noise for procedural generation
        const noise = new SimplexNoise();

        // Terrain management
        const chunkSize = 64;
        const renderDistance = 2; // Chunks around the camera
        const chunks = new Map(); // Key: "x,z", Value: THREE.Mesh

        function getHeight(x, z) {
            // Multi-octave noise for varied terrain
            const scale = 0.005;
            let height = noise.noise2D(x * scale, z * scale) * 10; // Base height
            height += noise.noise2D(x * scale * 2, z * scale * 2) * 5; // Medium details
            height += noise.noise2D(x * scale * 4, z * scale * 4) * 2; // Fine details
            return Math.max(-10, Math.min(50, height)); // Clamp between -10 and 50
        }

        function generateChunk(chunkX, chunkZ) {
            const key = `${chunkX},${chunkZ}`;
            if (chunks.has(key)) return;

            const geometry = new THREE.PlaneGeometry(chunkSize, chunkSize, 32, 32);
            geometry.rotateX(-Math.PI / 2);
            const vertices = geometry.attributes.position.array;

            for (let i = 0; i < vertices.length; i += 3) {
                const x = chunkX * chunkSize + vertices[i];
                const z = chunkZ * chunkSize + vertices[i + 2];
                vertices[i + 1] = getHeight(x, z);
            }
            geometry.computeVertexNormals(); // For lighting

            const material = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 1, metalness: 0 });
            const chunk = new THREE.Mesh(geometry, material);
            chunk.position.set(chunkX * chunkSize, 0, chunkZ * chunkSize);
            chunk.receiveShadow = true;
            chunk.castShadow = true;
            scene.add(chunk);
            chunks.set(key, chunk);

            // Add grass to this chunk
            addGrassToChunk(chunkX, chunkZ);
        }

        // Grass setup
        const bladeCountPerChunk = 5000; // Adjust based on performance
        const bladeWidth = 0.1;
        const bladeGeometry = new THREE.PlaneGeometry(bladeWidth, 1, 1, 1);
        const bladeMaterial = new THREE.ShaderMaterial({
            uniforms: { time: { value: 0 } },
            vertexShader: `
                uniform float time;
                void main() {
                    vec3 pos = position;
                    vec4 worldPos = modelMatrix * instanceMatrix * vec4(0.0, 0.0, 0.0, 1.0);
                    if (pos.y > 0.4) {
                        float wind = sin(time + worldPos.x * 0.1 + worldPos.z * 0.1) * 0.1;
                        pos.x += wind;
                        pos.z += wind;
                    }
                    gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(pos, 1.0);
                }
            `,
            fragmentShader: `
                void main() {
                    gl_FragColor = vec4(0.0, 0.8, 0.0, 1.0); // Slightly darker green
                }
            `,
            side: THREE.DoubleSide
        });

        function addGrassToChunk(chunkX, chunkZ) {
            const blades = new THREE.InstancedMesh(bladeGeometry, bladeMaterial, bladeCountPerChunk);
            const dummy = new THREE.Object3D();
            for (let i = 0; i < bladeCountPerChunk; i++) {
                const x = chunkX * chunkSize + Math.random() * chunkSize - chunkSize / 2;
                const z = chunkZ * chunkSize + Math.random() * chunkSize - chunkSize / 2;
                const height = getHeight(x, z);
                // Skip grass in low areas (e.g., river) or randomly for patches
                if (height < -2 || Math.random() < 0.2) continue;
                dummy.position.set(x, height + 0.5, z);
                dummy.updateMatrix();
                blades.setMatrixAt(i % bladeCountPerChunk, dummy.matrix);
            }
            blades.castShadow = true;
            blades.receiveShadow = true;
            scene.add(blades);
            chunks.set(`${chunkX},${chunkZ}_grass`, blades);
        }

        // River (simple straight river for now)
        const riverGeometry = new THREE.PlaneGeometry(chunkSize * 2, 10, 32, 1);
        riverGeometry.rotateX(-Math.PI / 2);
        const riverMaterial = new THREE.ShaderMaterial({
            uniforms: { time: { value: 0 } },
            vertexShader: `
                uniform float time;
                void main() {
                    vec3 pos = position;
                    pos.y += sin(pos.x * 0.1 + time) * 0.2; // Simple wave
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `,
            fragmentShader: `
                void main() {
                    gl_FragColor = vec4(0.0, 0.5, 1.0, 0.8); // Blue with transparency
                }
            `,
            side: THREE.DoubleSide,
            transparent: true
        });
        const river = new THREE.Mesh(riverGeometry, riverMaterial);
        river.position.set(0, -2, 0); // Below terrain base level
        scene.add(river);

        // Controls
        const movement = { forward: false, backward: false, left: false, right: false };
        let lookTouchId = null, movementTouchId = null;
        let lookInitialPos = { x: 0, y: 0 }, movementInitialPos = { x: 0, y: 0 };
        let currentLookPos = { x: 0, y: 0 }, currentMovementPos = { x: 0, y: 0 };
        let movementSpeedForward = 0, movementYawSpeed = 0;
        let prevMouseX = 0, prevMouseY = 0, mouseMoved = false;

        // Desktop controls
        document.addEventListener('keydown', (event) => {
            switch (event.code) {
                case 'KeyW': movement.forward = true; break;
                case 'KeyS': movement.backward = true; break;
                case 'KeyA': movement.left = true; break;
                case 'KeyD': movement.right = true; break;
            }
        });

        document.addEventListener('keyup', (event) => {
            switch (event.code) {
                case 'KeyW': movement.forward = false; break;
                case 'KeyS': movement.backward = false; break;
                case 'KeyA': movement.left = false; break;
                case 'KeyD': movement.right = false; break;
            }
        });

        document.addEventListener('mousemove', (event) => {
            if (!mouseMoved) {
                prevMouseX = event.clientX;
                prevMouseY = event.clientY;
                mouseMoved = true;
                return;
            }
            const deltaX = event.clientX - prevMouseX;
            const deltaY = event.clientY - prevMouseY;
            prevMouseX = event.clientX;
            prevMouseY = event.clientY;
            camera.rotation.y -= deltaX * 0.002;
            camera.rotation.x -= deltaY * 0.002;
            camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
        });

        // Mobile controls
        document.addEventListener('touchstart', (event) => {
            event.preventDefault();
            for (const touch of event.changedTouches) {
                const x = touch.clientX;
                const y = touch.clientY;
                if (x < window.innerWidth / 2 && lookTouchId === null) {
                    lookTouchId = touch.identifier;
                    lookInitialPos = { x, y };
                    currentLookPos = { x, y };
                } else if (x >= window.innerWidth / 2 && movementTouchId === null) {
                    movementTouchId = touch.identifier;
                    movementInitialPos = { x, y };
                    currentMovementPos = { x, y };
                }
            }
        }, { passive: false });

        document.addEventListener('touchmove', (event) => {
            event.preventDefault();
            for (const touch of event.changedTouches) {
                if (touch.identifier === lookTouchId) {
                    const prevX = currentLookPos.x;
                    const prevY = currentLookPos.y;
                    currentLookPos = { x: touch.clientX, y: touch.clientY };
                    const deltaX = currentLookPos.x - prevX;
                    const deltaY = currentLookPos.y - prevY;
                    camera.rotation.y -= deltaX * 0.01;
                    camera.rotation.x -= deltaY * 0.01;
                    camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
                } else if (touch.identifier === movementTouchId) {
                    currentMovementPos = { x: touch.clientX, y: touch.clientY };
                    const dx = currentMovementPos.x - movementInitialPos.x;
                    const dy = currentMovementPos.y - movementInitialPos.y;
                    movementSpeedForward = -dy * 0.1; // Up is forward
                    movementYawSpeed = dx * 0.005; // Left/right yaws
                }
            }
        }, { passive: false });

        document.addEventListener('touchend', (event) => {
            event.preventDefault();
            for (const touch of event.changedTouches) {
                if (touch.identifier === lookTouchId) {
                    lookTouchId = null;
                } else if (touch.identifier === movementTouchId) {
                    movementTouchId = null;
                    movementSpeedForward = 0;
                    movementYawSpeed = 0;
                }
            }
        }, { passive: false });

        // Animation loop
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();
            const time = clock.getElapsedTime();

            // Update shaders
            bladeMaterial.uniforms.time.value = time;
            riverMaterial.uniforms.time.value = time;

            // Movement
            let speedForward = 0, speedStrafe = 0;
            if (movement.forward) speedForward = 10;
            else if (movement.backward) speedForward = -10;
            if (movement.left) speedStrafe = -10;
            else if (movement.right) speedStrafe = 10;

            if (movementTouchId !== null) {
                speedForward = movementSpeedForward;
                camera.rotation.y -= movementYawSpeed * deltaTime; // Apply yaw
            }

            if (speedForward !== 0 || speedStrafe !== 0) {
                const forwardDir = camera.getWorldDirection(new THREE.Vector3());
                camera.position.addScaledVector(forwardDir, speedForward * deltaTime);
                const rightDir = new THREE.Vector3().crossVectors(camera.up, forwardDir).normalize();
                camera.position.addScaledVector(rightDir, speedStrafe * deltaTime);
            }

            // Update terrain chunks
            const chunkX = Math.floor(camera.position.x / chunkSize);
            const chunkZ = Math.floor(camera.position.z / chunkSize);
            for (let x = chunkX - renderDistance; x <= chunkX + renderDistance; x++) {
                for (let z = chunkZ - renderDistance; z <= chunkZ + renderDistance; z++) {
                    generateChunk(x, z);
                }
            }

            // Clean up distant chunks (optional optimization)
            for (const [key, chunk] of chunks) {
                const [cx, cz] = key.split(',').map(Number);
                if (Math.abs(cx - chunkX) > renderDistance + 1 || Math.abs(cz - chunkZ) > renderDistance + 1) {
                    scene.remove(chunk);
                    chunks.delete(key);
                }
            }

            renderer.render(scene, camera);
        }

        // Initial chunk generation
        generateChunk(0, 0);
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
