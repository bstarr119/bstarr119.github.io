<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Scene with Three.js</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/simplex-noise@2.4.0/simplex-noise.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Handle window resize
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });

        // Noise instances for terrain and river
        const noise = new SimplexNoise();
        const riverNoise = new SimplexNoise('river');

        // Height function for terrain and river
        function getHeight(x, z) {
            const riverX = riverNoise.noise2D(0, z / 100) * 50;
            const distanceToRiver = Math.abs(x - riverX);
            const riverWidth = 10;
            let height = noise.noise2D(x / 50, z / 50) * 20; // Base terrain height
            if (distanceToRiver < riverWidth) {
                return -5 + (distanceToRiver / riverWidth) * 2; // River bed with smooth transition
            }
            // Add larger features like mountains
            const mountainNoise = noise.noise2D(x / 200, z / 200);
            height += mountainNoise > 0.5 ? (mountainNoise - 0.5) * 40 : 0; // Tall mountains
            return height;
        }

        // Grass geometry (single blade)
        const grassGeometry = new THREE.PlaneGeometry(0.1, 0.5);
        grassGeometry.translate(0, 0.25, 0); // Base at ground level

        // Grass material with swaying shader
        const grassMaterial = new THREE.ShaderMaterial({
            uniforms: { time: { value: 0.0 } },
            vertexShader: `
                uniform float time;
                void main() {
                    vec3 pos = position;
                    if (pos.y > 0.0) { // Sway top vertices
                        float sway = sin(time + instanceMatrix[3][0] + instanceMatrix[3][2]) * 0.1;
                        pos.x += sway;
                    }
                    gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(pos, 1.0);
                }
            `,
            fragmentShader: `
                void main() {
                    gl_FragColor = vec4(0.0, 0.8, 0.0, 1.0); // Green grass
                }
            `,
            side: THREE.DoubleSide
        });

        // Terrain material with dirt texture
        const textureLoader = new THREE.TextureLoader();
        const dirtTexture = textureLoader.load('https://threejs.org/examples/textures/terrain/rock.jpg'); // Using rock.jpg as a dirt substitute
        dirtTexture.wrapS = THREE.RepeatWrapping;
        dirtTexture.wrapT = THREE.RepeatWrapping;
        dirtTexture.repeat.set(10, 10);
        const terrainMaterial = new THREE.MeshStandardMaterial({ map: dirtTexture });

        // Function to create a terrain chunk with grass
        function createChunk(cx, cz) {
            // Terrain geometry
            const width = 100;
            const height = 100;
            const widthSegments = 100;
            const heightSegments = 100;
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const indices = [];
            const segmentWidth = width / widthSegments;
            const segmentHeight = height / heightSegments;

            for (let i = 0; i <= widthSegments; i++) {
                for (let j = 0; j <= heightSegments; j++) {
                    const x = cx * width + i * segmentWidth;
                    const z = cz * height + j * segmentHeight;
                    const y = getHeight(x, z);
                    positions.push(x, y, z);
                }
            }

            for (let i = 0; i < widthSegments; i++) {
                for (let j = 0; j < heightSegments; j++) {
                    const a = i * (heightSegments + 1) + j;
                    const b = a + 1;
                    const c = (i + 1) * (heightSegments + 1) + j;
                    const d = c + 1;
                    indices.push(a, b, d, a, d, c);
                }
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setIndex(indices);
            geometry.computeVertexNormals();
            const terrainMesh = new THREE.Mesh(geometry, terrainMaterial);
            scene.add(terrainMesh);

            // Grass instancing
            const grassCount = 10000; // Adjust based on performance
            const grassMesh = new THREE.InstancedMesh(grassGeometry, grassMaterial, grassCount);
            const dummy = new THREE.Object3D();
            let instanceIndex = 0;
            for (let i = 0; i < grassCount; i++) {
                const x = cx * 100 + Math.random() * 100;
                const z = cz * 100 + Math.random() * 100;
                const y = getHeight(x, z);
                const grassDensity = noise.noise2D(x / 20, z / 20);
                if (y > 0 && grassDensity > -0.2) { // Above water and in grassy areas
                    dummy.position.set(x, y, z);
                    dummy.updateMatrix();
                    grassMesh.setMatrixAt(instanceIndex++, dummy.matrix);
                }
            }
            grassMesh.count = instanceIndex; // Only render placed instances
            scene.add(grassMesh);

            return { terrain: terrainMesh, grass: grassMesh };
        }

        // Water plane
        const waterGeometry = new THREE.PlaneGeometry(10000, 10000, 1, 1);
        waterGeometry.rotateX(-Math.PI / 2);
        const waterMaterial = new THREE.MeshStandardMaterial({
            color: 0x1e90ff,
            transparent: true,
            opacity: 0.7
        });
        const water = new THREE.Mesh(waterGeometry, waterMaterial);
        water.position.y = 0;
        scene.add(water);

        // Lighting
        const sunLight = new THREE.DirectionalLight(0xffffff, 1);
        sunLight.position.set(100, 100, 100);
        scene.add(sunLight);
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        // Lens flare
        function createFlareTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.beginPath();
            ctx.arc(128, 128, 100, 0, Math.PI * 2);
            ctx.fillStyle = 'white';
            ctx.fill();
            return new THREE.CanvasTexture(canvas);
        }
        const flareTexture = createFlareTexture();
        const flareMaterial = new THREE.SpriteMaterial({
            map: flareTexture,
            color: 0xffffff,
            transparent: true,
            blending: THREE.AdditiveBlending
        });
        const flare = new THREE.Sprite(flareMaterial);
        flare.scale.set(10, 10, 1);
        flare.position.copy(sunLight.position);
        scene.add(flare);

        // Camera controls
        let leftTouchId = null, rightTouchId = null;
        let startTouchXLeft, startTouchYLeft, currentTouchXLeft, currentTouchYLeft;
        let startTouchXRight, startTouchYRight, currentTouchXRight, currentTouchYRight;
        let moveSpeed = 0;
        const yawSpeed = 0.005;
        const pitchSpeed = 0.005;

        document.addEventListener('touchstart', (event) => {
            for (let touch of event.changedTouches) {
                const x = touch.clientX;
                if (x < window.innerWidth / 2 && leftTouchId === null) {
                    leftTouchId = touch.identifier;
                    startTouchXLeft = x;
                    startTouchYLeft = touch.clientY;
                    currentTouchXLeft = x;
                    currentTouchYLeft = touch.clientY;
                } else if (x >= window.innerWidth / 2 && rightTouchId === null) {
                    rightTouchId = touch.identifier;
                    startTouchXRight = x;
                    startTouchYRight = touch.clientY;
                    currentTouchXRight = x;
                    currentTouchYRight = touch.clientY;
                }
            }
        });

        document.addEventListener('touchmove', (event) => {
            for (let touch of event.changedTouches) {
                if (touch.identifier === leftTouchId) {
                    currentTouchXLeft = touch.clientX;
                    currentTouchYLeft = touch.clientY;
                    const deltaX = currentTouchXLeft - startTouchXLeft;
                    const deltaY = currentTouchYLeft - startTouchYLeft;
                    camera.rotation.y -= deltaX * yawSpeed;
                    camera.rotation.x -= deltaY * pitchSpeed;
                    camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
                    startTouchXLeft = currentTouchXLeft;
                    startTouchYLeft = currentTouchYLeft;
                } else if (touch.identifier === rightTouchId) {
                    currentTouchXRight = touch.clientX;
                    currentTouchYRight = touch.clientY;
                    const deltaX = currentTouchXRight - startTouchXRight;
                    camera.rotation.y -= deltaX * yawSpeed;
                    startTouchXRight = currentTouchXRight;
                    const deltaY = startTouchYRight - currentTouchYRight;
                    moveSpeed = deltaY * 0.001;
                }
            }
        });

        document.addEventListener('touchend', (event) => {
            for (let touch of event.changedTouches) {
                if (touch.identifier === leftTouchId) {
                    leftTouchId = null;
                } else if (touch.identifier === rightTouchId) {
                    rightTouchId = null;
                    moveSpeed = 0;
                }
            }
        });

        // Chunk management
        const loadedChunks = new Map();
        const chunkSize = 100;

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Update grass swaying
            grassMaterial.uniforms.time.value = performance.now() / 1000;

            // Camera movement
            if (rightTouchId !== null) {
                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                forward.y = 0;
                forward.normalize();
                camera.position.add(forward.multiplyScalar(moveSpeed));
            }

            // Chunk loading/unloading
            const cameraChunkX = Math.floor(camera.position.x / chunkSize);
            const cameraChunkZ = Math.floor(camera.position.z / chunkSize);
            const loadRadius = 2;
            const chunksToLoad = [];
            for (let cx = cameraChunkX - loadRadius; cx <= cameraChunkX + loadRadius; cx++) {
                for (let cz = cameraChunkZ - loadRadius; cz <= cameraChunkZ + loadRadius; cz++) {
                    chunksToLoad.push(`${cx},${cz}`);
                }
            }

            const chunksToLoadSet = new Set(chunksToLoad);
            for (let key of [...loadedChunks.keys()]) {
                const baseKey = key.split('_')[0];
                if (!chunksToLoadSet.has(baseKey)) {
                    const obj = loadedChunks.get(key);
                    scene.remove(obj);
                    obj.geometry.dispose();
                    if (obj.material.dispose) obj.material.dispose();
                    loadedChunks.delete(key);
                }
            }

            for (let key of chunksToLoad) {
                if (!loadedChunks.has(key)) {
                    const [cx, cz] = key.split(',').map(Number);
                    const chunk = createChunk(cx, cz);
                    loadedChunks.set(`${cx},${cz}`, chunk.terrain);
                    loadedChunks.set(`${cx},${cz}_grass`, chunk.grass);
                }
            }

            renderer.render(scene, camera);
        }

        // Initialize camera position
        camera.position.set(0, 15, 0);
        camera.lookAt(0, 0, 0);

        // Start animation
        animate();
    </script>
</body>
</html>
​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​