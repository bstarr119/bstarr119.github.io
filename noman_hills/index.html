<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Walkthrough Scene</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <!-- Include Three.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Include Simplex Noise for procedural generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.y = 1.6; // Eye height, will be adjusted to terrain

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio); // Optimize for mobile screens
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Background (simple sky color for now)
        scene.background = new THREE.Color(0x87CEEB);

        // Lighting for realism
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1); // Sun
        directionalLight.position.set(50, 50, 50);
        scene.add(directionalLight);

        const ambientLight = new THREE.AmbientLight(0x404040, 0.5); // Soft ambient light
        scene.add(ambientLight);

        const hemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x8B4513, 0.3); // Sky and ground colors
        scene.add(hemisphereLight);

        // Simplex Noise for terrain generation
        const noise = new SimplexNoise();

        // Constants
        const chunkSize = 64;
        const chunkSegments = 64;
        const noiseScale = 0.05;
        const heightScale = 20; // Increased for taller mountains and deeper valleys
        const viewDistance = 3;

        // Touch control variables
        let rotationTouchId = null;
        let movementTouchId = null;
        let previousTouchPosition = {};
        const rotationSpeed = 0.005;
        const movementSpeed = 0.1;
        const centerX = window.innerWidth * 0.75; // Center of right half
        const centerY = window.innerHeight * 0.5;

        // Chunk management
        const loadedChunks = {};

        // Time for animations
        let time = 0;

        // Grass blade geometry (simple plane, centered at base)
        const bladeGeometry = new THREE.PlaneGeometry(0.1, 0.5, 1, 1);
        bladeGeometry.translate(0, 0.25, 0);

        // Grass shader for wind animation
        const grassVertexShader = `
            uniform float time;
            varying vec2 vUv;
            void main() {
                vec3 pos = position;
                float windStrength = sin(time + instanceMatrix[3].x + instanceMatrix[3].z);
                pos.x += windStrength * 0.1 * uv.y; // Sway more at the top
                gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(pos, 1.0);
                vUv = uv;
            }
        `;
        const grassFragmentShader = `
            uniform vec3 grassColor;
            varying vec2 vUv;
            void main() {
                gl_FragColor = vec4(grassColor, 1.0);
            }
        `;
        const grassMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                grassColor: { value: new THREE.Color(0x00aa00) } // Darker green for realism
            },
            vertexShader: grassVertexShader,
            fragmentShader: grassFragmentShader
        });

        // Chunk class for terrain and grass
        class Chunk {
            constructor(x, z) {
                this.x = x;
                this.z = z;
                this.mesh = this.createTerrainMesh();
                this.grass = this.createGrass();
                scene.add(this.mesh);
                scene.add(this.grass);
            }

            createTerrainMesh() {
                const geometry = new THREE.PlaneGeometry(chunkSize, chunkSize, chunkSegments, chunkSegments);
                geometry.rotateX(-Math.PI / 2);

                const positions = geometry.attributes.position.array;
                for (let i = 0; i < positions.length; i += 3) {
                    const lx = (i / 3) % (chunkSegments + 1);
                    const lz = Math.floor((i / 3) / (chunkSegments + 1));
                    const wx = this.x * chunkSize + lx * (chunkSize / chunkSegments);
                    const wz = this.z * chunkSize + lz * (chunkSize / chunkSegments);
                    // Layered noise for varied topology
                    const height = (noise.noise2D(wx * noiseScale, wz * noiseScale) +
                                   0.5 * noise.noise2D(wx * noiseScale * 2, wz * noiseScale * 2)) * heightScale;
                    positions[i + 1] = height;
                }
                geometry.computeVertexNormals();

                const material = new THREE.MeshStandardMaterial({ color: 0x8B4513 }); // Dirt color
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(this.x * chunkSize, 0, this.z * chunkSize);
                return mesh;
            }

            createGrass() {
                const instanceCount = 1000;
                const instancedMesh = new THREE.InstancedMesh(bladeGeometry, grassMaterial.clone(), instanceCount);
                const dummy = new THREE.Object3D();
                for (let i = 0; i < instanceCount; i++) {
                    const lx = Math.random() * chunkSize;
                    const lz = Math.random() * chunkSize;
                    const wx = this.x * chunkSize + lx;
                    const wz = this.z * chunkSize + lz;
                    const height = (noise.noise2D(wx * noiseScale, wz * noiseScale) +
                                   0.5 * noise.noise2D(wx * noiseScale * 2, wz * noiseScale * 2)) * heightScale;
                    dummy.position.set(lx, height, lz);
                    dummy.rotation.y = Math.random() * Math.PI * 2; // Random rotation for variety
                    dummy.updateMatrix();
                    instancedMesh.setMatrixAt(i, dummy.matrix);
                }
                instancedMesh.position.set(this.x * chunkSize, 0, this.z * chunkSize);
                return instancedMesh;
            }

            update(time) {
                this.grass.material.uniforms.time.value = time;
            }
        }

        // Simple lens flare (sprite-based)
        const flareTexture = new THREE.TextureLoader().load(
            'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAADGSURBVFhH7ZbRDcIwDEVTVG+gF+gN+gY+gDfoHXgC3uBOoBvoBfoGvoE34B34DlX+ox+QR/HZfS8e64bDWvfkMc0zP8uK45pnyuV8iufK5XyO58rnfI7nKp7zOZ7rOM/nB8C5gHMBRwPOBRwNOBtwNuBswNmAswFnA84GPAJ4DHgE8AjgEcAjgEcAjwAeATwCeARwCOARwCOARwCPAB4BPAJ4BHAY8AngEcBjwCeARwCPAB4BPAJ4BHAY8AngEcBjwCeARwCPAB7r+AP8fG6xXqM9uAAAAAElFTkSuQmCC'
        ); // Simple white circle as placeholder
        const flareMaterial = new THREE.SpriteMaterial({ map: flareTexture, color: 0xffffff, transparent: true, opacity: 0.8 });
        const lensFlare = new THREE.Sprite(flareMaterial);
        lensFlare.scale.set(5, 5, 1);
        lensFlare.position.copy(directionalLight.position);
        scene.add(lensFlare);

        // Flowing river (basic water plane)
        const waterGeometry = new THREE.PlaneGeometry(1000, 1000);
        waterGeometry.rotateX(-Math.PI / 2);
        const waterMaterial = new THREE.MeshPhongMaterial({
            color: 0x1E90FF,
            transparent: true,
            opacity: 0.6,
            shininess: 100
        });
        const water = new THREE.Mesh(waterGeometry, waterMaterial);
        water.position.y = 0; // Water level
        scene.add(water);

        // Touch event handlers
        function onTouchStart(event) {
            event.preventDefault();
            for (let touch of event.changedTouches) {
                const x = touch.clientX;
                if (x < window.innerWidth / 2 && rotationTouchId === null) {
                    rotationTouchId = touch.identifier;
                    previousTouchPosition[touch.identifier] = { x: x, y: touch.clientY };
                } else if (x >= window.innerWidth / 2 && movementTouchId === null) {
                    movementTouchId = touch.identifier;
                }
            }
        }

        function onTouchMove(event) {
            event.preventDefault();
            for (let touch of event.changedTouches) {
                if (touch.identifier === rotationTouchId) {
                    const prev = previousTouchPosition[touch.identifier];
                    const deltaX = touch.clientX - prev.x;
                    const deltaY = touch.clientY - prev.y;
                    camera.rotation.y -= deltaX * rotationSpeed;
                    camera.rotation.x -= deltaY * rotationSpeed;
                    camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
                    previousTouchPosition[touch.identifier] = { x: touch.clientX, y: touch.clientY };
                }
            }
        }

        function onTouchEnd(event) {
            event.preventDefault();
            for (let touch of event.changedTouches) {
                if (touch.identifier === rotationTouchId) {
                    rotationTouchId = null;
                    delete previousTouchPosition[touch.identifier];
                } else if (touch.identifier === movementTouchId) {
                    movementTouchId = null;
                }
            }
        }

        renderer.domElement.addEventListener('touchstart', onTouchStart, false);
        renderer.domElement.addEventListener('touchmove', onTouchMove, false);
        renderer.domElement.addEventListener('touchend', onTouchEnd, false);
        renderer.domElement.addEventListener('touchcancel', onTouchEnd, false);

        // Terrain management
        function updateTerrain() {
            const camChunkX = Math.floor(camera.position.x / chunkSize);
            const camChunkZ = Math.floor(camera.position.z / chunkSize);

            for (let dx = -viewDistance; dx <= viewDistance; dx++) {
                for (let dz = -viewDistance; dz <= viewDistance; dz++) {
                    const cx = camChunkX + dx;
                    const cz = camChunkZ + dz;
                    const key = `${cx},${cz}`;
                    if (!loadedChunks[key]) {
                        loadedChunks[key] = new Chunk(cx, cz);
                    }
                }
            }

            for (let key in loadedChunks) {
                const [cx, cz] = key.split(',').map(Number);
                if (Math.abs(cx - camChunkX) > viewDistance || Math.abs(cz - camChunkZ) > viewDistance) {
                    scene.remove(loadedChunks[key].mesh);
                    scene.remove(loadedChunks[key].grass);
                    delete loadedChunks[key];
                }
            }
        }

        // Animation loop
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            time += clock.getDelta();

            // Handle movement
            if (movementTouchId !== null) {
                const touch = Array.from(renderer.domElement.touches).find(t => t.identifier === movementTouchId);
                if (touch) {
                    const dx = (touch.clientX - centerX) / (window.innerWidth * 0.25);
                    const dy = (touch.clientY - centerY) / (window.innerHeight * 0.5);
                    const strafeSpeed = movementSpeed * Math.min(Math.max(dx, -1), 1);
                    const forwardSpeed = -movementSpeed * Math.min(Math.max(dy, -1), 1);
                    camera.translateX(strafeSpeed);
                    camera.translateZ(forwardSpeed);

                    // Adjust camera height to terrain
                    const terrainHeight = (noise.noise2D(camera.position.x * noiseScale, camera.position.z * noiseScale) +
                                          0.5 * noise.noise2D(camera.position.x * noiseScale * 2, camera.position.z * noiseScale * 2)) * heightScale;
                    camera.position.y = terrainHeight + 1.6;
                }
            }

            updateTerrain();
            for (let key in loadedChunks) {
                loadedChunks[key].update(time);
            }

            renderer.render(scene, camera);
        }
        animate();

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​