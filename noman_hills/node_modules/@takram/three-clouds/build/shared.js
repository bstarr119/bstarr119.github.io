import { Pass as He, ShaderPass as Z, Resolution as q, Effect as Fe, EffectAttribute as ze } from "postprocessing";
import { Vector3 as f, Vector2 as m, Matrix4 as v, Object3D as se, Box3 as We, Uniform as r, GLSL3 as W, Vector4 as x, RawShaderMaterial as X, Camera as xe, WebGLRenderTarget as Ge, HalfFloatType as we, LinearFilter as z, RedFormat as Be, WebGLArrayRenderTarget as Ve, EventDispatcher as ke, Texture as ce, Data3DTexture as le } from "three";
import { AtmosphereMaterialBase as je, AtmosphereParameters as Ce, getAltitudeCorrectionOffset as Ye } from "@takram/three-atmosphere";
import { lerp as Te, defineInt as O, defineExpression as De, define as C, defineFloat as J, unrollLoops as G, resolveIncludes as M, assertType as Ze, Geodetic as qe, definePropertyShorthand as he, defineUniformShorthand as ue } from "@takram/three-geospatial";
import { functions as de, parameters as pe } from "@takram/three-atmosphere/shaders";
import { vogelDisk as Ke, interleavedGradientNoise as $e, cascadedShadowMaps as Xe, raySphereIntersection as Ee, generators as Je, turbo as Ae, math as _e, depth as Qe } from "@takram/three-geospatial/shaders";
class B {
  constructor(e = 0, t = 0, n = 0, a = 0) {
    this.expTerm = e, this.exponent = t, this.linearTerm = n, this.constantTerm = a;
  }
  set(e = 0, t = 0, n = 0, a = 0) {
    return this.expTerm = e, this.exponent = t, this.linearTerm = n, this.constantTerm = a, this;
  }
  clone() {
    return new B(
      this.expTerm,
      this.exponent,
      this.linearTerm,
      this.constantTerm
    );
  }
  copy(e) {
    return this.expTerm = e.expTerm, this.exponent = e.exponent, this.linearTerm = e.linearTerm, this.constantTerm = e.constantTerm, this;
  }
}
const et = [
  "channel",
  "altitude",
  "height",
  "densityScale",
  "shapeAmount",
  "shapeDetailAmount",
  "weatherExponent",
  "shapeAlteringBias",
  "coverageFilterWidth",
  "shadow",
  "densityProfile"
];
function tt(o, e) {
  if (e != null)
    for (const t of et) {
      const n = e[t];
      n != null && (o[t] instanceof B ? o[t].copy(n) : o[t] = n);
    }
}
const N = class N {
  constructor(e) {
    this.channel = "r", this.altitude = 0, this.height = 0, this.densityScale = 0.2, this.shapeAmount = 1, this.shapeDetailAmount = 1, this.weatherExponent = 1, this.shapeAlteringBias = 0.35, this.coverageFilterWidth = 0.6, this.densityProfile = new B(0, 0, 0.75, 0.25), this.shadow = !1, this.set(e);
  }
  set(e) {
    return tt(this, e), this;
  }
  clone() {
    return new N(this);
  }
  copy(e) {
    return this.channel = e.channel, this.altitude = e.altitude, this.height = e.height, this.densityScale = e.densityScale, this.shapeAmount = e.shapeAmount, this.shapeDetailAmount = e.shapeDetailAmount, this.weatherExponent = e.weatherExponent, this.shapeAlteringBias = e.shapeAlteringBias, this.coverageFilterWidth = e.coverageFilterWidth, this.densityProfile.copy(e.densityProfile), this.shadow = e.shadow, this;
  }
};
N.DEFAULT = /* @__PURE__ */ new N();
let T = N;
const P = /* @__PURE__ */ Array.from(
  { length: 8 },
  () => ({ value: 0, flag: 0 })
), L = /* @__PURE__ */ Array.from(
  { length: 3 },
  () => ({ min: 0, max: 0 })
);
function nt(o, e) {
  return o.value !== e.value ? o.value - e.value : o.flag - e.flag;
}
const b = class b extends Array {
  constructor(e) {
    super(
      new T(e == null ? void 0 : e[0]),
      new T(e == null ? void 0 : e[1]),
      new T(e == null ? void 0 : e[2]),
      new T(e == null ? void 0 : e[3])
    );
  }
  set(e) {
    return this[0].set(e == null ? void 0 : e[0]), this[1].set(e == null ? void 0 : e[1]), this[2].set(e == null ? void 0 : e[2]), this[3].set(e == null ? void 0 : e[3]), this;
  }
  reset() {
    return this[0].copy(T.DEFAULT), this[1].copy(T.DEFAULT), this[2].copy(T.DEFAULT), this[3].copy(T.DEFAULT), this;
  }
  clone() {
    return new b(this);
  }
  copy(e) {
    return this[0].copy(e[0]), this[1].copy(e[1]), this[2].copy(e[2]), this[3].copy(e[3]), this;
  }
  get localWeatherChannels() {
    return this[0].channel + this[1].channel + this[2].channel + this[3].channel;
  }
  packValues(e, t) {
    return t.set(this[0][e], this[1][e], this[2][e], this[3][e]);
  }
  packSums(e, t, n) {
    return n.set(
      this[0][e] + this[0][t],
      this[1][e] + this[1][t],
      this[2][e] + this[2][t],
      this[3][e] + this[3][t]
    );
  }
  packDensityProfiles(e, t) {
    return t.set(
      this[0].densityProfile[e],
      this[1].densityProfile[e],
      this[2].densityProfile[e],
      this[3].densityProfile[e]
    );
  }
  // Redundant, but need to avoid creating garbage here as this runs every frame.
  packIntervalHeights(e, t) {
    for (let s = 0; s < 4; ++s) {
      const c = this[s];
      let h = P[s];
      h.value = c.altitude, h.flag = 0, h = P[s + 4], h.value = c.altitude + c.height, h.flag = 1;
    }
    P.sort(nt);
    let n = 0, a = 0;
    for (let s = 0; s < P.length; ++s) {
      const { value: c, flag: h } = P[s];
      if (a === 0 && s > 0) {
        const u = L[n++];
        u.min = P[s - 1].value, u.max = c;
      }
      a += h === 0 ? 1 : -1;
    }
    for (; n < 3; ++n) {
      const s = L[n];
      s.min = 0, s.max = 0;
    }
    let i = L[0];
    e.x = i.min, t.x = i.max, i = L[1], e.y = i.min, t.y = i.max, i = L[2], e.z = i.min, t.z = i.max;
  }
};
b.DEFAULT = /* @__PURE__ */ new b([
  {
    channel: "r",
    altitude: 750,
    height: 650,
    densityScale: 0.2,
    shapeAmount: 1,
    shapeDetailAmount: 1,
    weatherExponent: 1,
    shapeAlteringBias: 0.35,
    coverageFilterWidth: 0.6,
    shadow: !0
  },
  {
    channel: "g",
    altitude: 1e3,
    height: 1200,
    densityScale: 0.2,
    shapeAmount: 1,
    shapeDetailAmount: 1,
    weatherExponent: 1,
    shapeAlteringBias: 0.35,
    coverageFilterWidth: 0.6,
    shadow: !0
  },
  {
    channel: "b",
    altitude: 7500,
    height: 500,
    densityScale: 3e-3,
    shapeAmount: 0.4,
    shapeDetailAmount: 0,
    weatherExponent: 1,
    shapeAlteringBias: 0.35,
    coverageFilterWidth: 0.5
  },
  { channel: "a" }
]);
let K = b;
var at = process.env.NODE_ENV === "production", fe = "Invariant failed";
function A(o, e) {
  if (!o) {
    if (at)
      throw new Error(fe);
    var t = fe;
    throw new Error(t);
  }
}
class U {
  constructor(e, t) {
    this.near = [new f(), new f(), new f(), new f()], this.far = [new f(), new f(), new f(), new f()], e != null && t != null && this.setFromCamera(e, t);
  }
  clone() {
    return new U().copy(this);
  }
  copy(e) {
    for (let t = 0; t < 4; ++t)
      this.near[t].copy(e.near[t]), this.far[t].copy(e.far[t]);
    return this;
  }
  setFromCamera(e, t) {
    const n = e.isOrthographicCamera === !0, a = e.projectionMatrixInverse;
    this.near[0].set(1, 1, -1), this.near[1].set(1, -1, -1), this.near[2].set(-1, -1, -1), this.near[3].set(-1, 1, -1);
    for (let i = 0; i < 4; ++i)
      this.near[i].applyMatrix4(a);
    this.far[0].set(1, 1, 1), this.far[1].set(1, -1, 1), this.far[2].set(-1, -1, 1), this.far[3].set(-1, 1, 1);
    for (let i = 0; i < 4; ++i) {
      const s = this.far[i];
      s.applyMatrix4(a);
      const c = Math.abs(s.z);
      n ? s.z *= Math.min(t / c, 1) : s.multiplyScalar(Math.min(t / c, 1));
    }
    return this;
  }
  split(e, t = []) {
    for (let n = 0; n < e.length; ++n) {
      const a = t[n] ?? (t[n] = new U());
      if (n === 0)
        for (let i = 0; i < 4; ++i)
          a.near[i].copy(this.near[i]);
      else
        for (let i = 0; i < 4; ++i)
          a.near[i].lerpVectors(
            this.near[i],
            this.far[i],
            e[n - 1]
          );
      if (n === e.length - 1)
        for (let i = 0; i < 4; ++i)
          a.far[i].copy(this.far[i]);
      else
        for (let i = 0; i < 4; ++i)
          a.far[i].lerpVectors(
            this.near[i],
            this.far[i],
            e[n]
          );
    }
    return t.length = e.length, t;
  }
  applyMatrix4(e) {
    for (let t = 0; t < 4; ++t)
      this.near[t].applyMatrix4(e), this.far[t].applyMatrix4(e);
    return this;
  }
}
const it = {
  uniform: (o, e, t, n, a = []) => {
    for (let i = 0; i < o; ++i)
      a[i] = (e + (t - e) * (i + 1) / o) / t;
    return a.length = o, a;
  },
  logarithmic: (o, e, t, n, a = []) => {
    for (let i = 0; i < o; ++i)
      a[i] = e * (t / e) ** ((i + 1) / o) / t;
    return a.length = o, a;
  },
  practical: (o, e, t, n = 0.5, a = []) => {
    for (let i = 0; i < o; ++i) {
      const s = (e + (t - e) * (i + 1) / o) / t, c = e * (t / e) ** ((i + 1) / o) / t;
      a[i] = Te(s, c, n);
    }
    return a.length = o, a;
  }
};
function rt(o, e, t, n, a, i = []) {
  return it[o](e, t, n, a, i);
}
const me = /* @__PURE__ */ new f(), ve = /* @__PURE__ */ new f(), ot = /* @__PURE__ */ new v(), ge = /* @__PURE__ */ new v(), st = /* @__PURE__ */ new U(), ct = /* @__PURE__ */ new We(), lt = {
  maxFar: null,
  farScale: 1,
  splitMode: "practical",
  splitLambda: 0.5,
  margin: 0,
  fade: !0
};
class ht {
  constructor(e) {
    this.cascades = [], this.mapSize = new m(), this.cameraFrustum = new U(), this.frusta = [], this.splits = [], this._far = 0;
    const {
      cascadeCount: t,
      mapSize: n,
      maxFar: a,
      farScale: i,
      splitMode: s,
      splitLambda: c,
      margin: h,
      fade: u
    } = {
      ...lt,
      ...e
    };
    this.cascadeCount = t, this.mapSize.copy(n), this.maxFar = a, this.farScale = i, this.splitMode = s, this.splitLambda = c, this.margin = h, this.fade = u;
  }
  get cascadeCount() {
    return this.cascades.length;
  }
  set cascadeCount(e) {
    var t;
    if (e !== this.cascadeCount) {
      for (let n = 0; n < e; ++n)
        (t = this.cascades)[n] ?? (t[n] = {
          interval: new m(),
          matrix: new v(),
          inverseMatrix: new v(),
          projectionMatrix: new v(),
          inverseProjectionMatrix: new v(),
          viewMatrix: new v(),
          inverseViewMatrix: new v()
        });
      this.cascades.length = e;
    }
  }
  get far() {
    return this._far;
  }
  updateIntervals(e) {
    const t = this.cascadeCount, n = this.splits, a = this.far;
    rt(
      this.splitMode,
      t,
      e.near,
      a,
      this.splitLambda,
      n
    ), this.cameraFrustum.setFromCamera(e, a), this.cameraFrustum.split(n, this.frusta);
    const i = this.cascades;
    for (let s = 0; s < t; ++s)
      i[s].interval.set(n[s - 1] ?? 0, n[s] ?? 0);
  }
  getFrustumRadius(e, t) {
    const n = t.near, a = t.far;
    let i = Math.max(
      a[0].distanceTo(a[2]),
      a[0].distanceTo(n[2])
    );
    if (this.fade) {
      const s = e.near, c = this.far, h = a[0].z / (c - s);
      i += 0.25 * h ** 2 * (c - s);
    }
    return i * 0.5;
  }
  updateMatrices(e, t, n = 1) {
    const a = ot.lookAt(
      me.setScalar(0),
      ve.copy(t).multiplyScalar(-1),
      se.DEFAULT_UP
    ), i = ge.multiplyMatrices(
      ge.copy(a).invert(),
      e.matrixWorld
    ), s = this.frusta, c = this.cascades;
    A(s.length === c.length);
    const h = this.margin, u = this.mapSize;
    for (let d = 0; d < s.length; ++d) {
      const p = s[d], g = c[d], S = this.getFrustumRadius(e, s[d]), ee = -S, te = S, ne = S, ae = -S;
      g.projectionMatrix.makeOrthographic(
        ee,
        te,
        ne,
        ae,
        -this.margin,
        // near
        S * 2 + this.margin
        // far
      );
      const { near: Me, far: Ue } = st.copy(p).applyMatrix4(i), H = ct.makeEmpty();
      for (let F = 0; F < 4; F++)
        H.expandByPoint(Me[F]), H.expandByPoint(Ue[F]);
      const E = H.getCenter(me);
      E.z = H.max.z + h;
      const ie = (te - ee) / u.width, re = (ne - ae) / u.height;
      E.x = Math.round(E.x / ie) * ie, E.y = Math.round(E.y / re) * re, E.applyMatrix4(a);
      const oe = ve.copy(t).multiplyScalar(n).add(E);
      g.inverseViewMatrix.lookAt(E, oe, se.DEFAULT_UP).setPosition(oe);
    }
  }
  update(e, t, n) {
    this._far = this.maxFar != null ? Math.min(this.maxFar, e.far * this.farScale) : e.far * this.farScale, this.updateIntervals(e), this.updateMatrices(e, t, n);
    const a = this.cascades, i = this.cascadeCount;
    for (let s = 0; s < i; ++s) {
      const {
        matrix: c,
        inverseMatrix: h,
        projectionMatrix: u,
        inverseProjectionMatrix: d,
        viewMatrix: p,
        inverseViewMatrix: g
      } = a[s];
      d.copy(u).invert(), p.copy(g).invert(), c.copy(u).multiply(p), h.copy(g).multiply(d);
    }
  }
}
const Se = [
  0,
  8,
  2,
  10,
  12,
  4,
  14,
  6,
  3,
  11,
  1,
  9,
  15,
  7,
  13,
  5
], Pe = /* @__PURE__ */ Se.reduce(
  (o, e, t) => {
    const n = new m();
    for (let a = 0; a < 16; ++a)
      if (Se[a] === t) {
        n.set((a % 4 + 0.5) / 4, (Math.floor(a / 4) + 0.5) / 4);
        break;
      }
    return [...o, n];
  },
  []
), ut = {
  resolutionScale: 1,
  lightShafts: !0,
  shapeDetail: !0,
  turbulence: !0,
  haze: !0,
  clouds: {
    multiScatteringOctaves: 8,
    accurateSunSkyIrradiance: !0,
    accuratePhaseFunction: !1,
    // Primary raymarch
    maxIterationCount: 500,
    minStepSize: 50,
    maxStepSize: 1e3,
    maxRayDistance: 2e5,
    perspectiveStepScale: 1.01,
    minDensity: 1e-5,
    minExtinction: 1e-5,
    minTransmittance: 0.01,
    // Secondary raymarch
    maxIterationCountToGround: 3,
    maxIterationCountToSun: 2,
    minSecondaryStepSize: 100,
    secondaryStepScale: 2,
    // Shadow length
    maxShadowLengthIterationCount: 500,
    minShadowLengthStepSize: 50,
    maxShadowLengthRayDistance: 2e5
  },
  shadow: {
    cascadeCount: 3,
    mapSize: /* @__PURE__ */ new m(512, 512),
    // Primary raymarch
    maxIterationCount: 50,
    minStepSize: 100,
    maxStepSize: 1e3,
    minDensity: 1e-5,
    minExtinction: 1e-5,
    minTransmittance: 1e-4
  }
}, l = ut, dt = {
  // TODO: We cloud decrease multi-scattering octaves for lower quality presets,
  // but it leads to a loss of higher frequency scattering, making it darker
  // overall, which suggests the need for a fudge factor to scale the radiance.
  low: {
    ...l,
    lightShafts: !1,
    // Expensive
    shapeDetail: !1,
    // Expensive
    turbulence: !1,
    // Expensive
    clouds: {
      ...l.clouds,
      accurateSunSkyIrradiance: !1,
      // Greatly reduces texel reads.
      maxIterationCount: 200,
      minStepSize: 100,
      maxRayDistance: 1e5,
      minDensity: 1e-4,
      minExtinction: 1e-4,
      minTransmittance: 0.1,
      // Makes the primary march terminate earlier.
      maxIterationCountToGround: 0,
      // Expensive
      maxIterationCountToSun: 1
      // Only 1 march makes big difference
    },
    shadow: {
      ...l.shadow,
      maxIterationCount: 25,
      minDensity: 1e-4,
      minExtinction: 1e-4,
      minTransmittance: 0.01,
      // Makes the primary march terminate earlier.
      cascadeCount: 2,
      // Obvious
      mapSize: /* @__PURE__ */ new m(256, 256)
      // Obvious
    }
  },
  medium: {
    ...l,
    lightShafts: !1,
    // Expensive
    turbulence: !1,
    // Expensive
    clouds: {
      ...l.clouds,
      minDensity: 1e-4,
      minExtinction: 1e-4,
      accurateSunSkyIrradiance: !1,
      maxIterationCountToSun: 2,
      maxIterationCountToGround: 1
    },
    shadow: {
      ...l.shadow,
      minDensity: 1e-4,
      minExtinction: 1e-4,
      mapSize: /* @__PURE__ */ new m(256, 256)
    }
  },
  high: l,
  // Consider high quality preset as default.
  ultra: {
    ...l,
    clouds: {
      ...l.clouds,
      minStepSize: 10
    },
    shadow: {
      ...l.shadow,
      mapSize: /* @__PURE__ */ new m(1024, 1024)
    }
  }
}, pt = `precision highp float;
precision highp sampler3D;
precision highp sampler2DArray;

#include <common>
#include <packing>

#include "core/depth"
#include "core/math"
#include "core/turbo"
#include "core/generators"
#include "core/raySphereIntersection"
#include "core/cascadedShadowMaps"
#include "core/interleavedGradientNoise"
#include "core/vogelDisk"
#include "atmosphere/parameters"
#include "atmosphere/functions"
#include "types"
#include "parameters"
#include "clouds"

#if !defined(RECIPROCAL_PI4)
#define RECIPROCAL_PI4 (0.07957747154594767)
#endif // !defined(RECIPROCAL_PI4)

uniform sampler2D depthBuffer;
uniform mat4 viewMatrix;
uniform mat4 reprojectionMatrix;
uniform float cameraNear;
uniform float cameraFar;
uniform float cameraHeight;
uniform vec2 temporalJitter;
uniform vec2 targetUvScale;
uniform float mipLevelScale;

// Scattering
const vec2 scatterAnisotropy = vec2(SCATTER_ANISOTROPY_1, SCATTER_ANISOTROPY_2);
const float scatterAnisotropyMix = SCATTER_ANISOTROPY_MIX;
uniform float skyIrradianceScale;
uniform float groundIrradianceScale;
uniform float powderScale;
uniform float powderExponent;

// Primary raymarch
uniform int maxIterationCount;
uniform float minStepSize;
uniform float maxStepSize;
uniform float maxRayDistance;
uniform float perspectiveStepScale;

// Secondary raymarch
uniform int maxIterationCountToSun;
uniform int maxIterationCountToGround;
uniform float minSecondaryStepSize;
uniform float secondaryStepScale;

// Beer shadow map
uniform sampler2DArray shadowBuffer;
uniform vec2 shadowTexelSize;
uniform vec2 shadowIntervals[SHADOW_CASCADE_COUNT];
uniform mat4 shadowMatrices[SHADOW_CASCADE_COUNT];
uniform float shadowFar;
uniform float maxShadowFilterRadius;

// Shadow length
#ifdef SHADOW_LENGTH
uniform int maxShadowLengthIterationCount;
uniform float minShadowLengthStepSize;
uniform float maxShadowLengthRayDistance;
#endif // SHADOW_LENGTH

in vec2 vUv;
in vec3 vCameraPosition;
in vec3 vCameraDirection; // Direction to the center of screen
in vec3 vRayDirection; // Direction to the texel
in vec3 vEllipsoidCenter;
in GroundIrradiance vGroundIrradiance;
in CloudsIrradiance vCloudsIrradiance;

layout(location = 0) out vec4 outputColor;
layout(location = 1) out vec3 outputDepthVelocity;
#ifdef SHADOW_LENGTH
layout(location = 2) out float outputShadowLength;
#endif // SHADOW_LENGTH

float readDepth(const vec2 uv) {
  #if DEPTH_PACKING == 3201
  return unpackRGBAToDepth(texture(depthBuffer, uv));
  #else // DEPTH_PACKING == 3201
  return texture(depthBuffer, uv).r;
  #endif // DEPTH_PACKING == 3201
}

float getViewZ(const float depth) {
  #ifdef PERSPECTIVE_CAMERA
  return perspectiveDepthToViewZ(depth, cameraNear, cameraFar);
  #else // PERSPECTIVE_CAMERA
  return orthographicDepthToViewZ(depth, cameraNear, cameraFar);
  #endif // PERSPECTIVE_CAMERA
}

vec3 ECEFToWorld(const vec3 positionECEF) {
  return mat3(ellipsoidMatrix) * (positionECEF + vEllipsoidCenter);
}

vec2 getShadowUv(const vec3 worldPosition, const int cascadeIndex) {
  vec4 clip = shadowMatrices[cascadeIndex] * vec4(worldPosition, 1.0);
  clip /= clip.w;
  return clip.xy * 0.5 + 0.5;
}

float getDistanceToShadowTop(const vec3 rayPosition) {
  // Distance to the top of the shadows along the sun direction, which matches
  // the ray origin of BSM.
  return raySphereSecondIntersection(
    rayPosition,
    sunDirection,
    vec3(0.0),
    bottomRadius + shadowTopHeight
  );
}

#ifdef DEBUG_SHOW_CASCADES

const vec3 cascadeColors[4] = vec3[4](
  vec3(1.0, 0.0, 0.0),
  vec3(0.0, 1.0, 0.0),
  vec3(0.0, 0.0, 1.0),
  vec3(1.0, 1.0, 0.0)
);

vec3 getCascadeColor(const vec3 rayPosition) {
  vec3 worldPosition = ECEFToWorld(rayPosition);
  int cascadeIndex = getCascadeIndex(
    viewMatrix,
    worldPosition,
    shadowIntervals,
    cameraNear,
    shadowFar
  );
  vec2 uv = getShadowUv(worldPosition, cascadeIndex);
  if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
    return vec3(1.0);
  }
  return cascadeColors[cascadeIndex];
}

vec3 getFadedCascadeColor(const vec3 rayPosition, const float jitter) {
  vec3 worldPosition = ECEFToWorld(rayPosition);
  int cascadeIndex = getFadedCascadeIndex(
    viewMatrix,
    worldPosition,
    shadowIntervals,
    cameraNear,
    shadowFar,
    jitter
  );
  return cascadeIndex >= 0
    ? cascadeColors[cascadeIndex]
    : vec3(1.0);
}

#endif // DEBUG_SHOW_CASCADES

float readShadowOpticalDepth(
  const vec2 uv,
  const float distanceToTop,
  const float distanceOffset,
  const int cascadeIndex
) {
  // r: frontDepth, g: meanExtinction, b: maxOpticalDepth, a: maxOpticalDepthTail
  // Also see the discussion here: https://x.com/shotamatsuda/status/1885322308908442106
  vec4 shadow = texture(shadowBuffer, vec3(uv, float(cascadeIndex)));
  float distanceToFront = max(0.0, distanceToTop - distanceOffset - shadow.r);
  return min(shadow.b + shadow.a, shadow.g * distanceToFront);
}

float sampleShadowOpticalDepthPCF(
  const vec3 worldPosition,
  const float distanceToTop,
  const float distanceOffset,
  const float radius,
  const int cascadeIndex
) {
  vec2 uv = getShadowUv(worldPosition, cascadeIndex);
  if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
    return 0.0;
  }
  if (radius < 0.1) {
    return readShadowOpticalDepth(uv, distanceToTop, distanceOffset, cascadeIndex);
  }
  float sum = 0.0;
  vec2 offset;
  #pragma unroll_loop_start
  for (int i = 0; i < 16; ++i) {
    #if UNROLLED_LOOP_INDEX < SHADOW_SAMPLE_COUNT
    offset = vogelDisk(
      UNROLLED_LOOP_INDEX,
      SHADOW_SAMPLE_COUNT,
      interleavedGradientNoise(gl_FragCoord.xy + temporalJitter * resolution) * PI2
    );
    sum += readShadowOpticalDepth(
      uv + offset * radius * shadowTexelSize,
      distanceToTop,
      distanceOffset,
      cascadeIndex
    );
    #endif // UNROLLED_LOOP_INDEX < SHADOW_SAMPLE_COUNT
  }
  #pragma unroll_loop_end
  return sum / float(SHADOW_SAMPLE_COUNT);
}

float sampleShadowOpticalDepth(
  const vec3 rayPosition,
  const float distanceOffset,
  const float radius,
  const float jitter
) {
  float distanceToTop = getDistanceToShadowTop(rayPosition);
  if (distanceToTop <= 0.0) {
    return 0.0;
  }
  vec3 worldPosition = ECEFToWorld(rayPosition);
  int cascadeIndex = getFadedCascadeIndex(
    viewMatrix,
    worldPosition,
    shadowIntervals,
    cameraNear,
    shadowFar,
    jitter
  );
  return cascadeIndex >= 0
    ? sampleShadowOpticalDepthPCF(
      worldPosition,
      distanceToTop,
      distanceOffset,
      radius,
      cascadeIndex
    )
    : 0.0;
}

#ifdef DEBUG_SHOW_SHADOW_MAP
vec4 getCascadedShadowMaps(vec2 uv) {
  vec4 coord = vec4(vUv, vUv - 0.5) * 2.0;
  vec4 shadow = vec4(0.0);
  if (uv.y > 0.5) {
    if (uv.x < 0.5) {
      shadow = texture(shadowBuffer, vec3(coord.xw, 0.0));
    } else {
      #if SHADOW_CASCADE_COUNT > 1
      shadow = texture(shadowBuffer, vec3(coord.zw, 1.0));
      #endif // SHADOW_CASCADE_COUNT > 1
    }
  } else {
    if (uv.x < 0.5) {
      #if SHADOW_CASCADE_COUNT > 2
      shadow = texture(shadowBuffer, vec3(coord.xy, 2.0));
      #endif // SHADOW_CASCADE_COUNT > 2
    } else {
      #if SHADOW_CASCADE_COUNT > 3
      shadow = texture(shadowBuffer, vec3(coord.zy, 3.0));
      #endif // SHADOW_CASCADE_COUNT > 3
    }
  }

  #if !defined(DEBUG_SHOW_SHADOW_MAP_TYPE)
  #define DEBUG_SHOW_SHADOW_MAP_TYPE (0)
  #endif // !defined(DEBUG_SHOW_SHADOW_MAP_TYPE

  const float frontDepthScale = 1e-5;
  const float meanExtinctionScale = 10.0;
  const float maxOpticalDepthScale = 0.01;
  vec3 color;
  #if DEBUG_SHOW_SHADOW_MAP_TYPE == 1
  color = vec3(shadow.r * frontDepthScale);
  #elif DEBUG_SHOW_SHADOW_MAP_TYPE == 2
  color = vec3(shadow.g * meanExtinctionScale);
  #elif DEBUG_SHOW_SHADOW_MAP_TYPE == 3
  color = vec3((shadow.b + shadow.a) * maxOpticalDepthScale);
  #else // DEBUG_SHOW_SHADOW_MAP_TYPE
  color =
    (shadow.rgb + vec3(0.0, 0.0, shadow.a)) *
    vec3(frontDepthScale, meanExtinctionScale, maxOpticalDepthScale);
  #endif // DEBUG_SHOW_SHADOW_MAP_TYPE
  return vec4(color, 1.0);
}
#endif // DEBUG_SHOW_SHADOW_MAP

vec2 henyeyGreenstein(const vec2 g, const float cosTheta) {
  vec2 g2 = g * g;
  // prettier-ignore
  return RECIPROCAL_PI4 *
    ((1.0 - g2) / max(vec2(1e-7), pow(1.0 + g2 - 2.0 * g * cosTheta, vec2(1.5))));
}

#ifdef ACCURATE_PHASE_FUNCTION

float draine(float u, float g, float a) {
  float g2 = g * g;
  // prettier-ignore
  return (1.0 - g2) *
    (1.0 + a * u * u) /
    (4.0 * (1.0 + a * (1.0 + 2.0 * g2) / 3.0) * PI * pow(1.0 + g2 - 2.0 * g * u, 1.5));
}

// Numerically-fitted large particles (d=10) phase function It won't be
// plausible without a more precise multiple scattering.
// Reference: https://research.nvidia.com/labs/rtr/approximate-mie/
float phaseFunction(const float cosTheta, const float attenuation) {
  const float gHG = 0.988176691700256; // exp(-0.0990567/(d-1.67154))
  const float gD = 0.5556712547839497; // exp(-2.20679/(d+3.91029) - 0.428934)
  const float alpha = 21.995520856274638; // exp(3.62489 - 8.29288/(d+5.52825))
  const float weight = 0.4819554318404214; // exp(-0.599085/(d-0.641583)-0.665888)
  return mix(
    henyeyGreenstein(vec2(gHG) * attenuation, cosTheta).x,
    draine(cosTheta, gD * attenuation, alpha),
    weight
  );
}

#else // ACCURATE_PHASE_FUNCTION

float phaseFunction(const float cosTheta, const float attenuation) {
  const vec2 g = scatterAnisotropy;
  const vec2 weights = vec2(1.0 - scatterAnisotropyMix, scatterAnisotropyMix);
  // A similar approximation is described in the Frostbite's paper, where phase
  // angle is attenuated instead of anisotropy.
  return dot(henyeyGreenstein(g * attenuation, cosTheta), weights);
}

#endif // ACCURATE_PHASE_FUNCTION

float phaseFunction(const float cosTheta) {
  return phaseFunction(cosTheta, 1.0);
}

float marchOpticalDepth(
  const vec3 rayOrigin,
  const vec3 rayDirection,
  const int maxIterationCount,
  const float mipLevel,
  const float jitter,
  out float rayDistance
) {
  int iterationCount = int(
    max(0.0, remap(mipLevel, 0.0, 1.0, float(maxIterationCount + 1), 1.0) - jitter)
  );
  if (iterationCount == 0) {
    // Fudge factor to approximate the mean optical depth.
    // TODO: Remove it.
    return 0.5;
  }
  float stepSize = minSecondaryStepSize / float(iterationCount);
  float nextDistance = stepSize * jitter;
  float opticalDepth = 0.0;
  for (int i = 0; i < iterationCount; ++i) {
    rayDistance = nextDistance;
    vec3 position = rayDistance * rayDirection + rayOrigin;
    vec2 uv = getGlobeUv(position);
    float height = length(position) - bottomRadius;
    WeatherSample weather = sampleWeather(uv, height, mipLevel);
    MediaSample media = sampleMedia(weather, position, uv, mipLevel, jitter);
    opticalDepth += media.extinction * stepSize;
    nextDistance += stepSize;
    stepSize *= secondaryStepScale;
  }
  return opticalDepth;
}

float marchOpticalDepth(
  const vec3 rayOrigin,
  const vec3 rayDirection,
  const int maxIterationCount,
  const float mipLevel,
  const float jitter
) {
  float rayDistance;
  return marchOpticalDepth(
    rayOrigin,
    rayDirection,
    maxIterationCount,
    mipLevel,
    jitter,
    rayDistance
  );
}

float approximateMultipleScattering(const float opticalDepth, const float cosTheta) {
  // Multiple scattering approximation
  // See: https://fpsunflower.github.io/ckulla/data/oz_volumes.pdf
  // a: attenuation, b: contribution, c: phase attenuation
  vec3 coeffs = vec3(1.0); // [a, b, c]
  const vec3 attenuation = vec3(0.5, 0.5, 0.5); // Should satisfy a <= b
  float scattering = 0.0;
  float beerLambert;
  #pragma unroll_loop_start
  for (int i = 0; i < 12; ++i) {
    #if UNROLLED_LOOP_INDEX < MULTI_SCATTERING_OCTAVES
    beerLambert = exp(-opticalDepth * coeffs.y);
    scattering += coeffs.x * beerLambert * phaseFunction(cosTheta, coeffs.z);
    coeffs *= attenuation;
    #endif // UNROLLED_LOOP_INDEX < MULTI_SCATTERING_OCTAVES
  }
  #pragma unroll_loop_end
  return scattering;
}

// TODO: Construct spherical harmonics of degree 2 using 2 sample points
// positioned near the horizon occlusion points on the sun direction plane.
vec3 getGroundSunSkyIrradiance(
  const vec3 position,
  const vec3 surfaceNormal,
  const float height,
  out vec3 skyIrradiance
) {
  #ifdef ACCURATE_SUN_SKY_IRRADIANCE
  return GetSunAndSkyIrradiance(
    (position - surfaceNormal * height) * METER_TO_LENGTH_UNIT,
    sunDirection,
    skyIrradiance
  );
  #else // ACCURATE_SUN_SKY_IRRADIANCE
  skyIrradiance = vGroundIrradiance.sky;
  return vGroundIrradiance.sun;
  #endif // ACCURATE_SUN_SKY_IRRADIANCE
}

vec3 getCloudsSunSkyIrradiance(const vec3 position, const float height, out vec3 skyIrradiance) {
  #ifdef ACCURATE_SUN_SKY_IRRADIANCE
  return GetSunAndSkyIrradiance(position * METER_TO_LENGTH_UNIT, sunDirection, skyIrradiance);
  #else // ACCURATE_SUN_SKY_IRRADIANCE
  float alpha = remapClamped(height, minHeight, maxHeight);
  skyIrradiance = mix(vCloudsIrradiance.minSky, vCloudsIrradiance.maxSky, alpha);
  return mix(vCloudsIrradiance.minSun, vCloudsIrradiance.maxSun, alpha);
  #endif // ACCURATE_SUN_SKY_IRRADIANCE
}

#ifdef GROUND_IRRADIANCE
vec3 approximateIrradianceFromGround(
  const vec3 position,
  const vec3 surfaceNormal,
  const float height,
  const float mipLevel,
  const float jitter
) {
  float opticalDepthToGround = marchOpticalDepth(
    position,
    -surfaceNormal,
    maxIterationCountToGround,
    mipLevel,
    jitter
  );
  vec3 skyIrradiance;
  vec3 sunIrradiance = getGroundSunSkyIrradiance(position, surfaceNormal, height, skyIrradiance);
  const float groundAlbedo = 0.3;
  vec3 groundIrradiance = skyIrradiance + (1.0 - coverage) * sunIrradiance * RECIPROCAL_PI2;
  vec3 bouncedLight = groundAlbedo * RECIPROCAL_PI * groundIrradiance;
  vec3 bouncedIrradiance = bouncedLight * exp(-opticalDepthToGround);
  return albedo * bouncedIrradiance * RECIPROCAL_PI4 * groundIrradianceScale;
}
#endif // GROUND_IRRADIANCE

vec4 marchClouds(
  const vec3 rayOrigin,
  const vec3 rayDirection,
  const vec2 rayNearFar,
  const float cosTheta,
  const float jitter,
  const float rayStartTexelsPerPixel,
  out float frontDepth,
  out ivec3 sampleCount
) {
  vec3 radianceIntegral = vec3(0.0);
  float transmittanceIntegral = 1.0;
  float weightedDistanceSum = 0.0;
  float transmittanceSum = 0.0;

  float maxRayDistance = rayNearFar.y - rayNearFar.x;
  float stepSize = minStepSize + (perspectiveStepScale - 1.0) * rayNearFar.x;
  // I don't understand why spatial aliasing remains unless doubling the jitter.
  float rayDistance = stepSize * jitter * 2.0;

  for (int i = 0; i < maxIterationCount; ++i) {
    if (rayDistance > maxRayDistance) {
      break; // Termination
    }

    vec3 position = rayDistance * rayDirection + rayOrigin;
    float height = length(position) - bottomRadius;
    float mipLevel = log2(max(1.0, rayStartTexelsPerPixel + rayDistance * 1e-5));

    #if !defined(DEBUG_MARCH_INTERVALS)
    if (insideLayerIntervals(height)) {
      stepSize *= perspectiveStepScale;
      rayDistance += mix(stepSize, maxStepSize, min(1.0, mipLevel));
      continue;
    }
    #endif // !defined(DEBUG_MARCH_INTERVALS)

    // Sample rough weather.
    vec2 uv = getGlobeUv(position);
    WeatherSample weather = sampleWeather(uv, height, mipLevel);

    #ifdef DEBUG_SHOW_SAMPLE_COUNT
    ++sampleCount.x;
    #endif // DEBUG_SHOW_SAMPLE_COUNT

    if (!any(greaterThan(weather.density, vec4(minDensity)))) {
      // Step longer in empty space.
      // TODO: This produces banding artifacts.
      // Possible improvement: Binary search refinement
      stepSize *= perspectiveStepScale;
      rayDistance += mix(stepSize, maxStepSize, min(1.0, mipLevel));
      continue;
    }

    // Sample detailed participating media.
    MediaSample media = sampleMedia(weather, position, uv, mipLevel, jitter, sampleCount);

    if (media.extinction > minExtinction) {
      vec3 skyIrradiance;
      vec3 sunIrradiance = getCloudsSunSkyIrradiance(position, height, skyIrradiance);
      vec3 surfaceNormal = normalize(position);

      // March optical depth to the sun for finer details, which BSM lacks.
      float sunRayDistance = 0.0;
      float opticalDepth = marchOpticalDepth(
        position,
        sunDirection,
        maxIterationCountToSun,
        mipLevel,
        jitter,
        sunRayDistance
      );

      if (height < shadowTopHeight) {
        // Obtain the optical depth from BSM at the ray position.
        opticalDepth += sampleShadowOpticalDepth(
          position,
          // Take account of only positions further than the marched ray
          // distance.
          sunRayDistance,
          // Apply PCF only when the sun is close to the horizon.
          maxShadowFilterRadius * remapClamped(dot(sunDirection, surfaceNormal), 0.1, 0.0),
          jitter
        );
      }

      float scattering = approximateMultipleScattering(opticalDepth, cosTheta);
      vec3 radiance = albedo * sunIrradiance * scattering;

      #ifdef GROUND_IRRADIANCE
      // Fudge factor for the irradiance from ground.
      if (height < shadowTopHeight && mipLevel < 0.5) {
        radiance += approximateIrradianceFromGround(
          position,
          surfaceNormal,
          height,
          mipLevel,
          jitter
        );
      }
      #endif // GROUND_IRRADIANCE

      // Crude approximation of sky gradient. Better than none in the shadows.
      float skyGradient = dot(0.5 + weather.heightFraction, media.weight);
      radiance += albedo * skyIrradiance * RECIPROCAL_PI4 * skyGradient * skyIrradianceScale;

      // Finally multiply by extinction (redundant but kept for clarity).
      radiance *= media.extinction;

      #ifdef POWDER
      radiance *= 1.0 - powderScale * exp(-media.extinction * powderExponent);
      #endif // POWDER

      #ifdef DEBUG_SHOW_CASCADES
      if (height < shadowTopHeight) {
        radiance = 1e-3 * getFadedCascadeColor(position, jitter);
      }
      #endif // DEBUG_SHOW_CASCADES

      // Energy-conserving analytical integration of scattered light
      // See 5.6.3 in https://media.contentapi.ea.com/content/dam/eacom/frostbite/files/s2016-pbs-frostbite-sky-clouds-new.pdf
      float transmittance = exp(-media.extinction * stepSize);
      float clampedExtinction = max(media.extinction, 1e-7);
      vec3 scatteringIntegral = (radiance - radiance * transmittance) / clampedExtinction;
      radianceIntegral += transmittanceIntegral * scatteringIntegral;
      transmittanceIntegral *= transmittance;

      // Aerial perspective affecting clouds
      // See 5.9.1 in https://media.contentapi.ea.com/content/dam/eacom/frostbite/files/s2016-pbs-frostbite-sky-clouds-new.pdf
      weightedDistanceSum += rayDistance * transmittanceIntegral;
      transmittanceSum += transmittanceIntegral;
    }

    if (transmittanceIntegral <= minTransmittance) {
      break; // Early termination
    }

    // Take a shorter step because we've already hit the clouds.
    stepSize *= perspectiveStepScale;
    rayDistance += stepSize;
  }

  // The final product of 5.9.1 and we'll evaluate this in aerial perspective.
  frontDepth = transmittanceSum > 0.0 ? weightedDistanceSum / transmittanceSum : -1.0;

  return vec4(radianceIntegral, remapClamped(transmittanceIntegral, 1.0, minTransmittance));
}

#ifdef SHADOW_LENGTH

float marchShadowLength(
  const vec3 rayOrigin,
  const vec3 rayDirection,
  const vec2 rayNearFar,
  const float jitter
) {
  float shadowLength = 0.0;
  float maxRayDistance = rayNearFar.y - rayNearFar.x;
  float stepSize = minShadowLengthStepSize;
  float rayDistance = stepSize * jitter;
  const float attenuationFactor = 1.0 - 1e-3;
  float attenuation = 1.0;

  // TODO: This march is closed, and sample resolution can be much lower.
  // Refining the termination by binary search will make it much more efficient.
  for (int i = 0; i < maxShadowLengthIterationCount; ++i) {
    if (rayDistance > maxRayDistance) {
      break; // Termination
    }
    vec3 position = rayDistance * rayDirection + rayOrigin;
    float opticalDepth = sampleShadowOpticalDepth(position, 0.0, 0.0, jitter);
    shadowLength += (1.0 - exp(-opticalDepth)) * stepSize * attenuation;

    // Hack to prevent over-integration of shadow length. The shadow should be
    // attenuated by the inscatter as the ray travels further.
    attenuation *= attenuationFactor;
    if (attenuation < 1e-5) {
      break;
    }

    stepSize *= perspectiveStepScale;
    rayDistance += stepSize;
  }
  return shadowLength;
}

#endif // SHADOW_LENGTH

#ifdef HAZE

vec4 approximateHaze(
  const vec3 rayOrigin,
  const vec3 rayDirection,
  const float maxRayDistance,
  const float cosTheta,
  const float shadowLength
) {
  float modulation = remapClamped(coverage, 0.2, 0.4);
  if (cameraHeight * modulation < 0.0) {
    return vec4(0.0);
  }
  float density = modulation * hazeDensityScale * exp(-cameraHeight * hazeExponent);
  if (density < 1e-7) {
    return vec4(0.0); // Prevent artifact in views from space
  }

  // Analytical optical depth where density exponentially decreases with height.
  // Based on: https://iquilezles.org/articles/fog/
  float angle = max(dot(normalize(rayOrigin), rayDirection), 1e-5);
  float exponent = angle * hazeExponent;
  // Derive the optical depths separately for with and without shadow length.
  float expTerm = 1.0 - exp(-maxRayDistance * exponent);
  float shadowExpTerm = 1.0 - exp(-min(maxRayDistance, shadowLength) * exponent);
  float linearTerm = density / hazeExponent / angle;
  float opticalDepth = expTerm * linearTerm;
  float effectiveOpticalDepth = max((expTerm - shadowExpTerm) * linearTerm, 0.0);

  vec3 skyIrradiance = vGroundIrradiance.sky;
  vec3 sunIrradiance = vGroundIrradiance.sun;
  vec3 irradiance = sunIrradiance * phaseFunction(cosTheta);
  irradiance += skyIrradiance * RECIPROCAL_PI4 * skyIrradianceScale;
  vec3 inscatter = albedo * irradiance * saturate(1.0 - exp(-effectiveOpticalDepth));

  // Inscatter is attenuated by shadow length, but transmittance is not.
  return vec4(inscatter, saturate(1.0 - exp(-opticalDepth)));
}

#endif // HAZE

void applyAerialPerspective(
  const vec3 cameraPosition,
  const vec3 frontPosition,
  const float shadowLength,
  inout vec4 color
) {
  vec3 transmittance;
  vec3 inscatter = GetSkyRadianceToPoint(
    cameraPosition * METER_TO_LENGTH_UNIT,
    frontPosition * METER_TO_LENGTH_UNIT,
    shadowLength * METER_TO_LENGTH_UNIT,
    sunDirection,
    transmittance
  );
  float clampedAlpha = max(color.a, 1e-7);
  color.rgb = mix(vec3(0.0), color.rgb * transmittance / clampedAlpha + inscatter, color.a);
}

bool rayIntersectsGround(const vec3 cameraPosition, const vec3 rayDirection) {
  float r = length(cameraPosition);
  float mu = dot(cameraPosition, rayDirection) / r;
  return mu < 0.0 && r * r * (mu * mu - 1.0) + bottomRadius * bottomRadius >= 0.0;
}

struct IntersectionResult {
  bool ground;
  vec4 first;
  vec4 second;
};

IntersectionResult getIntersections(const vec3 cameraPosition, const vec3 rayDirection) {
  IntersectionResult intersections;
  intersections.ground = rayIntersectsGround(cameraPosition, rayDirection);
  raySphereIntersections(
    cameraPosition,
    rayDirection,
    bottomRadius + vec4(0.0, minHeight, maxHeight, shadowTopHeight),
    intersections.first,
    intersections.second
  );
  return intersections;
}

vec2 getRayNearFar(const IntersectionResult intersections) {
  vec2 nearFar;
  if (cameraHeight < minHeight) {
    // View below the clouds
    if (intersections.ground) {
      nearFar = vec2(-1.0); // No clouds to the ground
    } else {
      nearFar = vec2(intersections.second.y, intersections.second.z);
      nearFar.y = min(nearFar.y, maxRayDistance);
    }
  } else if (cameraHeight < maxHeight) {
    // View inside the total cloud layer
    if (intersections.ground) {
      nearFar = vec2(cameraNear, intersections.first.y);
    } else {
      nearFar = vec2(cameraNear, intersections.second.z);
    }
  } else {
    // View above the clouds
    nearFar = vec2(intersections.first.z, intersections.second.z);
    if (intersections.ground) {
      // Clamp the ray at the min height.
      nearFar.y = intersections.first.y;
    }
  }
  return nearFar;
}

#ifdef SHADOW_LENGTH
vec2 getShadowRayNearFar(const IntersectionResult intersections) {
  vec2 nearFar;
  if (cameraHeight < shadowTopHeight) {
    if (intersections.ground) {
      nearFar = vec2(cameraNear, intersections.first.x);
    } else {
      nearFar = vec2(cameraNear, intersections.second.w);
    }
  } else {
    nearFar = vec2(intersections.first.w, intersections.second.w);
    if (intersections.ground) {
      // Clamp the ray at the ground.
      nearFar.y = intersections.first.x;
    }
  }
  nearFar.y = min(nearFar.y, maxShadowLengthRayDistance);
  return nearFar;
}
#endif // SHADOW_LENGTH

#ifdef HAZE
vec2 getHazeRayNearFar(const IntersectionResult intersections) {
  vec2 nearFar;
  if (cameraHeight < maxHeight) {
    if (intersections.ground) {
      nearFar = vec2(cameraNear, intersections.first.x);
    } else {
      nearFar = vec2(cameraNear, intersections.second.z);
    }
  } else {
    nearFar = vec2(cameraNear, intersections.second.z);
    if (intersections.ground) {
      // Clamp the ray at the ground.
      nearFar.y = intersections.first.x;
    }
  }
  return nearFar;
}
#endif // HAZE

float getRayDistanceToScene(const vec3 rayDirection) {
  float depth = readDepth(vUv * targetUvScale + temporalJitter);
  if (depth < 1.0 - 1e-7) {
    depth = reverseLogDepth(depth, cameraNear, cameraFar);
    float viewZ = getViewZ(depth);
    return -viewZ / dot(rayDirection, vCameraDirection);
  }
  return -1.0;
}

void main() {
  #ifdef DEBUG_SHOW_SHADOW_MAP
  outputColor = getCascadedShadowMaps(vUv);
  outputDepthVelocity = vec3(0.0);
  #ifdef SHADOW_LENGTH
  outputShadowLength = 0.0;
  #endif // SHADOW_LENGTH
  return;
  #endif // DEBUG_SHOW_SHADOW_MAP

  vec3 cameraPosition = vCameraPosition - vEllipsoidCenter;
  vec3 rayDirection = normalize(vRayDirection);
  float cosTheta = dot(sunDirection, rayDirection);

  IntersectionResult intersections = getIntersections(cameraPosition, rayDirection);
  vec2 rayNearFar = getRayNearFar(intersections);
  #ifdef SHADOW_LENGTH
  vec2 shadowRayNearFar = getShadowRayNearFar(intersections);
  #endif // SHADOW_LENGTH
  #ifdef HAZE
  vec2 hazeRayNearFar = getHazeRayNearFar(intersections);
  #endif // HAZE

  float rayDistanceToScene = getRayDistanceToScene(rayDirection);
  if (rayDistanceToScene >= 0.0) {
    rayNearFar.y = min(rayNearFar.y, rayDistanceToScene);
    #ifdef SHADOW_LENGTH
    shadowRayNearFar.y = min(shadowRayNearFar.y, rayDistanceToScene);
    #endif // SHADOW_LENGTH
    #ifdef HAZE
    hazeRayNearFar.y = min(hazeRayNearFar.y, rayDistanceToScene);
    #endif // HAZE
  }

  bool intersectsGround = any(lessThan(rayNearFar, vec2(0.0)));
  bool intersectsScene = rayNearFar.y < rayNearFar.x;

  float stbn = getSTBN();

  vec4 color = vec4(0.0);
  float frontDepth = rayNearFar.y;
  vec3 depthVelocity = vec3(0.0);
  float shadowLength = 0.0;

  if (!intersectsGround && !intersectsScene) {
    vec3 rayOrigin = rayNearFar.x * rayDirection + cameraPosition;

    vec2 globeUv = getGlobeUv(rayOrigin);
    #ifdef DEBUG_SHOW_UV
    outputColor = vec4(vec3(checker(globeUv, localWeatherRepeat + localWeatherOffset)), 1.0);
    outputDepthVelocity = vec3(0.0);
    #ifdef SHADOW_LENGTH
    outputShadowLength = 0.0;
    #endif // SHADOW_LENGTH
    return;
    #endif // DEBUG_SHOW_UV

    float mipLevel = getMipLevel(globeUv * localWeatherRepeat) * mipLevelScale;
    mipLevel = mix(0.0, mipLevel, min(1.0, 0.2 * cameraHeight / maxHeight));

    float marchedFrontDepth;
    ivec3 sampleCount = ivec3(0);
    color = marchClouds(
      rayOrigin,
      rayDirection,
      rayNearFar,
      cosTheta,
      stbn,
      pow(2.0, mipLevel),
      marchedFrontDepth,
      sampleCount
    );

    #ifdef DEBUG_SHOW_SAMPLE_COUNT
    outputColor = vec4(vec3(sampleCount) / vec3(500.0, 5.0, 5.0), 1.0);
    outputDepthVelocity = vec3(0.0);
    #ifdef SHADOW_LENGTH
    outputShadowLength = 0.0;
    #endif // SHADOW_LENGTH
    return;
    #endif // DEBUG_SHOW_SAMPLE_COUNT

    // Front depth will be -1.0 when no samples are accumulated.
    if (marchedFrontDepth >= 0.0) {
      frontDepth = rayNearFar.x + marchedFrontDepth;

      #ifdef SHADOW_LENGTH
      // Clamp the shadow length ray at the clouds.
      shadowRayNearFar.y = mix(
        shadowRayNearFar.y,
        min(frontDepth, shadowRayNearFar.y),
        color.a // Interpolate by the alpha for smoother edges.
      );
      #endif // SHADOW_LENGTH

      #ifdef HAZE
      // Clamp the haze ray at the clouds.
      hazeRayNearFar.y = mix(
        hazeRayNearFar.y,
        min(frontDepth, hazeRayNearFar.y),
        color.a // Interpolate by the alpha for smoother edges.
      );
      #endif // HAZE
    }

    #ifdef SHADOW_LENGTH
    if (all(greaterThanEqual(shadowRayNearFar, vec2(0.0)))) {
      shadowLength = marchShadowLength(
        shadowRayNearFar.x * rayDirection + cameraPosition,
        rayDirection,
        shadowRayNearFar,
        stbn
      );
    }
    #endif // SHADOW_LENGTH

    // Apply aerial perspective.
    vec3 frontPosition = cameraPosition + frontDepth * rayDirection;
    applyAerialPerspective(cameraPosition, frontPosition, shadowLength, color);

    // Velocity for temporal resolution.
    vec3 frontPositionWorld = ECEFToWorld(frontPosition);
    vec4 prevClip = reprojectionMatrix * vec4(frontPositionWorld, 1.0);
    prevClip /= prevClip.w;
    vec2 prevUv = prevClip.xy * 0.5 + 0.5;
    vec2 velocity = (vUv - prevUv) * resolution;
    depthVelocity = vec3(frontDepth, velocity);

  } else {
    #ifdef SHADOW_LENGTH
    if (all(greaterThanEqual(shadowRayNearFar, vec2(0.0)))) {
      shadowLength = marchShadowLength(
        shadowRayNearFar.x * rayDirection + cameraPosition,
        rayDirection,
        shadowRayNearFar,
        stbn
      );
    }
    #endif // SHADOW_LENGTH

    // TODO: We can calculate velocity to reduce occlusion errors at the edges,
    // but suffers from floating-point precision errors on near objects.

    // if (intersectsScene) {
    //   vec3 frontPosition = cameraPosition + rayNearFar.y * rayDirection;
    //   vec3 frontPositionWorld = ECEFToWorld(frontPosition);
    //   vec4 prevClip = reprojectionMatrix * vec4(frontPositionWorld, 1.0);
    //   prevClip /= prevClip.w;
    //   vec2 prevUv = prevClip.xy * 0.5 + 0.5;
    //   vec2 velocity = (vUv - prevUv) * resolution;
    //   depthVelocity = vec3(rayNearFar.y, velocity);
    // }

  }

  #ifdef DEBUG_SHOW_FRONT_DEPTH
  outputColor = vec4(turbo(frontDepth / maxRayDistance), 1.0);
  outputDepthVelocity = vec3(0.0);
  #ifdef SHADOW_LENGTH
  outputShadowLength = 0.0;
  #endif // SHADOW_LENGTH
  return;
  #endif // DEBUG_SHOW_FRONT_DEPTH

  #ifdef HAZE
  vec4 haze = approximateHaze(
    cameraNear * rayDirection + cameraPosition,
    rayDirection,
    hazeRayNearFar.y - hazeRayNearFar.x,
    cosTheta,
    shadowLength
  );
  color = color * (1.0 - haze.a) + haze;
  #endif // HAZE

  outputColor = color;
  outputDepthVelocity = depthVelocity;
  #ifdef SHADOW_LENGTH
  outputShadowLength = shadowLength * METER_TO_LENGTH_UNIT;
  #endif // SHADOW_LENGTH
}
`, Oe = `float getSTBN() {
  ivec3 size = textureSize(stbnTexture, 0);
  vec3 scale = 1.0 / vec3(size);
  return texture(stbnTexture, vec3(gl_FragCoord.xy, float(frame % size.z)) * scale).r;
}

// Straightforward spherical mapping
vec2 getSphericalUv(const vec3 position) {
  vec2 st = normalize(position.yx);
  float phi = atan(st.x, st.y);
  float theta = asin(normalize(position).z);
  return vec2(phi * RECIPROCAL_PI2 + 0.5, theta * RECIPROCAL_PI + 0.5);
}

vec2 getCubeSphereUv(const vec3 position) {
  // Cube-sphere relaxation by: http://mathproofs.blogspot.com/2005/07/mapping-cube-to-sphere.html
  // TODO: Tile and fix seams.
  // Possible improvements:
  // https://iquilezles.org/articles/texturerepetition/
  // https://gamedev.stackexchange.com/questions/184388/fragment-shader-map-dot-texture-repeatedly-over-the-sphere
  // https://github.com/mmikk/hextile-demo

  vec3 n = normalize(position);
  vec3 f = abs(n);
  vec3 c = n / max(f.x, max(f.y, f.z));
  vec2 m;
  if (all(greaterThan(f.yy, f.xz))) {
    m = c.y > 0.0 ? vec2(-n.x, n.z) : n.xz;
  } else if (all(greaterThan(f.xx, f.yz))) {
    m = c.x > 0.0 ? n.yz : vec2(-n.y, n.z);
  } else {
    m = c.z > 0.0 ? n.xy : vec2(n.x, -n.y);
  }

  vec2 m2 = m * m;
  float q = dot(m2.xy, vec2(-2.0, 2.0)) - 3.0;
  float q2 = q * q;
  vec2 uv;
  uv.x = sqrt(1.5 + m2.x - m2.y - 0.5 * sqrt(-24.0 * m2.x + q2)) * (m.x > 0.0 ? 1.0 : -1.0);
  uv.y = sqrt(6.0 / (3.0 - uv.x * uv.x)) * m.y;
  return uv * 0.5 + 0.5;
}

vec2 getGlobeUv(const vec3 position) {
  return getCubeSphereUv(position);
}

float getMipLevel(const vec2 uv) {
  const float mipLevelScale = 0.1;
  vec2 coord = uv * resolution;
  vec2 ddx = dFdx(coord);
  vec2 ddy = dFdy(coord);
  float deltaMaxSqr = max(dot(ddx, ddx), dot(ddy, ddy)) * mipLevelScale;
  return max(0.0, 0.5 * log2(max(1.0, deltaMaxSqr)));
}

bool insideLayerIntervals(const float height) {
  bvec3 gt = greaterThan(vec3(height), minIntervalHeights);
  bvec3 lt = lessThan(vec3(height), maxIntervalHeights);
  return any(bvec3(gt.x && lt.x, gt.y && lt.y, gt.z && lt.z));
}

struct WeatherSample {
  vec4 heightFraction; // Normalized height of each layer
  vec4 density;
};

vec4 shapeAlteringFunction(const vec4 heightFraction, const vec4 bias) {
  // Apply a semi-circle transform to round the clouds towards the top.
  vec4 biased = pow(heightFraction, bias);
  vec4 x = clamp(biased * 2.0 - 1.0, -1.0, 1.0);
  return 1.0 - x * x;
}

WeatherSample sampleWeather(const vec2 uv, const float height, const float mipLevel) {
  WeatherSample weather;
  weather.heightFraction = remapClamped(vec4(height), minLayerHeights, maxLayerHeights);

  vec4 localWeather = pow(
    textureLod(
      localWeatherTexture,
      uv * localWeatherRepeat + localWeatherOffset,
      mipLevel
    ).LOCAL_WEATHER_CHANNELS,
    weatherExponents
  );
  #ifdef SHADOW
  localWeather *= shadowLayerMask;
  #endif // SHADOW

  vec4 heightScale = shapeAlteringFunction(weather.heightFraction, shapeAlteringBiases);

  // Modulation to control weather by coverage parameter.
  // Reference: https://github.com/Prograda/Skybolt/blob/master/Assets/Core/Shaders/Clouds.h#L63
  vec4 factor = 1.0 - coverage * heightScale;
  weather.density = remapClamped(
    mix(localWeather, vec4(1.0), coverageFilterWidths),
    factor,
    factor + coverageFilterWidths
  );

  return weather;
}

vec4 getLayerDensity(const vec4 heightFraction) {
  // prettier-ignore
  return densityProfile.expTerms * exp(densityProfile.exponents * heightFraction) +
    densityProfile.linearTerms * heightFraction +
    densityProfile.constantTerms;
}

struct MediaSample {
  float density;
  vec4 weight;
  float scattering;
  float extinction;
};

MediaSample sampleMedia(
  const WeatherSample weather,
  const vec3 position,
  const vec2 uv,
  const float mipLevel,
  const float jitter,
  out ivec3 sampleCount
) {
  vec4 density = weather.density;

  // TODO: Define in physical length.
  vec3 surfaceNormal = normalize(position);
  float localWeatherSpeed = length(localWeatherOffset);
  vec3 evolution = -surfaceNormal * localWeatherSpeed * 2e4;

  vec3 turbulence = vec3(0.0);
  #ifdef TURBULENCE
  vec2 turbulenceUv = uv * localWeatherRepeat * turbulenceRepeat;
  turbulence =
    turbulenceDisplacement *
    (texture(turbulenceTexture, turbulenceUv).rgb * 2.0 - 1.0) *
    dot(density, remapClamped(weather.heightFraction, vec4(0.3), vec4(0.0)));
  #endif // TURBULENCE

  vec3 shapePosition = (position + evolution + turbulence) * shapeRepeat + shapeOffset;
  float shape = texture(shapeTexture, shapePosition).r;
  density = remapClamped(density, vec4(1.0 - shape) * shapeAmounts, vec4(1.0));

  #ifdef DEBUG_SHOW_SAMPLE_COUNT
  ++sampleCount.y;
  #endif // DEBUG_SHOW_SAMPLE_COUNT

  #ifdef SHAPE_DETAIL
  if (mipLevel * 0.5 + (jitter - 0.5) * 0.5 < 0.5) {
    vec3 detailPosition = (position + turbulence) * shapeDetailRepeat + shapeDetailOffset;
    float detail = texture(shapeDetailTexture, detailPosition).r;
    // Fluffy at the top and whippy at the bottom.
    vec4 modifier = mix(
      vec4(pow(detail, 6.0)),
      vec4(1.0 - detail),
      remapClamped(weather.heightFraction, vec4(0.2), vec4(0.4))
    );
    modifier = mix(vec4(0.0), modifier, shapeDetailAmounts);
    density = remapClamped(density * 2.0, vec4(modifier * 0.5), vec4(1.0));

    #ifdef DEBUG_SHOW_SAMPLE_COUNT
    ++sampleCount.z;
    #endif // DEBUG_SHOW_SAMPLE_COUNT
  }
  #endif // SHAPE_DETAIL

  // Nicely decrease the density at the bottom.
  density = saturate(density * densityScales * getLayerDensity(weather.heightFraction));

  MediaSample media;
  float densitySum = density.x + density.y + density.z + density.w;
  media.weight = density / densitySum;
  media.scattering = densitySum * scatteringCoefficient;
  media.extinction = densitySum * absorptionCoefficient + media.scattering;
  return media;
}

MediaSample sampleMedia(
  const WeatherSample weather,
  const vec3 position,
  const vec2 uv,
  const float mipLevel,
  const float jitter
) {
  ivec3 sampleCount;
  return sampleMedia(weather, position, uv, mipLevel, jitter, sampleCount);
}
`, ft = `precision highp float;
precision highp sampler3D;

#include "atmosphere/parameters"
#include "atmosphere/functions"
#include "types"

uniform mat4 inverseProjectionMatrix;
uniform mat4 inverseViewMatrix;
uniform vec3 cameraPosition;
uniform vec3 ellipsoidCenter;
uniform mat4 inverseEllipsoidMatrix;
uniform vec3 altitudeCorrection;

// Atmosphere
uniform float bottomRadius;
uniform vec3 sunDirection;

// Cloud layers
uniform float minHeight;
uniform float maxHeight;

layout(location = 0) in vec3 position;

out vec2 vUv;
out vec3 vCameraPosition;
out vec3 vCameraDirection; // Direction to the center of screen
out vec3 vRayDirection; // Direction to the texel
out vec3 vEllipsoidCenter;

out GroundIrradiance vGroundIrradiance;
out CloudsIrradiance vCloudsIrradiance;

void sampleSunSkyIrradiance(const vec3 positionECEF) {
  vGroundIrradiance.sun = GetSunAndSkyIrradiance(
    positionECEF * METER_TO_LENGTH_UNIT,
    sunDirection,
    vGroundIrradiance.sky
  );

  vec3 surfaceNormal = normalize(positionECEF);
  vec2 radii = (bottomRadius + vec2(minHeight, maxHeight)) * METER_TO_LENGTH_UNIT;
  vCloudsIrradiance.minSun = GetSunAndSkyIrradiance(
    surfaceNormal * radii.x,
    sunDirection,
    vCloudsIrradiance.minSky
  );
  vCloudsIrradiance.maxSun = GetSunAndSkyIrradiance(
    surfaceNormal * radii.y,
    sunDirection,
    vCloudsIrradiance.maxSky
  );
}

void main() {
  vUv = position.xy * 0.5 + 0.5;

  vec4 viewPosition = inverseProjectionMatrix * vec4(position, 1.0);
  vec4 worldDirection = inverseViewMatrix * vec4(viewPosition.xyz, 0.0);
  mat3 rotation = mat3(inverseEllipsoidMatrix);
  vCameraPosition = rotation * cameraPosition;
  vCameraDirection = rotation * normalize((inverseViewMatrix * vec4(0.0, 0.0, -1.0, 0.0)).xyz);
  vRayDirection = rotation * worldDirection.xyz;
  vEllipsoidCenter = ellipsoidCenter + altitudeCorrection;

  sampleSunSkyIrradiance(vCameraPosition - vEllipsoidCenter);

  gl_Position = vec4(position.xy, 1.0, 1.0);
}
`, Re = `uniform vec2 resolution;
uniform int frame;
uniform sampler3D stbnTexture;

// Atmosphere
uniform float bottomRadius;
uniform mat4 ellipsoidMatrix;
uniform mat4 inverseEllipsoidMatrix;
uniform vec3 sunDirection;

// Participating medium
uniform float scatteringCoefficient;
uniform float absorptionCoefficient;
uniform vec3 albedo;

// Primary raymarch
uniform float minDensity;
uniform float minExtinction;
uniform float minTransmittance;

// Shape and weather
uniform sampler2D localWeatherTexture;
uniform vec2 localWeatherRepeat;
uniform vec2 localWeatherOffset;
uniform float coverage;
uniform sampler3D shapeTexture;
uniform vec3 shapeRepeat;
uniform vec3 shapeOffset;

#ifdef SHAPE_DETAIL
uniform sampler3D shapeDetailTexture;
uniform vec3 shapeDetailRepeat;
uniform vec3 shapeDetailOffset;
#endif // SHAPE_DETAIL

#ifdef TURBULENCE
uniform sampler2D turbulenceTexture;
uniform vec2 turbulenceRepeat;
uniform float turbulenceDisplacement;
#endif // TURBULENCE

// Haze
#ifdef HAZE
uniform float hazeDensityScale;
uniform float hazeExponent;
#endif // HAZE

// Cloud layers
uniform vec4 minLayerHeights;
uniform vec4 maxLayerHeights;
uniform vec3 minIntervalHeights;
uniform vec3 maxIntervalHeights;
uniform vec4 densityScales;
uniform vec4 shapeAmounts;
uniform vec4 shapeDetailAmounts;
uniform vec4 weatherExponents;
uniform vec4 shapeAlteringBiases;
uniform vec4 coverageFilterWidths;
uniform float minHeight;
uniform float maxHeight;
uniform float shadowTopHeight;
uniform float shadowBottomHeight;
uniform vec4 shadowLayerMask;
uniform DensityProfile densityProfile;
`, $ = `struct GroundIrradiance {
  vec3 sun;
  vec3 sky;
};

struct CloudsIrradiance {
  vec3 minSun;
  vec3 minSky;
  vec3 maxSun;
  vec3 maxSky;
};

struct DensityProfile {
  vec4 expTerms;
  vec4 exponents;
  vec4 linearTerms;
  vec4 constantTerms;
};
`;
var mt = Object.defineProperty, w = (o, e, t, n) => {
  for (var a = void 0, i = o.length - 1, s; i >= 0; i--)
    (s = o[i]) && (a = s(e, t, a) || a);
  return a && mt(e, t, a), a;
};
const vt = /* @__PURE__ */ new f(), gt = /* @__PURE__ */ new qe();
class y extends je {
  constructor({
    parameterUniforms: e,
    layerUniforms: t,
    atmosphereUniforms: n
  }, a = Ce.DEFAULT) {
    super(
      {
        name: "CloudsMaterial",
        glslVersion: W,
        vertexShader: M(ft, {
          atmosphere: {
            parameters: pe,
            functions: de
          },
          types: $
        }),
        fragmentShader: G(
          M(pt, {
            core: {
              depth: Qe,
              math: _e,
              turbo: Ae,
              generators: Je,
              raySphereIntersection: Ee,
              cascadedShadowMaps: Xe,
              interleavedGradientNoise: $e,
              vogelDisk: Ke
            },
            atmosphere: {
              parameters: pe,
              functions: de
            },
            types: $,
            parameters: Re,
            clouds: Oe
          })
        ),
        // prettier-ignore
        uniforms: {
          ...e,
          ...t,
          ...n,
          depthBuffer: new r(null),
          viewMatrix: new r(new v()),
          inverseProjectionMatrix: new r(new v()),
          inverseViewMatrix: new r(new v()),
          reprojectionMatrix: new r(new v()),
          resolution: new r(new m()),
          cameraNear: new r(0),
          cameraFar: new r(0),
          cameraHeight: new r(0),
          frame: new r(0),
          temporalJitter: new r(new m()),
          targetUvScale: new r(new m()),
          mipLevelScale: new r(1),
          stbnTexture: new r(null),
          // Scattering
          albedo: new r(new f()),
          skyIrradianceScale: new r(2.5),
          groundIrradianceScale: new r(3),
          powderScale: new r(0.8),
          powderExponent: new r(150),
          // Primary raymarch
          maxIterationCount: new r(l.clouds.maxIterationCount),
          minStepSize: new r(l.clouds.minStepSize),
          maxStepSize: new r(l.clouds.maxStepSize),
          maxRayDistance: new r(l.clouds.maxRayDistance),
          perspectiveStepScale: new r(l.clouds.perspectiveStepScale),
          minDensity: new r(l.clouds.minDensity),
          minExtinction: new r(l.clouds.minExtinction),
          minTransmittance: new r(l.clouds.minTransmittance),
          // Secondary raymarch
          maxIterationCountToSun: new r(l.clouds.maxIterationCountToSun),
          maxIterationCountToGround: new r(l.clouds.maxIterationCountToGround),
          minSecondaryStepSize: new r(l.clouds.minSecondaryStepSize),
          secondaryStepScale: new r(l.clouds.secondaryStepScale),
          // Beer shadow map
          shadowBuffer: new r(null),
          shadowTexelSize: new r(new m()),
          shadowIntervals: new r(
            Array.from({ length: 4 }, () => new m())
            // Populate the max number of elements
          ),
          shadowMatrices: new r(
            Array.from({ length: 4 }, () => new v())
            // Populate the max number of elements
          ),
          shadowFar: new r(0),
          maxShadowFilterRadius: new r(6),
          shadowLayerMask: new r(new x().setScalar(1)),
          // Disable mask
          // Shadow length
          maxShadowLengthIterationCount: new r(l.clouds.maxShadowLengthIterationCount),
          minShadowLengthStepSize: new r(l.clouds.minShadowLengthStepSize),
          maxShadowLengthRayDistance: new r(l.clouds.maxShadowLengthRayDistance),
          // Haze
          hazeDensityScale: new r(3e-5),
          hazeExponent: new r(1e-3)
        }
      },
      a
    ), this.temporalUpscale = !0, this.depthPacking = 0, this.localWeatherChannels = "rgba", this.shapeDetail = l.shapeDetail, this.turbulence = l.turbulence, this.shadowLength = l.lightShafts, this.haze = l.haze, this.multiScatteringOctaves = l.clouds.multiScatteringOctaves, this.accurateSunSkyIrradiance = l.clouds.accurateSunSkyIrradiance, this.accuratePhaseFunction = l.clouds.accuratePhaseFunction, this.shadowCascadeCount = l.shadow.cascadeCount, this.shadowSampleCount = 8, this.scatterAnisotropy1 = 0.7, this.scatterAnisotropy2 = -0.2, this.scatterAnisotropyMix = 0.5;
  }
  onBeforeRender(e, t, n, a, i, s) {
    const c = this.uniforms;
    c.albedo.value.setScalar(
      c.scatteringCoefficient.value / (c.absorptionCoefficient.value + c.scatteringCoefficient.value)
    );
    const h = this.defines.POWDER != null, u = this.uniforms.powderScale.value > 0;
    u !== h && (u ? this.defines.POWDER = "1" : delete this.defines.POWDER, this.needsUpdate = !0);
    const d = this.defines.GROUND_IRRADIANCE != null;
    (this.uniforms.groundIrradianceScale.value > 0 && this.uniforms.maxIterationCountToGround.value > 0) !== d && (u ? this.defines.GROUND_IRRADIANCE = "1" : delete this.defines.GROUND_IRRADIANCE, this.needsUpdate = !0);
  }
  copyCameraSettings(e) {
    e.isPerspectiveCamera === !0 ? this.defines.PERSPECTIVE_CAMERA !== "1" && (this.defines.PERSPECTIVE_CAMERA = "1", this.needsUpdate = !0) : this.defines.PERSPECTIVE_CAMERA != null && (delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = !0);
    const t = this.uniforms;
    t.viewMatrix.value.copy(e.matrixWorldInverse), t.inverseViewMatrix.value.copy(e.matrixWorld);
    const n = this.previousProjectionMatrix ?? e.projectionMatrix, a = this.previousViewMatrix ?? e.matrixWorldInverse, i = t.inverseProjectionMatrix.value, s = t.reprojectionMatrix.value;
    if (this.temporalUpscale) {
      const u = t.frame.value % 16, d = t.resolution.value, p = Pe[u], g = (p.x - 0.5) / d.x * 4, S = (p.y - 0.5) / d.y * 4;
      t.temporalJitter.value.set(g, S), t.mipLevelScale.value = 0.25, i.copy(e.projectionMatrix), i.elements[8] += g * 2, i.elements[9] += S * 2, i.invert(), s.copy(n), s.elements[8] += g * 2, s.elements[9] += S * 2, s.multiply(a);
    } else
      t.temporalJitter.value.setScalar(0), t.mipLevelScale.value = 1, i.copy(e.projectionMatrixInverse), s.copy(n).multiply(a);
    Ze(e), t.cameraNear.value = e.near, t.cameraFar.value = e.far;
    const c = e.getWorldPosition(
      t.cameraPosition.value
    ), h = vt.copy(c).applyMatrix4(t.inverseEllipsoidMatrix.value).sub(t.ellipsoidCenter.value);
    try {
      t.cameraHeight.value = gt.setFromECEF(h).height;
    } catch {
    }
  }
  // copyCameraSettings can be called multiple times within a frame. Only
  // reliable way is to explicitly store the matrices.
  copyReprojectionMatrix(e) {
    this.previousProjectionMatrix ?? (this.previousProjectionMatrix = new v()), this.previousViewMatrix ?? (this.previousViewMatrix = new v()), this.previousProjectionMatrix.copy(e.projectionMatrix), this.previousViewMatrix.copy(e.matrixWorldInverse);
  }
  setSize(e, t, n, a) {
    this.uniforms.resolution.value.set(e, t), n != null && a != null ? this.uniforms.targetUvScale.value.set(
      e / n,
      t / a
    ) : this.uniforms.targetUvScale.value.setScalar(1), this.previousProjectionMatrix = void 0, this.previousViewMatrix = void 0;
  }
  setShadowSize(e, t) {
    this.uniforms.shadowTexelSize.value.set(1 / e, 1 / t);
  }
  get depthBuffer() {
    return this.uniforms.depthBuffer.value;
  }
  set depthBuffer(e) {
    this.uniforms.depthBuffer.value = e;
  }
}
w([
  O("DEPTH_PACKING")
], y.prototype, "depthPacking");
w([
  De("LOCAL_WEATHER_CHANNELS", {
    validate: (o) => /^[rgba]{4}$/.test(o)
  })
], y.prototype, "localWeatherChannels");
w([
  C("SHAPE_DETAIL")
], y.prototype, "shapeDetail");
w([
  C("TURBULENCE")
], y.prototype, "turbulence");
w([
  C("SHADOW_LENGTH")
], y.prototype, "shadowLength");
w([
  C("HAZE")
], y.prototype, "haze");
w([
  O("MULTI_SCATTERING_OCTAVES", { min: 1, max: 12 })
], y.prototype, "multiScatteringOctaves");
w([
  C("ACCURATE_SUN_SKY_IRRADIANCE")
], y.prototype, "accurateSunSkyIrradiance");
w([
  C("ACCURATE_PHASE_FUNCTION")
], y.prototype, "accuratePhaseFunction");
w([
  O("SHADOW_CASCADE_COUNT", { min: 1, max: 4 })
], y.prototype, "shadowCascadeCount");
w([
  O("SHADOW_SAMPLE_COUNT", { min: 1, max: 16 })
], y.prototype, "shadowSampleCount");
w([
  J("SCATTER_ANISOTROPY_1")
], y.prototype, "scatterAnisotropy1");
w([
  J("SCATTER_ANISOTROPY_2")
], y.prototype, "scatterAnisotropy2");
w([
  J("SCATTER_ANISOTROPY_MIX")
], y.prototype, "scatterAnisotropyMix");
const St = `// Taken from https://gist.github.com/TheRealMJP/c83b8c0f46b63f3a88a5986f4fa982b1
// TODO: Use 5-taps version: https://www.shadertoy.com/view/MtVGWz
// Or even 4 taps (requires preprocessing in the input buffer):
// https://www.shadertoy.com/view/4tyGDD

/**
 * MIT License
 *
 * Copyright (c) 2019 MJP
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

vec4 textureCatmullRom(sampler2D tex, vec2 uv) {
  vec2 texSize = vec2(textureSize(tex, 0));

  // We're going to sample a a 4x4 grid of texels surrounding the target UV
  // coordinate. We'll do this by rounding down the sample location to get the
  // exact center of our "starting" texel. The starting texel will be at
  // location [1, 1] in the grid, where [0, 0] is the top left corner.
  vec2 samplePos = uv * texSize;
  vec2 texPos1 = floor(samplePos - 0.5) + 0.5;

  // Compute the fractional offset from our starting texel to our original
  // sample location, which we'll feed into the Catmull-Rom spline function to
  // get our filter weights.
  vec2 f = samplePos - texPos1;

  // Compute the Catmull-Rom weights using the fractional offset that we
  // calculated earlier. These equations are pre-expanded based on our knowledge
  // of where the texels will be located, which lets us avoid having to evaluate
  // a piece-wise function.
  vec2 w0 = f * (-0.5 + f * (1.0 - 0.5 * f));
  vec2 w1 = 1.0 + f * f * (-2.5 + 1.5 * f);
  vec2 w2 = f * (0.5 + f * (2.0 - 1.5 * f));
  vec2 w3 = f * f * (-0.5 + 0.5 * f);

  // Work out weighting factors and sampling offsets that will let us use
  // bilinear filtering to simultaneously evaluate the middle 2 samples from the
  // 4x4 grid.
  vec2 w12 = w1 + w2;
  vec2 offset12 = w2 / (w1 + w2);

  // Compute the final UV coordinates we'll use for sampling the texture
  vec2 texPos0 = texPos1 - 1.0;
  vec2 texPos3 = texPos1 + 2.0;
  vec2 texPos12 = texPos1 + offset12;

  texPos0 /= texSize;
  texPos3 /= texSize;
  texPos12 /= texSize;

  vec4 result = vec4(0.0);
  result += texture(tex, vec2(texPos0.x, texPos0.y)) * w0.x * w0.y;
  result += texture(tex, vec2(texPos12.x, texPos0.y)) * w12.x * w0.y;
  result += texture(tex, vec2(texPos3.x, texPos0.y)) * w3.x * w0.y;

  result += texture(tex, vec2(texPos0.x, texPos12.y)) * w0.x * w12.y;
  result += texture(tex, vec2(texPos12.x, texPos12.y)) * w12.x * w12.y;
  result += texture(tex, vec2(texPos3.x, texPos12.y)) * w3.x * w12.y;

  result += texture(tex, vec2(texPos0.x, texPos3.y)) * w0.x * w3.y;
  result += texture(tex, vec2(texPos12.x, texPos3.y)) * w12.x * w3.y;
  result += texture(tex, vec2(texPos3.x, texPos3.y)) * w3.x * w3.y;

  return result;
}

vec4 textureCatmullRom(sampler2DArray tex, vec3 uv) {
  vec2 texSize = vec2(textureSize(tex, 0));
  vec2 samplePos = uv.xy * texSize;
  vec2 texPos1 = floor(samplePos - 0.5) + 0.5;
  vec2 f = samplePos - texPos1;
  vec2 w0 = f * (-0.5 + f * (1.0 - 0.5 * f));
  vec2 w1 = 1.0 + f * f * (-2.5 + 1.5 * f);
  vec2 w2 = f * (0.5 + f * (2.0 - 1.5 * f));
  vec2 w3 = f * f * (-0.5 + 0.5 * f);
  vec2 w12 = w1 + w2;
  vec2 offset12 = w2 / (w1 + w2);
  vec2 texPos0 = texPos1 - 1.0;
  vec2 texPos3 = texPos1 + 2.0;
  vec2 texPos12 = texPos1 + offset12;
  texPos0 /= texSize;
  texPos3 /= texSize;
  texPos12 /= texSize;
  vec4 result = vec4(0.0);
  result += texture(tex, vec3(texPos0.x, texPos0.y, uv.z)) * w0.x * w0.y;
  result += texture(tex, vec3(texPos12.x, texPos0.y, uv.z)) * w12.x * w0.y;
  result += texture(tex, vec3(texPos3.x, texPos0.y, uv.z)) * w3.x * w0.y;
  result += texture(tex, vec3(texPos0.x, texPos12.y, uv.z)) * w0.x * w12.y;
  result += texture(tex, vec3(texPos12.x, texPos12.y, uv.z)) * w12.x * w12.y;
  result += texture(tex, vec3(texPos3.x, texPos12.y, uv.z)) * w3.x * w12.y;
  result += texture(tex, vec3(texPos0.x, texPos3.y, uv.z)) * w0.x * w3.y;
  result += texture(tex, vec3(texPos12.x, texPos3.y, uv.z)) * w12.x * w3.y;
  result += texture(tex, vec3(texPos3.x, texPos3.y, uv.z)) * w3.x * w3.y;
  return result;
}
`, yt = `precision highp float;
precision highp sampler2DArray;

#include "core/turbo"
#include "catmullRomSampling"
#include "varianceClipping"

uniform sampler2D colorBuffer;
uniform sampler2D depthVelocityBuffer;
uniform sampler2D colorHistoryBuffer;

#ifdef SHADOW_LENGTH
uniform sampler2D shadowLengthBuffer;
uniform sampler2D shadowLengthHistoryBuffer;
#endif // SHADOW_LENGTH

uniform vec2 texelSize;
uniform int frame;
uniform float varianceGamma;
uniform float temporalAlpha;
uniform vec2 jitterOffset;

in vec2 vUv;

layout(location = 0) out vec4 outputColor;
#ifdef SHADOW_LENGTH
layout(location = 1) out float outputShadowLength;
#endif // SHADOW_LENGTH

const ivec2 neighborOffsets[9] = ivec2[9](
  ivec2(-1, -1),
  ivec2(-1, 0),
  ivec2(-1, 1),
  ivec2(0, -1),
  ivec2(0, 0),
  ivec2(0, 1),
  ivec2(1, -1),
  ivec2(1, 0),
  ivec2(1, 1)
);

const ivec4[4] bayerIndices = ivec4[4](
  ivec4(0, 12, 3, 15),
  ivec4(8, 4, 11, 7),
  ivec4(2, 14, 1, 13),
  ivec4(10, 6, 9, 5)
);

vec2 getUnjitteredUv(ivec2 coord) {
  return (vec2(coord) + 0.5 - jitterOffset) * texelSize;
}

vec4 getClosestFragment(const vec2 uv) {
  vec4 result = vec4(1e7, 0.0, 0.0, 0.0);
  vec4 neighbor;
  #pragma unroll_loop_start
  for (int i = 0; i < 9; ++i) {
    neighbor = textureOffset(depthVelocityBuffer, uv, neighborOffsets[i]);
    if (neighbor.r < result.r) {
      result = neighbor;
    }
  }
  #pragma unroll_loop_end
  return result;
}

vec4 getClosestFragment(const ivec2 coord) {
  vec4 result = vec4(1e7, 0.0, 0.0, 0.0);
  vec4 neighbor;
  #pragma unroll_loop_start
  for (int i = 0; i < 9; ++i) {
    neighbor = texelFetchOffset(depthVelocityBuffer, coord, 0, neighborOffsets[i]);
    if (neighbor.r < result.r) {
      result = neighbor;
    }
  }
  #pragma unroll_loop_end
  return result;
}

void temporalUpscale(
  const ivec2 coord,
  const ivec2 lowResCoord,
  const bool currentFrame,
  out vec4 outputColor,
  out float outputShadowLength
) {
  #if !defined(DEBUG_SHOW_VELOCITY)
  if (currentFrame) {
    // Use the texel just rendered without any accumulation.
    outputColor = texelFetch(colorBuffer, lowResCoord, 0);
    #ifdef SHADOW_LENGTH
    outputShadowLength = texelFetch(shadowLengthBuffer, lowResCoord, 0).r;
    #endif // SHADOW_LENGTH
    return;
  }
  #endif // !defined(DEBUG_SHOW_VELOCITY)

  vec2 unjitteredUv = getUnjitteredUv(coord);
  vec4 currentColor = texture(colorBuffer, unjitteredUv);
  #ifdef SHADOW_LENGTH
  vec4 currentShadowLength = vec4(texture(shadowLengthBuffer, unjitteredUv).rgb, 1.0);
  #endif // SHADOW_LENGTH

  vec4 depthVelocity = getClosestFragment(unjitteredUv);
  vec2 velocity = depthVelocity.gb * texelSize;
  vec2 prevUv = vUv - velocity;
  if (prevUv.x < 0.0 || prevUv.x > 1.0 || prevUv.y < 0.0 || prevUv.y > 1.0) {
    outputColor = currentColor;
    #ifdef SHADOW_LENGTH
    outputShadowLength = currentShadowLength.r;
    #endif // SHADOW_LENGTH
    return; // Rejection
  }

  // Variance clipping with a large variance gamma seems to work fine for
  // upsampling. This increases ghosting, of course, but it's hard to notice on
  // clouds.
  // vec4 historyColor = textureCatmullRom(colorHistoryBuffer, prevUv);
  vec4 historyColor = texture(colorHistoryBuffer, prevUv);
  vec4 clippedColor = varianceClipping(colorBuffer, vUv, currentColor, historyColor, varianceGamma);
  outputColor = clippedColor;

  #ifdef DEBUG_SHOW_VELOCITY
  outputColor.rgb = outputColor.rgb + vec3(abs(velocity), 0.0);
  #endif // DEBUG_SHOW_VELOCITY

  #ifdef SHADOW_LENGTH
  // Sampling the shadow length history using scene depth doesn't make much
  // sense, but it's too hard to derive it properly. At least this approach
  // resolves the edges of scene objects.
  // vec4 historyShadowLength = vec4(textureCatmullRom(shadowLengthHistoryBuffer, prevUv).rgb, 1.0);
  vec4 historyShadowLength = vec4(texture(shadowLengthHistoryBuffer, prevUv).rgb, 1.0);
  vec4 clippedShadowLength = varianceClipping(
    shadowLengthBuffer,
    vUv,
    currentShadowLength,
    historyShadowLength,
    varianceGamma
  );
  outputShadowLength = clippedShadowLength.r;
  #endif // SHADOW_LENGTH
}

void temporalAntialiasing(const ivec2 coord, out vec4 outputColor, out float outputShadowLength) {
  vec4 currentColor = texelFetch(colorBuffer, coord, 0);
  #ifdef SHADOW_LENGTH
  vec4 currentShadowLength = vec4(texelFetch(shadowLengthBuffer, coord, 0).rgb, 1.0);
  #endif // SHADOW_LENGTH

  vec4 depthVelocity = getClosestFragment(coord);
  vec2 velocity = depthVelocity.gb * texelSize;

  vec2 prevUv = vUv - velocity;
  if (prevUv.x < 0.0 || prevUv.x > 1.0 || prevUv.y < 0.0 || prevUv.y > 1.0) {
    outputColor = currentColor;
    #ifdef SHADOW_LENGTH
    outputShadowLength = currentShadowLength.r;
    #endif // SHADOW_LENGTH
    return; // Rejection
  }

  vec4 historyColor = texture(colorHistoryBuffer, prevUv);
  vec4 clippedColor = varianceClipping(colorBuffer, coord, currentColor, historyColor);
  outputColor = mix(clippedColor, currentColor, temporalAlpha);

  #ifdef DEBUG_SHOW_VELOCITY
  outputColor.rgb = outputColor.rgb + vec3(abs(velocity), 0.0);
  #endif // DEBUG_SHOW_VELOCITY

  #ifdef SHADOW_LENGTH
  vec4 historyShadowLength = vec4(texture(shadowLengthHistoryBuffer, prevUv).rgb, 1.0);
  vec4 clippedShadowLength = varianceClipping(
    shadowLengthBuffer,
    coord,
    currentShadowLength,
    historyShadowLength
  );
  outputShadowLength = mix(clippedShadowLength.r, currentShadowLength.r, temporalAlpha);
  #endif // SHADOW_LENGTH
}

void main() {
  ivec2 coord = ivec2(gl_FragCoord.xy);

  #if !defined(SHADOW_LENGTH)
  float outputShadowLength;
  #endif // !defined(SHADOW_LENGTH)

  #ifdef TEMPORAL_UPSCALE
  ivec2 lowResCoord = coord / 4;
  int bayerValue = bayerIndices[coord.x % 4][coord.y % 4];
  bool currentFrame = bayerValue == frame % 16;
  temporalUpscale(coord, lowResCoord, currentFrame, outputColor, outputShadowLength);
  #else // TEMPORAL_UPSCALE
  temporalAntialiasing(coord, outputColor, outputShadowLength);
  #endif // TEMPORAL_UPSCALE

  #if defined(SHADOW_LENGTH) && defined(DEBUG_SHOW_SHADOW_LENGTH)
  outputColor = vec4(turbo(outputShadowLength * 0.05), 1.0);
  #endif // defined(SHADOW_LENGTH) && defined(DEBUG_SHOW_SHADOW_LENGTH)
}
`, xt = `precision highp float;

layout(location = 0) in vec3 position;

out vec2 vUv;

void main() {
  vUv = position.xy * 0.5 + 0.5;
  gl_Position = vec4(position.xy, 1.0, 1.0);
}
`, Le = `#ifdef VARIANCE_9_SAMPLES
#define VARIANCE_OFFSET_COUNT (8)
const ivec2 varianceOffsets[8] = ivec2[8](
  ivec2(-1, -1),
  ivec2(-1, 1),
  ivec2(1, -1),
  ivec2(1, 1),
  ivec2(1, 0),
  ivec2(0, -1),
  ivec2(0, 1),
  ivec2(-1, 0)
);
#else // VARIANCE_9_SAMPLES
#define VARIANCE_OFFSET_COUNT (4)
const ivec2 varianceOffsets[4] = ivec2[4](ivec2(1, 0), ivec2(0, -1), ivec2(0, 1), ivec2(-1, 0));
#endif // VARIANCE_9_SAMPLES

// Reference: https://github.com/playdeadgames/temporal
vec4 clipAABB(const vec4 current, const vec4 history, const vec4 minColor, const vec4 maxColor) {
  vec3 pClip = 0.5 * (maxColor.rgb + minColor.rgb);
  vec3 eClip = 0.5 * (maxColor.rgb - minColor.rgb) + 1e-7;
  vec4 vClip = history - vec4(pClip, current.a);
  vec3 vUnit = vClip.xyz / eClip;
  vec3 aUnit = abs(vUnit);
  float maUnit = max(aUnit.x, max(aUnit.y, aUnit.z));
  if (maUnit > 1.0) {
    return vec4(pClip, current.a) + vClip / maUnit;
  }
  return history;
}

#ifdef VARIANCE_SAMPLER_ARRAY
#define VARIANCE_SAMPLER sampler2DArray
#define VARIANCE_SAMPLER_COORD ivec3
#else // VARIANCE_SAMPLER_ARRAY
#define VARIANCE_SAMPLER sampler2D
#define VARIANCE_SAMPLER_COORD ivec2
#endif // VARIANCE_SAMPLER_ARRAY

// Variance clipping
// Reference: https://developer.download.nvidia.com/gameworks/events/GDC2016/msalvi_temporal_supersampling.pdf
vec4 varianceClipping(
  const VARIANCE_SAMPLER inputBuffer,
  const VARIANCE_SAMPLER_COORD coord,
  const vec4 current,
  const vec4 history,
  const float gamma
) {
  vec4 moment1 = current;
  vec4 moment2 = current * current;
  vec4 neighbor;
  #pragma unroll_loop_start
  for (int i = 0; i < 8; ++i) {
    #if UNROLLED_LOOP_INDEX < VARIANCE_OFFSET_COUNT
    neighbor = texelFetchOffset(inputBuffer, coord, 0, varianceOffsets[i]);
    moment1 += neighbor;
    moment2 += neighbor * neighbor;
    #endif // UNROLLED_LOOP_INDEX < VARIANCE_OFFSET_COUNT
  }
  #pragma unroll_loop_end

  const float N = float(VARIANCE_OFFSET_COUNT + 1);
  vec4 mean = moment1 / N;
  vec4 varianceGamma = sqrt(max(moment2 / N - mean * mean, 0.0)) * gamma;
  vec4 minColor = mean - varianceGamma;
  vec4 maxColor = mean + varianceGamma;
  return clipAABB(clamp(mean, minColor, maxColor), history, minColor, maxColor);
}

vec4 varianceClipping(
  const VARIANCE_SAMPLER inputBuffer,
  const VARIANCE_SAMPLER_COORD coord,
  const vec4 current,
  const vec4 history
) {
  return varianceClipping(inputBuffer, coord, current, history, 1.0);
}

vec4 varianceClipping(
  const sampler2D inputBuffer,
  const vec2 coord,
  const vec4 current,
  const vec4 history,
  const float gamma
) {
  vec4 moment1 = current;
  vec4 moment2 = current * current;
  vec4 neighbor;
  #pragma unroll_loop_start
  for (int i = 0; i < 8; ++i) {
    #if UNROLLED_LOOP_INDEX < VARIANCE_OFFSET_COUNT
    neighbor = textureOffset(inputBuffer, coord, varianceOffsets[i]);
    moment1 += neighbor;
    moment2 += neighbor * neighbor;
    #endif // UNROLLED_LOOP_INDEX < VARIANCE_OFFSET_COUNT
  }
  #pragma unroll_loop_end

  const float N = float(VARIANCE_OFFSET_COUNT + 1);
  vec4 mean = moment1 / N;
  vec4 varianceGamma = sqrt(max(moment2 / N - mean * mean, 0.0)) * gamma;
  vec4 minColor = mean - varianceGamma;
  vec4 maxColor = mean + varianceGamma;
  return clipAABB(clamp(mean, minColor, maxColor), history, minColor, maxColor);
}

vec4 varianceClipping(
  const sampler2D inputBuffer,
  const vec2 coord,
  const vec4 current,
  const vec4 history
) {
  return varianceClipping(inputBuffer, coord, current, history, 1.0);
}
`;
var wt = Object.defineProperty, Ie = (o, e, t, n) => {
  for (var a = void 0, i = o.length - 1, s; i >= 0; i--)
    (s = o[i]) && (a = s(e, t, a) || a);
  return a && wt(e, t, a), a;
};
class Q extends X {
  constructor({
    colorBuffer: e = null,
    depthVelocityBuffer: t = null,
    shadowLengthBuffer: n = null,
    colorHistoryBuffer: a = null,
    shadowLengthHistoryBuffer: i = null
  } = {}) {
    super({
      name: "CloudsResolveMaterial",
      glslVersion: W,
      vertexShader: xt,
      fragmentShader: G(
        M(yt, {
          core: { turbo: Ae },
          catmullRomSampling: St,
          varianceClipping: Le
        })
      ),
      uniforms: {
        colorBuffer: new r(e),
        depthVelocityBuffer: new r(t),
        shadowLengthBuffer: new r(n),
        colorHistoryBuffer: new r(a),
        shadowLengthHistoryBuffer: new r(i),
        texelSize: new r(new m()),
        frame: new r(0),
        jitterOffset: new r(new m()),
        varianceGamma: new r(2),
        temporalAlpha: new r(0.1)
      }
    }), this.temporalUpscale = !0, this.shadowLength = !0;
  }
  setSize(e, t) {
    this.uniforms.texelSize.value.set(1 / e, 1 / t);
  }
  onBeforeRender(e, t, n, a, i, s) {
    const h = this.uniforms.frame.value % 16, u = Pe[h], d = (u.x - 0.5) * 4, p = (u.y - 0.5) * 4;
    this.uniforms.jitterOffset.value.set(d, p);
  }
}
Ie([
  C("TEMPORAL_UPSCALE")
], Q.prototype, "temporalUpscale");
Ie([
  C("SHADOW_LENGTH")
], Q.prototype, "shadowLength");
class Ne extends He {
  constructor(e, t) {
    super(e), this._mainCamera = new xe();
    const { shadow: n } = t;
    this.shadow = n;
  }
  get mainCamera() {
    return this._mainCamera;
  }
  set mainCamera(e) {
    this._mainCamera = e;
  }
}
function k(o, { depthVelocity: e, shadowLength: t }) {
  const n = new Ge(1, 1, {
    depthBuffer: !1,
    stencilBuffer: !1,
    type: we
  });
  n.texture.minFilter = z, n.texture.magFilter = z, n.texture.name = o;
  let a;
  e && (a = n.texture.clone(), a.isRenderTargetTexture = !0, n.depthVelocity = a, n.textures.push(a));
  let i;
  return t && (i = n.texture.clone(), i.isRenderTargetTexture = !0, i.format = Be, n.shadowLength = i, n.textures.push(i)), Object.assign(n, {
    depthVelocity: a ?? null,
    shadowLength: i ?? null
  });
}
class Ct extends Ne {
  constructor({
    parameterUniforms: e,
    layerUniforms: t,
    atmosphereUniforms: n,
    ...a
  }, i) {
    super("CloudsPass", a), this.atmosphere = i, this.width = 0, this.height = 0, this.currentMaterial = new y(
      {
        parameterUniforms: e,
        layerUniforms: t,
        atmosphereUniforms: n
      },
      i
    ), this.currentPass = new Z(this.currentMaterial), this.resolveMaterial = new Q(), this.resolvePass = new Z(this.resolveMaterial), this.initRenderTargets({
      depthVelocity: !0,
      shadowLength: l.lightShafts
    });
  }
  copyCameraSettings(e) {
    this.currentMaterial.copyCameraSettings(e);
  }
  initialize(e, t, n) {
    this.currentPass.initialize(e, t, n), this.resolvePass.initialize(e, t, n);
  }
  initRenderTargets(e) {
    var s, c, h;
    (s = this.currentRenderTarget) == null || s.dispose(), (c = this.resolveRenderTarget) == null || c.dispose(), (h = this.historyRenderTarget) == null || h.dispose();
    const t = k("Clouds", e), n = k("Clouds.A", {
      ...e,
      depthVelocity: !1
    }), a = k("Clouds.B", {
      ...e,
      depthVelocity: !1
    });
    this.currentRenderTarget = t, this.resolveRenderTarget = n, this.historyRenderTarget = a;
    const i = this.resolveMaterial.uniforms;
    i.colorBuffer.value = t.texture, i.depthVelocityBuffer.value = t.depthVelocity, i.shadowLengthBuffer.value = t.shadowLength, i.colorHistoryBuffer.value = a.texture, i.shadowLengthHistoryBuffer.value = a.shadowLength;
  }
  copyShadow() {
    const e = this.shadow, t = this.currentMaterial.uniforms;
    for (let n = 0; n < e.cascadeCount; ++n) {
      const a = e.cascades[n];
      t.shadowIntervals.value[n].copy(a.interval), t.shadowMatrices.value[n].copy(a.matrix);
    }
    t.shadowFar.value = e.far;
  }
  copyReprojection() {
    this.currentMaterial.copyReprojectionMatrix(this.mainCamera);
  }
  swapBuffers() {
    const e = this.historyRenderTarget, t = this.resolveRenderTarget;
    this.resolveRenderTarget = e, this.historyRenderTarget = t;
    const n = this.resolveMaterial.uniforms;
    n.colorHistoryBuffer.value = t.texture, n.shadowLengthHistoryBuffer.value = t.shadowLength;
  }
  update(e, t, n) {
    this.currentMaterial.uniforms.frame.value = t, this.resolveMaterial.uniforms.frame.value = t, this.copyCameraSettings(this.mainCamera), this.copyShadow(), this.currentPass.render(e, null, this.currentRenderTarget), this.resolvePass.render(e, null, this.resolveRenderTarget), this.copyReprojection(), this.swapBuffers();
  }
  setSize(e, t) {
    if (this.width = e, this.height = t, this.temporalUpscale) {
      const n = Math.ceil(e / 4), a = Math.ceil(t / 4);
      this.currentRenderTarget.setSize(n, a), this.currentMaterial.setSize(
        n * 4,
        a * 4,
        e,
        t
      );
    } else
      this.currentRenderTarget.setSize(e, t), this.currentMaterial.setSize(e, t);
    this.resolveRenderTarget.setSize(e, t), this.resolveMaterial.setSize(e, t), this.historyRenderTarget.setSize(e, t);
  }
  setShadowSize(e, t, n) {
    this.currentMaterial.shadowCascadeCount = n, this.currentMaterial.setShadowSize(e, t);
  }
  setDepthTexture(e, t) {
    this.currentMaterial.depthBuffer = e, this.currentMaterial.depthPacking = t ?? 0;
  }
  get outputBuffer() {
    return this.historyRenderTarget.texture;
  }
  get shadowBuffer() {
    return this.currentMaterial.uniforms.shadowBuffer.value;
  }
  set shadowBuffer(e) {
    this.currentMaterial.uniforms.shadowBuffer.value = e;
  }
  get shadowLengthBuffer() {
    return this.historyRenderTarget.shadowLength;
  }
  get temporalUpscale() {
    return this.currentMaterial.temporalUpscale;
  }
  set temporalUpscale(e) {
    e !== this.temporalUpscale && (this.currentMaterial.temporalUpscale = e, this.resolveMaterial.temporalUpscale = e, this.setSize(this.width, this.height));
  }
  get lightShafts() {
    return this.currentMaterial.shadowLength;
  }
  set lightShafts(e) {
    e !== this.lightShafts && (this.currentMaterial.shadowLength = e, this.resolveMaterial.shadowLength = e, this.initRenderTargets({
      depthVelocity: !0,
      shadowLength: e
    }), this.setSize(this.width, this.height));
  }
}
function Tt(o, e) {
  const t = o.properties.get(e.texture).__webglTexture, n = o.getContext();
  A(n instanceof WebGL2RenderingContext), o.setRenderTarget(e);
  const a = [];
  if (t != null)
    for (let i = 0; i < e.depth; ++i)
      n.framebufferTextureLayer(
        n.FRAMEBUFFER,
        n.COLOR_ATTACHMENT0 + i,
        t,
        0,
        i
      ), a.push(n.COLOR_ATTACHMENT0 + i);
  n.drawBuffers(a);
}
class ye extends Z {
  render(e, t, n, a, i) {
    const s = this.fullscreenMaterial.uniforms;
    t !== null && (s == null ? void 0 : s[this.input]) != null && (s[this.input].value = t.texture), Tt(e, n), e.render(this.scene, this.camera);
  }
}
const Dt = `precision highp float;
precision highp sampler3D;

#include <common>

#include "core/math"
#include "core/raySphereIntersection"
#include "types"
#include "parameters"
#include "structuredSampling"
#include "clouds"

uniform mat4 inverseShadowMatrices[CASCADE_COUNT];
uniform mat4 reprojectionMatrices[CASCADE_COUNT];

// Primary raymarch
uniform int maxIterationCount;
uniform float minStepSize;
uniform float maxStepSize;
uniform float opticalDepthTailScale;

in vec2 vUv;
in vec3 vEllipsoidCenter;

layout(location = 0) out vec4 outputColor[CASCADE_COUNT];

// Redundant notation for prettier.
#if CASCADE_COUNT == 1
layout(location = 1) out vec3 outputDepthVelocity[CASCADE_COUNT];
#elif CASCADE_COUNT == 2
layout(location = 2) out vec3 outputDepthVelocity[CASCADE_COUNT];
#elif CASCADE_COUNT == 3
layout(location = 3) out vec3 outputDepthVelocity[CASCADE_COUNT];
#elif CASCADE_COUNT == 4
layout(location = 4) out vec3 outputDepthVelocity[CASCADE_COUNT];
#endif // CASCADE_COUNT

vec4 marchClouds(
  const vec3 rayOrigin,
  const vec3 rayDirection,
  const float maxRayDistance,
  const float jitter,
  const float mipLevel
) {
  // Setup structured volume sampling (SVS).
  // While SVS introduces spatial aliasing, it is indeed temporally stable,
  // which is important for lower-resolution shadow maps where a flickering
  // single pixel can be highly noticeable.
  vec3 normal = getStructureNormal(rayDirection, jitter);
  float rayDistance;
  float stepSize;
  intersectStructuredPlanes(
    normal,
    rayOrigin,
    rayDirection,
    clamp(maxRayDistance / float(maxIterationCount), minStepSize, maxStepSize),
    rayDistance,
    stepSize
  );

  #ifdef TEMPORAL_JITTER
  rayDistance -= stepSize * jitter;
  #endif // TEMPORAL_JITTER

  float extinctionSum = 0.0;
  float maxOpticalDepth = 0.0;
  float maxOpticalDepthTail = 0.0;
  float transmittanceIntegral = 1.0;
  float weightedDistanceSum = 0.0;
  float transmittanceSum = 0.0;

  int sampleCount = 0;
  for (int i = 0; i < maxIterationCount; ++i) {
    if (rayDistance > maxRayDistance) {
      break; // Termination
    }

    vec3 position = rayDistance * rayDirection + rayOrigin;
    float height = length(position) - bottomRadius;

    #if !defined(DEBUG_MARCH_INTERVALS)
    if (insideLayerIntervals(height)) {
      rayDistance += stepSize;
      continue;
    }
    #endif // !defined(DEBUG_MARCH_INTERVALS)

    // Sample rough weather.
    vec2 uv = getGlobeUv(position);
    WeatherSample weather = sampleWeather(uv, height, mipLevel);

    if (any(greaterThan(weather.density, vec4(minDensity)))) {
      // Sample detailed participating media.
      // Note this assumes an homogeneous medium.
      MediaSample media = sampleMedia(weather, position, uv, mipLevel, jitter);
      if (media.extinction > minExtinction) {
        extinctionSum += media.extinction;
        maxOpticalDepth += media.extinction * stepSize;
        transmittanceIntegral *= exp(-media.extinction * stepSize);
        weightedDistanceSum += rayDistance * transmittanceIntegral;
        transmittanceSum += transmittanceIntegral;
        ++sampleCount;
      }
    }

    if (transmittanceIntegral <= minTransmittance) {
      // A large amount of optical depth accumulates in the tail, beyond the
      // point of minimum transmittance. The expected optical depth seems to
      // decrease exponentially with the number of samples taken before reaching
      // the minimum transmittance.
      // See the discussion here: https://x.com/shotamatsuda/status/1886259549931520437
      maxOpticalDepthTail = min(
        opticalDepthTailScale * stepSize * exp(float(1 - sampleCount)),
        stepSize * 0.5 // Excessive optical depth only introduces aliasing.
      );
      break; // Early termination
    }
    rayDistance += stepSize;
  }

  if (sampleCount == 0) {
    return vec4(maxRayDistance, 0.0, 0.0, 0.0);
  }
  float frontDepth = min(weightedDistanceSum / transmittanceSum, maxRayDistance);
  float meanExtinction = extinctionSum / float(sampleCount);
  return vec4(frontDepth, meanExtinction, maxOpticalDepth, maxOpticalDepthTail);
}

void getRayNearFar(
  const vec3 sunPosition,
  const vec3 rayDirection,
  out float rayNear,
  out float rayFar
) {
  vec4 firstIntersections = raySphereFirstIntersection(
    sunPosition,
    rayDirection,
    vec3(0.0),
    bottomRadius + vec4(shadowTopHeight, shadowBottomHeight, 0.0, 0.0)
  );
  rayNear = max(0.0, firstIntersections.x);
  rayFar = firstIntersections.y;
  if (rayFar < 0.0) {
    rayFar = 1e6;
  }
}

void cascade(
  const int cascadeIndex,
  const float mipLevel,
  out vec4 outputColor,
  out vec3 outputDepthVelocity
) {
  vec2 clip = vUv * 2.0 - 1.0;
  vec4 point = inverseShadowMatrices[cascadeIndex] * vec4(clip.xy, -1.0, 1.0);
  point /= point.w;
  vec3 sunPosition = mat3(inverseEllipsoidMatrix) * point.xyz - vEllipsoidCenter;

  // The sun direction is in ECEF. Since the view matrix is constructed with the
  // ellipsoid matrix already applied, there's no need to apply the inverse
  // matrix here.
  vec3 rayDirection = normalize(-sunDirection);
  float rayNear;
  float rayFar;
  getRayNearFar(sunPosition, rayDirection, rayNear, rayFar);

  vec3 rayOrigin = rayNear * rayDirection + sunPosition;
  float stbn = getSTBN();
  vec4 color = marchClouds(rayOrigin, rayDirection, rayFar - rayNear, stbn, mipLevel);
  outputColor = color;

  // Velocity for temporal resolution.
  #ifdef TEMPORAL_PASS
  vec3 frontPosition = color.x * rayDirection + rayOrigin;
  vec3 frontPositionWorld = mat3(ellipsoidMatrix) * (frontPosition + vEllipsoidCenter);
  vec4 prevClip = reprojectionMatrices[cascadeIndex] * vec4(frontPositionWorld, 1.0);
  prevClip /= prevClip.w;
  vec2 prevUv = prevClip.xy * 0.5 + 0.5;
  vec2 velocity = (vUv - prevUv) * resolution;
  outputDepthVelocity = vec3(color.x, velocity);
  #else // TEMPORAL_PASS
  outputDepthVelocity = vec3(0.0);
  #endif // TEMPORAL_PASS
}

// TODO: Calculate from the main camera frustum perhaps?
const float mipLevels[4] = float[4](0.0, 0.5, 1.0, 2.0);

void main() {
  #pragma unroll_loop_start
  for (int i = 0; i < 4; ++i) {
    #if UNROLLED_LOOP_INDEX < CASCADE_COUNT
    cascade(UNROLLED_LOOP_INDEX, mipLevels[i], outputColor[i], outputDepthVelocity[i]);
    #endif // UNROLLED_LOOP_INDEX < CASCADE_COUNT
  }
  #pragma unroll_loop_end
}
`, Et = `precision highp float;

uniform vec3 ellipsoidCenter;
uniform vec3 altitudeCorrection;

layout(location = 0) in vec3 position;

out vec2 vUv;
out vec3 vEllipsoidCenter;

void main() {
  vUv = position.xy * 0.5 + 0.5;
  vEllipsoidCenter = ellipsoidCenter + altitudeCorrection;

  gl_Position = vec4(position.xy, 1.0, 1.0);
}
`, At = `// Implements Structured Volume Sampling in fragment shader:
// https://github.com/huwb/volsample
// Implementation reference:
// https://www.shadertoy.com/view/ttVfDc

void getIcosahedralVertices(const vec3 direction, out vec3 v1, out vec3 v2, out vec3 v3) {
  // Normalization scalers to fit dodecahedron to unit sphere.
  const float a = 0.85065080835204; // phi / sqrt(2 + phi)
  const float b = 0.5257311121191336; // 1 / sqrt(2 + phi)

  // Derive the vertices of icosahedron where triangle intersects the direction.
  // See: https://www.ppsloan.org/publications/AmbientDice.pdf
  const float kT = 0.6180339887498948; // 1 / phi
  const float kT2 = 0.38196601125010515; // 1 / phi^2
  vec3 absD = abs(direction);
  float selector1 = dot(absD, vec3(1.0, kT2, -kT));
  float selector2 = dot(absD, vec3(-kT, 1.0, kT2));
  float selector3 = dot(absD, vec3(kT2, -kT, 1.0));
  v1 = selector1 > 0.0 ? vec3(a, b, 0.0) : vec3(-b, 0.0, a);
  v2 = selector2 > 0.0 ? vec3(0.0, a, b) : vec3(a, -b, 0.0);
  v3 = selector3 > 0.0 ? vec3(b, 0.0, a) : vec3(0.0, a, -b);
  vec3 octantSign = sign(direction);
  v1 *= octantSign;
  v2 *= octantSign;
  v3 *= octantSign;
}

void swapIfBigger(inout vec4 a, inout vec4 b) {
  if (a.w > b.w) {
    vec4 t = a;
    a = b;
    b = t;
  }
}

void sortVertices(inout vec3 a, inout vec3 b, inout vec3 c) {
  const vec3 base = vec3(0.5, 0.5, 1.0);
  vec4 aw = vec4(a, dot(a, base));
  vec4 bw = vec4(b, dot(b, base));
  vec4 cw = vec4(c, dot(c, base));
  swapIfBigger(aw, bw);
  swapIfBigger(bw, cw);
  swapIfBigger(aw, bw);
  a = aw.xyz;
  b = bw.xyz;
  c = cw.xyz;
}

vec3 getPentagonalWeights(const vec3 direction, const vec3 v1, const vec3 v2, const vec3 v3) {
  float d1 = dot(v1, direction);
  float d2 = dot(v2, direction);
  float d3 = dot(v3, direction);
  vec3 w = exp(vec3(d1, d2, d3) * 40.0);
  return w / (w.x + w.y + w.z);
}

vec3 getStructureNormal(
  const vec3 direction,
  const float jitter,
  out vec3 a,
  out vec3 b,
  out vec3 c,
  out vec3 weights
) {
  getIcosahedralVertices(direction, a, b, c);
  sortVertices(a, b, c);
  weights = getPentagonalWeights(direction, a, b, c);
  return jitter < weights.x
    ? a
    : jitter < weights.x + weights.y
      ? b
      : c;
}

vec3 getStructureNormal(const vec3 direction, const float jitter) {
  vec3 a, b, c, weights;
  return getStructureNormal(direction, jitter, a, b, c, weights);
}

// Reference: https://github.com/huwb/volsample/blob/master/src/unity/Assets/Shaders/RayMarchCore.cginc
void intersectStructuredPlanes(
  const vec3 normal,
  const vec3 rayOrigin,
  const vec3 rayDirection,
  const float samplePeriod,
  out float stepOffset,
  out float stepSize
) {
  float NoD = dot(rayDirection, normal);
  stepSize = samplePeriod / abs(NoD);

  // Skips leftover bit to get from rayOrigin to first strata plane.
  stepOffset = -mod(dot(rayOrigin, normal), samplePeriod) / NoD;

  // mod() gives different results depending on if the arg is negative or
  // positive. This line makes it consistent, and ensures the first sample is in
  // front of the viewer.
  if (stepOffset < 0.0) {
    stepOffset += stepSize;
  }
}
`;
var _t = Object.defineProperty, R = (o, e, t, n) => {
  for (var a = void 0, i = o.length - 1, s; i >= 0; i--)
    (s = o[i]) && (a = s(e, t, a) || a);
  return a && _t(e, t, a), a;
};
class _ extends X {
  constructor({
    parameterUniforms: e,
    layerUniforms: t,
    atmosphereUniforms: n
  }) {
    super({
      name: "ShadowMaterial",
      glslVersion: W,
      vertexShader: Et,
      fragmentShader: G(
        M(Dt, {
          core: {
            math: _e,
            raySphereIntersection: Ee
          },
          types: $,
          parameters: Re,
          structuredSampling: At,
          clouds: Oe
        })
      ),
      uniforms: {
        ...e,
        ...t,
        ...n,
        inverseShadowMatrices: new r(
          Array.from({ length: 4 }, () => new v())
          // Populate the max number of elements
        ),
        reprojectionMatrices: new r(
          Array.from({ length: 4 }, () => new v())
          // Populate the max number of elements
        ),
        resolution: new r(new m()),
        frame: new r(0),
        stbnTexture: new r(null),
        // Primary raymarch
        maxIterationCount: new r(l.shadow.maxIterationCount),
        minStepSize: new r(l.shadow.minStepSize),
        maxStepSize: new r(l.shadow.maxStepSize),
        minDensity: new r(l.shadow.minDensity),
        minExtinction: new r(l.shadow.minExtinction),
        minTransmittance: new r(l.shadow.minTransmittance),
        opticalDepthTailScale: new r(2)
      },
      defines: {
        SHADOW: "1",
        TEMPORAL_PASS: "1",
        TEMPORAL_JITTER: "1"
      }
    }), this.localWeatherChannels = "rgba", this.cascadeCount = l.shadow.cascadeCount, this.temporalPass = !0, this.temporalJitter = !0, this.shapeDetail = l.shapeDetail, this.turbulence = l.turbulence, this.cascadeCount = l.shadow.cascadeCount;
  }
  setSize(e, t) {
    this.uniforms.resolution.value.set(e, t);
  }
}
R([
  De("LOCAL_WEATHER_CHANNELS", {
    validate: (o) => /^[rgba]{4}$/.test(o)
  })
], _.prototype, "localWeatherChannels");
R([
  O("CASCADE_COUNT", { min: 1, max: 4 })
], _.prototype, "cascadeCount");
R([
  C("TEMPORAL_PASS")
], _.prototype, "temporalPass");
R([
  C("TEMPORAL_JITTER")
], _.prototype, "temporalJitter");
R([
  C("SHAPE_DETAIL")
], _.prototype, "shapeDetail");
R([
  C("TURBULENCE")
], _.prototype, "turbulence");
const Pt = `precision highp float;
precision highp sampler2DArray;

#define VARIANCE_9_SAMPLES (1)
#define VARIANCE_SAMPLER_ARRAY (1)

#include "varianceClipping"

uniform sampler2DArray inputBuffer;
uniform sampler2DArray historyBuffer;

uniform vec2 texelSize;
uniform float varianceGamma;
uniform float temporalAlpha;

in vec2 vUv;

layout(location = 0) out vec4 outputColor[CASCADE_COUNT];

const ivec2 neighborOffsets[9] = ivec2[9](
  ivec2(-1, -1),
  ivec2(-1, 0),
  ivec2(-1, 1),
  ivec2(0, -1),
  ivec2(0, 0),
  ivec2(0, 1),
  ivec2(1, -1),
  ivec2(1, 0),
  ivec2(1, 1)
);

vec4 getClosestFragment(const ivec3 coord) {
  vec4 result = vec4(1e7, 0.0, 0.0, 0.0);
  vec4 neighbor;
  #pragma unroll_loop_start
  for (int i = 0; i < 9; ++i) {
    neighbor = texelFetchOffset(
      inputBuffer,
      coord + ivec3(0, 0, CASCADE_COUNT),
      0,
      neighborOffsets[i]
    );
    if (neighbor.r < result.r) {
      result = neighbor;
    }
  }
  #pragma unroll_loop_end
  return result;
}

void cascade(const int cascadeIndex, out vec4 outputColor) {
  ivec3 coord = ivec3(gl_FragCoord.xy, cascadeIndex);
  vec4 current = texelFetch(inputBuffer, coord, 0);

  vec4 depthVelocity = getClosestFragment(coord);
  vec2 velocity = depthVelocity.gb * texelSize;
  vec2 prevUv = vUv - velocity;
  if (prevUv.x < 0.0 || prevUv.x > 1.0 || prevUv.y < 0.0 || prevUv.y > 1.0) {
    outputColor = current;
    return; // Rejection
  }

  vec4 history = texture(historyBuffer, vec3(prevUv, float(cascadeIndex)));
  vec4 clippedHistory = varianceClipping(inputBuffer, coord, current, history, varianceGamma);
  outputColor = mix(clippedHistory, current, temporalAlpha);
}

void main() {
  #pragma unroll_loop_start
  for (int i = 0; i < 4; ++i) {
    #if UNROLLED_LOOP_INDEX < CASCADE_COUNT
    cascade(UNROLLED_LOOP_INDEX, outputColor[i]);
    #endif // UNROLLED_LOOP_INDEX < CASCADE_COUNT
  }
  #pragma unroll_loop_end
}
`, Ot = `precision highp float;

layout(location = 0) in vec3 position;

out vec2 vUv;

void main() {
  vUv = position.xy * 0.5 + 0.5;
  gl_Position = vec4(position.xy, 1.0, 1.0);
}
`;
var Rt = Object.defineProperty, Lt = (o, e, t, n) => {
  for (var a = void 0, i = o.length - 1, s; i >= 0; i--)
    (s = o[i]) && (a = s(e, t, a) || a);
  return a && Rt(e, t, a), a;
};
class be extends X {
  constructor({
    inputBuffer: e = null,
    historyBuffer: t = null
  } = {}) {
    super({
      name: "ShadowResolveMaterial",
      glslVersion: W,
      vertexShader: Ot,
      fragmentShader: G(
        M(Pt, {
          varianceClipping: Le
        })
      ),
      uniforms: {
        inputBuffer: new r(e),
        historyBuffer: new r(t),
        texelSize: new r(new m()),
        varianceGamma: new r(1),
        // Use a very slow alpha because a single flickering pixel can be highly
        // noticeable in shadow maps. This value can be increased if temporal
        // jitter is turned off in the shadows rendering, but it will suffer
        // from spatial aliasing.
        temporalAlpha: new r(0.01)
      },
      defines: {}
    }), this.cascadeCount = l.shadow.cascadeCount;
  }
  setSize(e, t) {
    this.uniforms.texelSize.value.set(1 / e, 1 / t);
  }
}
Lt([
  O("CASCADE_COUNT", { min: 1, max: 4 })
], be.prototype, "cascadeCount");
function j(o) {
  const e = new Ve(1, 1, 1, {
    depthBuffer: !1,
    stencilBuffer: !1
  });
  return e.texture.type = we, e.texture.minFilter = z, e.texture.magFilter = z, e.texture.name = o, e;
}
class It extends Ne {
  constructor({
    parameterUniforms: e,
    layerUniforms: t,
    atmosphereUniforms: n,
    ...a
  }) {
    super("ShadowPass", a), this.width = 0, this.height = 0, this.currentMaterial = new _({
      parameterUniforms: e,
      layerUniforms: t,
      atmosphereUniforms: n
    }), this.currentPass = new ye(this.currentMaterial), this.resolveMaterial = new be(), this.resolvePass = new ye(this.resolveMaterial), this.initRenderTargets();
  }
  initialize(e, t, n) {
    this.currentPass.initialize(e, t, n), this.resolvePass.initialize(e, t, n);
  }
  initRenderTargets() {
    var i, s, c;
    (i = this.currentRenderTarget) == null || i.dispose(), (s = this.resolveRenderTarget) == null || s.dispose(), (c = this.historyRenderTarget) == null || c.dispose();
    const e = j("Shadow"), t = this.temporalPass ? j("Shadow.A") : null, n = this.temporalPass ? j("Shadow.B") : null;
    this.currentRenderTarget = e, this.resolveRenderTarget = t, this.historyRenderTarget = n;
    const a = this.resolveMaterial.uniforms;
    a.inputBuffer.value = e.texture, a.historyBuffer.value = (n == null ? void 0 : n.texture) ?? null;
  }
  copyShadow() {
    const e = this.shadow, t = this.currentMaterial.uniforms;
    for (let n = 0; n < e.cascadeCount; ++n) {
      const a = e.cascades[n];
      t.inverseShadowMatrices.value[n].copy(a.inverseMatrix);
    }
  }
  copyReprojection() {
    const e = this.shadow, t = this.currentMaterial.uniforms;
    for (let n = 0; n < e.cascadeCount; ++n) {
      const a = e.cascades[n];
      t.reprojectionMatrices.value[n].copy(a.matrix);
    }
  }
  swapBuffers() {
    A(this.historyRenderTarget != null), A(this.resolveRenderTarget != null);
    const e = this.historyRenderTarget, t = this.resolveRenderTarget;
    this.resolveRenderTarget = e, this.historyRenderTarget = t, this.resolveMaterial.uniforms.historyBuffer.value = t.texture;
  }
  update(e, t, n) {
    this.currentMaterial.uniforms.frame.value = t, this.copyShadow(), this.currentPass.render(e, null, this.currentRenderTarget), this.temporalPass && (A(this.resolveRenderTarget != null), this.resolvePass.render(e, null, this.resolveRenderTarget), this.copyReprojection(), this.swapBuffers());
  }
  setSize(e, t, n = this.shadow.cascadeCount) {
    var a, i;
    this.width = e, this.height = t, this.currentMaterial.cascadeCount = n, this.resolveMaterial.cascadeCount = n, this.currentMaterial.setSize(e, t), this.resolveMaterial.setSize(e, t), this.currentRenderTarget.setSize(
      e,
      t,
      this.temporalPass ? n * 2 : n
      // For depth velocity
    ), (a = this.resolveRenderTarget) == null || a.setSize(e, t, n), (i = this.historyRenderTarget) == null || i.setSize(e, t, n);
  }
  get outputBuffer() {
    return this.temporalPass ? (A(this.historyRenderTarget != null), this.historyRenderTarget.texture) : this.currentRenderTarget.texture;
  }
  get temporalPass() {
    return this.currentMaterial.temporalPass;
  }
  set temporalPass(e) {
    e !== this.temporalPass && (this.currentMaterial.temporalPass = e, this.initRenderTargets(), this.setSize(this.width, this.height));
  }
}
function Nt(o) {
  return {
    // Participating medium
    scatteringCoefficient: new r(1),
    absorptionCoefficient: new r(0),
    // Weather and shape
    coverage: new r(0.3),
    localWeatherTexture: new r(o.localWeatherTexture),
    localWeatherRepeat: new r(o.localWeatherRepeat),
    localWeatherOffset: new r(o.localWeatherOffset),
    shapeTexture: new r(o.shapeTexture),
    shapeRepeat: new r(o.shapeRepeat),
    shapeOffset: new r(o.shapeOffset),
    shapeDetailTexture: new r(o.shapeDetailTexture),
    shapeDetailRepeat: new r(o.shapeDetailRepeat),
    shapeDetailOffset: new r(o.shapeDetailOffset),
    turbulenceTexture: new r(o.turbulenceTexture),
    turbulenceRepeat: new r(o.turbulenceRepeat),
    turbulenceDisplacement: new r(350)
  };
}
function bt() {
  return {
    minLayerHeights: new r(new x()),
    maxLayerHeights: new r(new x()),
    minIntervalHeights: new r(new f()),
    maxIntervalHeights: new r(new f()),
    densityScales: new r(new x()),
    shapeAmounts: new r(new x()),
    shapeDetailAmounts: new r(new x()),
    weatherExponents: new r(new x()),
    shapeAlteringBiases: new r(new x()),
    coverageFilterWidths: new r(new x()),
    minHeight: new r(0),
    maxHeight: new r(0),
    shadowTopHeight: new r(0),
    shadowBottomHeight: new r(0),
    shadowLayerMask: new r(new x()),
    densityProfile: new r({
      expTerms: new x(),
      exponents: new x(),
      linearTerms: new x(),
      constantTerms: new x()
    })
  };
}
const Y = [0, 0, 0, 0];
function Mt(o, e) {
  e.packValues("altitude", o.minLayerHeights.value), e.packSums("altitude", "height", o.maxLayerHeights.value), e.packIntervalHeights(
    o.minIntervalHeights.value,
    o.maxIntervalHeights.value
  ), e.packValues("densityScale", o.densityScales.value), e.packValues("shapeAmount", o.shapeAmounts.value), e.packValues("shapeDetailAmount", o.shapeDetailAmounts.value), e.packValues("weatherExponent", o.weatherExponents.value), e.packValues("shapeAlteringBias", o.shapeAlteringBiases.value), e.packValues("coverageFilterWidth", o.coverageFilterWidths.value);
  const t = o.densityProfile.value;
  e.packDensityProfiles("expTerm", t.expTerms), e.packDensityProfiles("exponent", t.exponents), e.packDensityProfiles("linearTerm", t.linearTerms), e.packDensityProfiles("constantTerm", t.constantTerms);
  let n = 1 / 0, a = 0, i = 1 / 0, s = 0;
  Y.fill(0);
  for (let c = 0; c < e.length; ++c) {
    const { altitude: h, height: u, shadow: d } = e[c], p = h + u;
    u > 0 && (h < n && (n = h), d && h < i && (i = h), p > a && (a = p), d && p > s && (s = p)), Y[c] = d ? 1 : 0;
  }
  n !== 1 / 0 ? (o.minHeight.value = n, o.maxHeight.value = a) : (A(a === 0), o.minHeight.value = 0), i !== 1 / 0 ? (o.shadowBottomHeight.value = i, o.shadowTopHeight.value = s) : (A(s === 0), o.shadowBottomHeight.value = 0), o.shadowLayerMask.value.fromArray(Y);
}
function Ut(o, e) {
  return {
    bottomRadius: new r(o.bottomRadius),
    topRadius: new r(o.topRadius),
    ellipsoidCenter: new r(e.ellipsoidCenter),
    ellipsoidMatrix: new r(e.ellipsoidMatrix),
    inverseEllipsoidMatrix: new r(e.inverseEllipsoidMatrix),
    altitudeCorrection: new r(e.altitudeCorrection),
    sunDirection: new r(e.sunDirection)
  };
}
const Ht = `uniform sampler2D cloudsBuffer;

void mainImage(const vec4 inputColor, const vec2 uv, out vec4 outputColor) {
  #ifdef SKIP_RENDERING
  outputColor = inputColor;
  #else // SKIP_RENDERING
  vec4 clouds = texture(cloudsBuffer, uv);
  outputColor.rgb = inputColor.rgb * (1.0 - clouds.a) + clouds.rgb;
  outputColor.a = inputColor.a * (1.0 - clouds.a) + clouds.a;
  #endif // SKIP_RENDERING
}
`;
var Ft = Object.defineProperty, zt = (o, e, t, n) => {
  for (var a = void 0, i = o.length - 1, s; i >= 0; i--)
    (s = o[i]) && (a = s(e, t, a) || a);
  return a && Ft(e, t, a), a;
};
const I = /* @__PURE__ */ new f(), Wt = /* @__PURE__ */ new m(), Gt = [
  "maxIterationCount",
  "minStepSize",
  "maxStepSize",
  "maxRayDistance",
  "perspectiveStepScale",
  "minDensity",
  "minExtinction",
  "minTransmittance",
  "maxIterationCountToSun",
  "maxIterationCountToGround",
  "minSecondaryStepSize",
  "secondaryStepScale",
  "maxShadowFilterRadius",
  "maxShadowLengthIterationCount",
  "minShadowLengthStepSize",
  "maxShadowLengthRayDistance",
  "hazeDensityScale",
  "hazeExponent"
], Bt = [
  "multiScatteringOctaves",
  "accurateSunSkyIrradiance",
  "accuratePhaseFunction"
], Vt = [
  "maxIterationCount",
  "minStepSize",
  "maxStepSize",
  "minDensity",
  "minExtinction",
  "minTransmittance",
  "opticalDepthTailScale"
], kt = [
  "temporalJitter"
], jt = [
  "temporalPass"
], Yt = [
  "cascadeCount",
  "mapSize",
  "maxFar",
  "farScale",
  "splitMode",
  "splitLambda"
], D = {
  type: "change"
}, Zt = {
  resolutionScale: l.resolutionScale,
  width: q.AUTO_SIZE,
  height: q.AUTO_SIZE
};
class qt extends Fe {
  constructor(e = new xe(), t, n = Ce.DEFAULT) {
    var d, p, g, S;
    super("CloudsEffect", Ht, {
      attributes: ze.DEPTH,
      uniforms: /* @__PURE__ */ new Map([["cloudsBuffer", new r(null)]])
    }), this.camera = e, this.atmosphere = n, this.cloudLayers = K.DEFAULT.clone(), this.correctAltitude = !0, this.localWeatherRepeat = new m().setScalar(100), this.localWeatherOffset = new m(), this.shapeRepeat = new f().setScalar(3e-4), this.shapeOffset = new f(), this.shapeDetailRepeat = new f().setScalar(6e-3), this.shapeDetailOffset = new f(), this.turbulenceRepeat = new m().setScalar(20), this.ellipsoidCenter = new f(), this.ellipsoidMatrix = new v(), this.inverseEllipsoidMatrix = new v(), this.altitudeCorrection = new f(), this.sunDirection = new f(), this.localWeatherVelocity = new m(), this.shapeVelocity = new f(), this.shapeDetailVelocity = new f(), this._atmosphereOverlay = null, this._atmosphereShadow = null, this._atmosphereShadowLength = null, this.events = new ke(), this.frame = 0, this.shadowCascadeCount = 0, this.shadowMapSize = new m(), this.onResolutionChange = () => {
      this.setSize(this.resolution.baseWidth, this.resolution.baseHeight);
    }, this.skipRendering = !0;
    const {
      resolutionScale: a,
      width: i,
      height: s,
      resolutionX: c = i,
      resolutionY: h = s
    } = {
      ...Zt,
      ...t
    };
    this.shadowMaps = new ht({
      cascadeCount: l.shadow.cascadeCount,
      mapSize: l.shadow.mapSize,
      splitLambda: 0.6
    }), this.parameterUniforms = Nt({
      localWeatherTexture: ((d = this.proceduralLocalWeather) == null ? void 0 : d.texture) ?? null,
      localWeatherRepeat: this.localWeatherRepeat,
      localWeatherOffset: this.localWeatherOffset,
      shapeTexture: ((p = this.proceduralShape) == null ? void 0 : p.texture) ?? null,
      shapeRepeat: this.shapeRepeat,
      shapeOffset: this.shapeOffset,
      shapeDetailTexture: ((g = this.proceduralShapeDetail) == null ? void 0 : g.texture) ?? null,
      shapeDetailRepeat: this.shapeDetailRepeat,
      shapeDetailOffset: this.shapeDetailOffset,
      turbulenceTexture: ((S = this.proceduralTurbulence) == null ? void 0 : S.texture) ?? null,
      turbulenceRepeat: this.turbulenceRepeat
    }), this.layerUniforms = bt(), this.atmosphereUniforms = Ut(n, {
      ellipsoidCenter: this.ellipsoidCenter,
      ellipsoidMatrix: this.ellipsoidMatrix,
      inverseEllipsoidMatrix: this.inverseEllipsoidMatrix,
      altitudeCorrection: this.altitudeCorrection,
      sunDirection: this.sunDirection
    });
    const u = {
      shadow: this.shadowMaps,
      parameterUniforms: this.parameterUniforms,
      layerUniforms: this.layerUniforms,
      atmosphereUniforms: this.atmosphereUniforms
    };
    this.shadowPass = new It(u), this.shadowPass.mainCamera = e, this.cloudsPass = new Ct(u, n), this.cloudsPass.mainCamera = e, this.clouds = he(
      ue(
        {},
        this.cloudsPass.currentMaterial,
        Gt
      ),
      this.cloudsPass.currentMaterial,
      Bt
    ), this.shadow = he(
      ue(
        {},
        this.shadowPass.currentMaterial,
        Vt
      ),
      this.shadowPass.currentMaterial,
      kt,
      this.shadowPass,
      jt,
      this.shadowMaps,
      Yt
    ), this.resolution = new q(
      this,
      c,
      h,
      a
    ), this.resolution.addEventListener("change", this.onResolutionChange);
  }
  get mainCamera() {
    return this.camera;
  }
  set mainCamera(e) {
    this.camera = e, this.shadowPass.mainCamera = e, this.cloudsPass.mainCamera = e;
  }
  initialize(e, t, n) {
    this.shadowPass.initialize(e, t, n), this.cloudsPass.initialize(e, t, n);
  }
  updateSharedUniforms(e) {
    Mt(this.layerUniforms, this.cloudLayers);
    const { parameterUniforms: t } = this;
    t.localWeatherOffset.value.add(
      Wt.copy(this.localWeatherVelocity).multiplyScalar(e)
    ), t.shapeOffset.value.add(
      I.copy(this.shapeVelocity).multiplyScalar(e)
    ), t.shapeDetailOffset.value.add(
      I.copy(this.shapeDetailVelocity).multiplyScalar(e)
    );
    const n = this.inverseEllipsoidMatrix.copy(this.ellipsoidMatrix).invert(), a = this.camera.getWorldPosition(I).applyMatrix4(n).sub(this.ellipsoidCenter), i = this.altitudeCorrection;
    this.correctAltitude ? Ye(
      a,
      this.atmosphere.bottomRadius,
      this.ellipsoid,
      i,
      !1
    ) : i.setScalar(0);
    const s = this.ellipsoid.getSurfaceNormal(
      a,
      I
    ), c = this.sunDirection.dot(s), h = Te(1e6, 1e3, c);
    this.shadowMaps.update(
      this.camera,
      // The sun direction must be rotated with the ellipsoid to ensure the
      // frusta are constructed correctly. Note this affects the transformation
      // in the shadow shader.
      I.copy(this.sunDirection).applyMatrix4(this.ellipsoidMatrix),
      h
    );
  }
  updateWeatherTextureChannels() {
    const e = this.cloudLayers.localWeatherChannels;
    this.cloudsPass.currentMaterial.localWeatherChannels = e, this.shadowPass.currentMaterial.localWeatherChannels = e;
  }
  updateAtmosphereComposition() {
    const { shadowMaps: e, shadowPass: t, cloudsPass: n } = this, a = t.currentMaterial.uniforms, i = n.currentMaterial.uniforms, s = this._atmosphereOverlay, c = Object.assign(this._atmosphereOverlay ?? {}, {
      map: n.outputBuffer
    });
    s !== c && (this._atmosphereOverlay = c, D.target = this, D.property = "atmosphereOverlay", this.events.dispatchEvent(D));
    const h = this._atmosphereShadow, u = Object.assign(this._atmosphereShadow ?? {}, {
      map: t.outputBuffer,
      mapSize: e.mapSize,
      cascadeCount: e.cascadeCount,
      intervals: i.shadowIntervals.value,
      matrices: i.shadowMatrices.value,
      inverseMatrices: a.inverseShadowMatrices.value,
      far: e.far,
      topHeight: i.shadowTopHeight.value
    });
    h !== u && (this._atmosphereShadow = u, D.target = this, D.property = "atmosphereShadow", this.events.dispatchEvent(D));
    const d = this._atmosphereShadowLength, p = n.shadowLengthBuffer != null ? Object.assign(this._atmosphereShadowLength ?? {}, {
      map: n.shadowLengthBuffer
    }) : null;
    d !== p && (this._atmosphereShadowLength = p, D.target = this, D.property = "atmosphereShadowLength", this.events.dispatchEvent(D));
  }
  update(e, t, n = 0) {
    var c, h, u, d;
    const { shadowMaps: a, shadowPass: i, cloudsPass: s } = this;
    if (a.cascadeCount !== this.shadowCascadeCount || !a.mapSize.equals(this.shadowMapSize)) {
      const { width: p, height: g } = a.mapSize, S = a.cascadeCount;
      this.shadowMapSize.set(p, g), this.shadowCascadeCount = S, i.setSize(p, g, S), s.setShadowSize(p, g, S);
    }
    (c = this.proceduralLocalWeather) == null || c.render(e, n), (h = this.proceduralShape) == null || h.render(e, n), (u = this.proceduralShapeDetail) == null || u.render(e, n), (d = this.proceduralTurbulence) == null || d.render(e, n), ++this.frame, this.updateSharedUniforms(n), this.updateWeatherTextureChannels(), i.update(e, this.frame, n), s.shadowBuffer = i.outputBuffer, s.update(e, this.frame, n), this.updateAtmosphereComposition(), this.uniforms.get("cloudsBuffer").value = this.cloudsPass.outputBuffer;
  }
  setSize(e, t) {
    const { resolution: n } = this;
    n.setBaseSize(e, t);
    const { width: a, height: i } = n;
    this.cloudsPass.setSize(a, i);
  }
  setDepthTexture(e, t) {
    this.shadowPass.setDepthTexture(e, t), this.cloudsPass.setDepthTexture(e, t);
  }
  // eslint-disable-next-line accessor-pairs
  set qualityPreset(e) {
    const { clouds: t, shadow: n, ...a } = dt[e];
    Object.assign(this, a), Object.assign(this.clouds, t), Object.assign(this.shadow, n);
  }
  // Textures
  get localWeatherTexture() {
    return this.proceduralLocalWeather ?? this.parameterUniforms.localWeatherTexture.value;
  }
  set localWeatherTexture(e) {
    e instanceof ce || e == null ? (this.proceduralLocalWeather = void 0, this.parameterUniforms.localWeatherTexture.value = e) : (this.proceduralLocalWeather = e, this.parameterUniforms.localWeatherTexture.value = e.texture);
  }
  get shapeTexture() {
    return this.proceduralShape ?? this.parameterUniforms.shapeTexture.value;
  }
  set shapeTexture(e) {
    e instanceof le || e == null ? (this.proceduralShape = void 0, this.parameterUniforms.shapeTexture.value = e) : (this.proceduralShape = e, this.parameterUniforms.shapeTexture.value = e.texture);
  }
  get shapeDetailTexture() {
    return this.proceduralShapeDetail ?? this.parameterUniforms.shapeDetailTexture.value;
  }
  set shapeDetailTexture(e) {
    e instanceof le || e == null ? (this.proceduralShapeDetail = void 0, this.parameterUniforms.shapeDetailTexture.value = e) : (this.proceduralShapeDetail = e, this.parameterUniforms.shapeDetailTexture.value = e.texture);
  }
  get turbulenceTexture() {
    return this.proceduralTurbulence ?? this.parameterUniforms.turbulenceTexture.value;
  }
  set turbulenceTexture(e) {
    e instanceof ce || e == null ? (this.proceduralTurbulence = void 0, this.parameterUniforms.turbulenceTexture.value = e) : (this.proceduralTurbulence = e, this.parameterUniforms.turbulenceTexture.value = e.texture);
  }
  get stbnTexture() {
    return this.cloudsPass.currentMaterial.uniforms.stbnTexture.value;
  }
  set stbnTexture(e) {
    this.cloudsPass.currentMaterial.uniforms.stbnTexture.value = e, this.shadowPass.currentMaterial.uniforms.stbnTexture.value = e;
  }
  // Rendering controls
  get resolutionScale() {
    return this.resolution.scale;
  }
  set resolutionScale(e) {
    this.resolution.scale = e;
  }
  get temporalUpscale() {
    return this.cloudsPass.temporalUpscale;
  }
  set temporalUpscale(e) {
    this.cloudsPass.temporalUpscale = e;
  }
  get lightShafts() {
    return this.cloudsPass.lightShafts;
  }
  set lightShafts(e) {
    this.cloudsPass.lightShafts = e;
  }
  get shapeDetail() {
    return this.cloudsPass.currentMaterial.shapeDetail;
  }
  set shapeDetail(e) {
    this.cloudsPass.currentMaterial.shapeDetail = e, this.shadowPass.currentMaterial.shapeDetail = e;
  }
  get turbulence() {
    return this.cloudsPass.currentMaterial.turbulence;
  }
  set turbulence(e) {
    this.cloudsPass.currentMaterial.turbulence = e, this.shadowPass.currentMaterial.turbulence = e;
  }
  get haze() {
    return this.cloudsPass.currentMaterial.haze;
  }
  set haze(e) {
    this.cloudsPass.currentMaterial.haze = e;
  }
  // Cloud parameter primitives
  get scatteringCoefficient() {
    return this.parameterUniforms.scatteringCoefficient.value;
  }
  set scatteringCoefficient(e) {
    this.parameterUniforms.scatteringCoefficient.value = e;
  }
  get absorptionCoefficient() {
    return this.parameterUniforms.absorptionCoefficient.value;
  }
  set absorptionCoefficient(e) {
    this.parameterUniforms.absorptionCoefficient.value = e;
  }
  get coverage() {
    return this.parameterUniforms.coverage.value;
  }
  set coverage(e) {
    this.parameterUniforms.coverage.value = e;
  }
  get turbulenceDisplacement() {
    return this.parameterUniforms.turbulenceDisplacement.value;
  }
  set turbulenceDisplacement(e) {
    this.parameterUniforms.turbulenceDisplacement.value = e;
  }
  // Scattering parameters
  get scatterAnisotropy1() {
    return this.cloudsPass.currentMaterial.scatterAnisotropy1;
  }
  set scatterAnisotropy1(e) {
    this.cloudsPass.currentMaterial.scatterAnisotropy1 = e;
  }
  get scatterAnisotropy2() {
    return this.cloudsPass.currentMaterial.scatterAnisotropy2;
  }
  set scatterAnisotropy2(e) {
    this.cloudsPass.currentMaterial.scatterAnisotropy2 = e;
  }
  get scatterAnisotropyMix() {
    return this.cloudsPass.currentMaterial.scatterAnisotropyMix;
  }
  set scatterAnisotropyMix(e) {
    this.cloudsPass.currentMaterial.scatterAnisotropyMix = e;
  }
  get skyIrradianceScale() {
    return this.cloudsPass.currentMaterial.uniforms.skyIrradianceScale.value;
  }
  set skyIrradianceScale(e) {
    this.cloudsPass.currentMaterial.uniforms.skyIrradianceScale.value = e;
  }
  get groundIrradianceScale() {
    return this.cloudsPass.currentMaterial.uniforms.groundIrradianceScale.value;
  }
  set groundIrradianceScale(e) {
    this.cloudsPass.currentMaterial.uniforms.groundIrradianceScale.value = e;
  }
  get powderScale() {
    return this.cloudsPass.currentMaterial.uniforms.powderScale.value;
  }
  set powderScale(e) {
    this.cloudsPass.currentMaterial.uniforms.powderScale.value = e;
  }
  get powderExponent() {
    return this.cloudsPass.currentMaterial.uniforms.powderExponent.value;
  }
  set powderExponent(e) {
    this.cloudsPass.currentMaterial.uniforms.powderExponent.value = e;
  }
  // Atmosphere composition
  get atmosphereOverlay() {
    return this._atmosphereOverlay;
  }
  get atmosphereShadow() {
    return this._atmosphereShadow;
  }
  get atmosphereShadowLength() {
    return this._atmosphereShadowLength;
  }
  // Atmosphere parameters
  get irradianceTexture() {
    return this.cloudsPass.currentMaterial.irradianceTexture;
  }
  set irradianceTexture(e) {
    this.cloudsPass.currentMaterial.irradianceTexture = e;
  }
  get scatteringTexture() {
    return this.cloudsPass.currentMaterial.scatteringTexture;
  }
  set scatteringTexture(e) {
    this.cloudsPass.currentMaterial.scatteringTexture = e;
  }
  get transmittanceTexture() {
    return this.cloudsPass.currentMaterial.transmittanceTexture;
  }
  set transmittanceTexture(e) {
    this.cloudsPass.currentMaterial.transmittanceTexture = e;
  }
  get ellipsoid() {
    return this.cloudsPass.currentMaterial.ellipsoid;
  }
  set ellipsoid(e) {
    this.cloudsPass.currentMaterial.ellipsoid = e;
  }
  get photometric() {
    return this.cloudsPass.currentMaterial.photometric;
  }
  set photometric(e) {
    this.cloudsPass.currentMaterial.photometric = e;
  }
  get sunAngularRadius() {
    return this.cloudsPass.currentMaterial.sunAngularRadius;
  }
  set sunAngularRadius(e) {
    this.cloudsPass.currentMaterial.sunAngularRadius = e;
  }
}
zt([
  C("SKIP_RENDERING")
], qt.prototype, "skipRendering");
const tn = 128, nn = 32, V = "45a1c6c1bb9fd38b3680fd120795ff4c32df68ff", an = `https://media.githubusercontent.com/media/takram-design-engineering/three-geospatial/${V}/packages/clouds/assets/local_weather.png`, rn = `https://media.githubusercontent.com/media/takram-design-engineering/three-geospatial/${V}/packages/clouds/assets/shape.bin`, on = `https://media.githubusercontent.com/media/takram-design-engineering/three-geospatial/${V}/packages/clouds/assets/shape_detail.bin`, sn = `https://media.githubusercontent.com/media/takram-design-engineering/three-geospatial/${V}/packages/clouds/assets/turbulence.png`;
export {
  tn as C,
  an as D,
  nn as a,
  T as b,
  K as c,
  Zt as d,
  qt as e,
  rn as f,
  on as g,
  sn as h,
  B as i
};
//# sourceMappingURL=shared.js.map
