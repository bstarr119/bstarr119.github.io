import { jsx as x, jsxs as k, Fragment as B } from "react/jsx-runtime";
import { useFrame as W, useThree as j } from "@react-three/fiber";
import { EffectComposerContext as X } from "@react-three/postprocessing";
import { createContext as Z, useState as L, useLayoutEffect as E, forwardRef as F, useContext as C, useMemo as $, useEffect as h, useCallback as q } from "react";
import { TextureLoader as G, LinearMipMapLinearFilter as J, LinearFilter as D, RepeatWrapping as f, NoColorSpace as _, RedFormat as K } from "three";
import { AtmosphereContext as Q, separateProps as V } from "@takram/three-atmosphere/r3f";
import { DEFAULT_STBN_URL as Y, createData3DTextureLoaderClass as z, parseUint8Array as ee, STBNLoader as te } from "@takram/three-geospatial";
import { c as w, b as A, d as re, e as oe, D as ae, f as se, g as ne, h as le, a as ce, C as ue } from "./shared.js";
const v = /* @__PURE__ */ Z(null), ie = ({
  layers: e,
  disableDefault: r = !1,
  children: c
}) => {
  const [a, u] = L();
  return E(() => {
    e.set(
      r ? Array(4).fill(A.DEFAULT) : w.DEFAULT
    ), u({
      layers: e,
      indexPool: [0, 1, 2, 3],
      disableDefault: r
    });
  }, [e, r]), a != null && /* @__PURE__ */ x(v.Provider, { value: a, children: c });
};
function U(e, r) {
  const [c, a] = L(typeof e != "string" ? e : null);
  return h(() => {
    if (typeof e == "string") {
      const u = new G();
      (async () => {
        const t = await u.loadAsync(e);
        t.minFilter = J, t.magFilter = D, t.wrapS = f, t.wrapT = f, t.colorSpace = _, t.needsUpdate = !0, r.initTexture(t), a(t);
      })().catch((t) => {
        console.error(t);
      });
    } else
      a(e);
  }, [e, r]), c;
}
function g(e, r) {
  const [c, a] = L(typeof e != "string" ? e : null);
  return h(() => {
    if (typeof e == "string") {
      const u = z(ee, {
        width: r,
        height: r,
        depth: r,
        format: K,
        minFilter: D,
        magFilter: D,
        wrapS: f,
        wrapT: f,
        wrapR: f,
        colorSpace: _
      }), t = new u();
      (async () => {
        a(await t.loadAsync(e));
      })().catch((i) => {
        console.error(i);
      });
    } else
      a(e);
  }, [e, r]), c;
}
function he(e) {
  const [r, c] = L(typeof e != "string" ? e : null);
  return h(() => {
    if (typeof e == "string") {
      const a = new te();
      (async () => {
        c(await a.loadAsync(e));
      })().catch((u) => {
        console.error(u);
      });
    } else
      c(e);
  }, [e]), r;
}
const Ee = /* @__PURE__ */ F(
  function({
    disableDefaultLayers: r = !1,
    localWeatherTexture: c = ae,
    shapeTexture: a = se,
    shapeDetailTexture: u = ne,
    turbulenceTexture: t = le,
    stbnTexture: i = Y,
    children: p,
    ...n
  }, d) {
    const { textures: l, transientStates: o, ...m } = C(Q), [b, R] = V({
      ...re,
      ...m,
      ...l,
      ...n
    }), s = $(() => new oe(), []);
    h(() => () => {
      s.dispose();
    }, [s]), W(() => {
      o != null && (s.sunDirection.copy(o.sunDirection), s.ellipsoidCenter.copy(o.ellipsoidCenter), s.ellipsoidMatrix.copy(o.ellipsoidMatrix));
    }), h(() => {
      if (o != null)
        return o.overlay = s.atmosphereOverlay, o.shadow = s.atmosphereShadow, o.shadowLength = s.atmosphereShadowLength, () => {
          o.overlay = null, o.shadow = null, o.shadowLength = null;
        };
    }, [s, o]);
    const T = q(
      (y) => {
        if (o != null)
          switch (y.property) {
            case "atmosphereOverlay":
              o.overlay = s.atmosphereOverlay;
              break;
            case "atmosphereShadow":
              o.shadow = s.atmosphereShadow;
              break;
            case "atmosphereShadowLength":
              o.shadowLength = s.atmosphereShadowLength;
              break;
          }
      },
      [s, o]
    );
    h(() => (s.events.addEventListener("change", T), () => {
      s.events.removeEventListener("change", T);
    }), [s, T]);
    const S = j(({ gl: y }) => y), O = U(c, S), P = g(
      a,
      ue
    ), I = g(
      u,
      ce
    ), H = U(t, S), M = he(i), { camera: N } = C(X);
    return /* @__PURE__ */ k(B, { children: [
      /* @__PURE__ */ x(
        "primitive",
        {
          ref: d,
          object: s,
          mainCamera: N,
          ...b,
          localWeatherTexture: O,
          shapeTexture: P,
          shapeDetailTexture: I,
          turbulenceTexture: H,
          stbnTexture: M,
          ...R
        }
      ),
      /* @__PURE__ */ x(
        ie,
        {
          layers: s.cloudLayers,
          disableDefault: r,
          children: p
        }
      )
    ] });
  }
), Ce = F(
  function({ index: r, ...c }, a) {
    const u = C(v);
    if (u == null)
      throw new Error(
        "CloudLayer can only be used within the Clouds component!"
      );
    const { layers: t, indexPool: i, disableDefault: p } = u, [n, d] = L();
    if (E(() => {
      if (r != null) {
        const l = i.indexOf(r);
        if (l !== -1)
          return i.splice(l, 1), d(r), () => {
            i.push(r), d(void 0);
          };
      } else {
        const l = i.sort((o, m) => o - m).shift();
        if (l != null)
          return d(l), () => {
            i.push(l), d(void 0);
          };
      }
    }, [r, t, i]), E(() => {
      if (n == null)
        return;
      const l = t[n];
      return () => {
        l.copy(
          p ? A.DEFAULT : w.DEFAULT[n]
        );
      };
    }, [t, n, p]), h(() => {
      n != null && (typeof a == "function" ? a(t[n]) : a != null && (a.current = t[n]));
    }, [a, t, n]), n != null) {
      const l = t[n];
      l.copy(
        p ? A.DEFAULT : w.DEFAULT[n]
      ), l.set(c);
    }
    return null;
  }
);
export {
  Ce as CloudLayer,
  Ee as Clouds
};
//# sourceMappingURL=r3f.js.map
