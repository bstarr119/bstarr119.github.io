import { BlendFunction as Kt, Effect as Jt, EffectAttribute as Qt } from "postprocessing";
import { Vector3 as O, Camera as er, Uniform as C, Vector2 as Ke, Matrix4 as t0, RawShaderMaterial as nr, HalfFloatType as oe, Color as it, REVISION as tr, DataTextureLoader as rr, FloatType as De, RGBAFormat as ir, RedFormat as ar, LinearFilter as Ve, DataUtils as Zn, Loader as or, LightProbe as sr, GLSL3 as at, BufferGeometry as cr, InterleavedBuffer as Wn, InterleavedBufferAttribute as an, Sphere as ur, DirectionalLight as lr } from "three";
import { radians as dr, Ellipsoid as Ue, define as E0, defineInt as vr, unrollLoops as hr, resolveIncludes as Se, Geodetic as fr, saturate as pr, remap as mr, isTypedArray as Sr, Float16Array as ot, clamp as Xn, EXR3DLoader as Er, createDataTextureLoader as Vn, parseFloat16Array as on, createData3DTextureLoader as _r } from "@takram/three-geospatial";
import { vogelDisk as gr, interleavedGradientNoise as wr, cascadedShadowMaps as Tr, raySphereIntersection as st, transform as Rr, math as Ar, packing as Cr, depth as yr } from "@takram/three-geospatial/shaders";
import { _ as xn, a as Ee } from "./shared2.js";
const Ir = [
  "solarIrradiance",
  "sunAngularRadius",
  "bottomRadius",
  "topRadius",
  "rayleighScattering",
  "mieScattering",
  "miePhaseFunctionG",
  "muSMin",
  "skyRadianceToLuminance",
  "sunRadianceToLuminance",
  "luminousEfficiency"
];
function xr(t, e) {
  if (e != null)
    for (const n of Ir) {
      const a = e[n];
      a != null && (t[n] instanceof O ? t[n].copy(a) : t[n] = a);
    }
}
const qe = class qe {
  constructor(e) {
    this.solarIrradiance = new O(1.474, 1.8504, 1.91198), this.sunAngularRadius = 4675e-6, this.bottomRadius = 636e4, this.topRadius = 642e4, this.rayleighScattering = new O(5802e-6, 0.013558, 0.0331), this.mieScattering = new O(3996e-6, 3996e-6, 3996e-6), this.miePhaseFunctionG = 0.8, this.muSMin = Math.cos(dr(120)), this.skyRadianceToLuminance = new O(114974.916437, 71305.954816, 65310.548555), this.sunRadianceToLuminance = new O(98242.786222, 69954.398112, 66475.012354), this.luminousEfficiency = new O(0.2126, 0.7152, 0.0722), this.skyRadianceToRelativeLuminance = new O(), this.sunRadianceToRelativeLuminance = new O(), xr(this, e);
    const n = this.luminousEfficiency.dot(this.skyRadianceToLuminance);
    this.skyRadianceToRelativeLuminance.copy(this.skyRadianceToLuminance).divideScalar(n), this.sunRadianceToRelativeLuminance.copy(this.sunRadianceToLuminance).divideScalar(n);
  }
};
qe.DEFAULT = /* @__PURE__ */ new qe();
let ce = qe;
const Je = 64, Qe = 16, Mn = 32, Dn = 128, Nn = 32, On = 8, Mr = On * Nn, Dr = Dn, Yn = Mn, en = 256, nn = 64, pe = 1 / 1e3, I1 = 100, ct = "82e00c5222d6cbc222af69abdf6d3f4fc9f63030", x1 = `https://media.githubusercontent.com/media/takram-design-engineering/three-geospatial/${ct}/packages/atmosphere/assets`, M1 = `https://media.githubusercontent.com/media/takram-design-engineering/three-geospatial/${ct}/packages/atmosphere/assets/stars.bin`, Nr = /* @__PURE__ */ new O();
function Un(t, e, n, a, o = !0) {
  const c = n.projectOnSurface(
    t,
    Nr
  );
  return c != null ? n.getOsculatingSphereCenter(
    // Move the center of the atmosphere's inner sphere down to intersect
    // the viewpoint when it's located underground.
    !o || c.lengthSq() < t.lengthSq() ? c : t,
    e,
    a
  ) : a.setScalar(0);
}
const Or = `precision highp sampler2DArray;

#include "core/depth"
#include "core/math"
#include "core/packing"
#include "core/transform"
#ifdef HAS_SHADOW
#include "core/raySphereIntersection"
#include "core/cascadedShadowMaps"
#include "core/interleavedGradientNoise"
#include "core/vogelDisk"
#endif // HAS_SHADOW
#include "parameters"
#include "functions"
#include "sky"

uniform sampler2D normalBuffer;

uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat4 inverseProjectionMatrix;
uniform mat4 inverseViewMatrix;
uniform float bottomRadius;
uniform vec3 ellipsoidCenter;
uniform mat4 inverseEllipsoidMatrix;
uniform vec3 sunDirection;
uniform vec3 moonDirection;
uniform float moonAngularRadius;
uniform float lunarRadianceScale;
uniform float irradianceScale;
uniform float idealSphereAlpha;

#ifdef HAS_OVERLAY
uniform sampler2D overlayBuffer;
#endif // HAS_OVERLAY

#ifdef HAS_SHADOW
uniform sampler2DArray shadowBuffer;
uniform vec2 shadowIntervals[SHADOW_CASCADE_COUNT];
uniform mat4 shadowMatrices[SHADOW_CASCADE_COUNT];
uniform mat4 inverseShadowMatrices[SHADOW_CASCADE_COUNT];
uniform float shadowFar;
uniform float shadowTopHeight;
uniform float shadowRadius;
uniform sampler3D stbnTexture;
uniform int frame;
#endif // HAS_SHADOW

#ifdef HAS_SHADOW_LENGTH
uniform sampler2D shadowLengthBuffer;
#endif // HAS_SHADOW_LENGTH

varying vec3 vCameraPosition;
varying vec3 vRayDirection;
varying vec3 vEllipsoidCenter;
varying vec3 vGeometryEllipsoidCenter;
varying vec3 vEllipsoidRadiiSquared;

vec3 readNormal(const vec2 uv) {
  #ifdef OCT_ENCODED_NORMAL
  return unpackVec2ToNormal(texture(normalBuffer, uv).xy);
  #else // OCT_ENCODED_NORMAL
  return 2.0 * texture(normalBuffer, uv).xyz - 1.0;
  #endif // OCT_ENCODED_NORMAL
}

void correctGeometricError(inout vec3 positionECEF, inout vec3 normalECEF) {
  // TODO: The error is pronounced at the edge of the ellipsoid due to the
  // large difference between the sphere position and the unprojected position
  // at the current fragment. Calculating the sphere position from the fragment
  // UV may resolve this.

  // Correct way is slerp, but this will be small-angle interpolation anyways.
  vec3 sphereNormal = normalize(positionECEF / vEllipsoidRadiiSquared);
  vec3 spherePosition = u_bottom_radius * sphereNormal;
  normalECEF = mix(normalECEF, sphereNormal, idealSphereAlpha);
  positionECEF = mix(positionECEF, spherePosition, idealSphereAlpha);
}

#if defined(SUN_IRRADIANCE) || defined(SKY_IRRADIANCE)

vec3 getSunSkyIrradiance(
  const vec3 positionECEF,
  const vec3 normal,
  const vec3 inputColor,
  const float sunTransmittance
) {
  // Assume lambertian BRDF. If both SUN_IRRADIANCE and SKY_IRRADIANCE are not
  // defined, regard the inputColor as radiance at the texel.
  vec3 albedo = inputColor * irradianceScale * RECIPROCAL_PI;
  vec3 skyIrradiance;
  vec3 sunIrradiance = GetSunAndSkyIrradiance(positionECEF, normal, sunDirection, skyIrradiance);

  #ifdef HAS_SHADOW
  sunIrradiance *= sunTransmittance;
  #endif // HAS_SHADOW

  #if defined(SUN_IRRADIANCE) && defined(SKY_IRRADIANCE)
  return albedo * (sunIrradiance + skyIrradiance);
  #elif defined(SUN_IRRADIANCE)
  return albedo * sunIrradiance;
  #elif defined(SKY_IRRADIANCE)
  return albedo * skyIrradiance;
  #endif // defined(SUN_IRRADIANCE) && defined(SKY_IRRADIANCE)
}

#endif // defined(SUN_IRRADIANCE) || defined(SKY_IRRADIANCE)

#if defined(TRANSMITTANCE) || defined(INSCATTER)

void applyTransmittanceInscatter(const vec3 positionECEF, float shadowLength, inout vec3 radiance) {
  vec3 transmittance;
  vec3 inscatter = GetSkyRadianceToPoint(
    vCameraPosition - vGeometryEllipsoidCenter,
    positionECEF,
    shadowLength,
    sunDirection,
    transmittance
  );
  #ifdef TRANSMITTANCE
  radiance = radiance * transmittance;
  #endif // TRANSMITTANCE
  #ifdef INSCATTER
  radiance = radiance + inscatter;
  #endif // INSCATTER
}

#endif // defined(TRANSMITTANCE) || defined(INSCATTER)

#ifdef HAS_SHADOW

float getSTBN() {
  ivec3 size = textureSize(stbnTexture, 0);
  vec3 scale = 1.0 / vec3(size);
  return texture(stbnTexture, vec3(gl_FragCoord.xy, float(frame % size.z)) * scale).r;
}

vec2 getShadowUv(const vec3 worldPosition, const int cascadeIndex) {
  vec4 clip = shadowMatrices[cascadeIndex] * vec4(worldPosition, 1.0);
  clip /= clip.w;
  return clip.xy * 0.5 + 0.5;
}

float getDistanceToShadowTop(const vec3 positionECEF) {
  // Distance to the top of the shadows along the sun direction, which matches
  // the ray origin of BSM.
  return raySphereSecondIntersection(
    positionECEF / METER_TO_LENGTH_UNIT, // TODO: Make units consistent
    sunDirection,
    vec3(0.0),
    bottomRadius + shadowTopHeight
  );
}

float readShadowOpticalDepth(const vec2 uv, const float distanceToTop, const int cascadeIndex) {
  // r: frontDepth, g: meanExtinction, b: maxOpticalDepth, a: maxOpticalDepthTail
  vec4 shadow = texture(shadowBuffer, vec3(uv, float(cascadeIndex)));
  // Omit adding maxOpticalDepthTail to avoid pronounced aliasing. Ground
  // shadow will be attenuated by inscatter anyways.
  return min(shadow.b, shadow.g * max(0.0, distanceToTop - shadow.r));
}

float sampleShadowOpticalDepthPCF(
  const vec3 worldPosition,
  const float distanceToTop,
  const float radius,
  const int cascadeIndex
) {
  vec2 uv = getShadowUv(worldPosition, cascadeIndex);
  if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
    return 0.0;
  }

  vec2 texelSize = vec2(1.0) / vec2(textureSize(shadowBuffer, 0).xy);
  float sum = 0.0;
  vec2 offset;
  #pragma unroll_loop_start
  for (int i = 0; i < 16; ++i) {
    #if UNROLLED_LOOP_INDEX < SHADOW_SAMPLE_COUNT
    offset = vogelDisk(
      UNROLLED_LOOP_INDEX,
      SHADOW_SAMPLE_COUNT,
      interleavedGradientNoise(gl_FragCoord.xy) * PI2
    );
    sum += readShadowOpticalDepth(uv + offset * radius * texelSize, distanceToTop, cascadeIndex);
    #endif // UNROLLED_LOOP_INDEX < SHADOW_SAMPLE_COUNT
  }
  #pragma unroll_loop_end
  return sum / float(SHADOW_SAMPLE_COUNT);
}

float sampleShadowOpticalDepth(
  const vec3 worldPosition,
  const vec3 positionECEF,
  const float radius,
  const float jitter
) {
  float distanceToTop = getDistanceToShadowTop(positionECEF);
  if (distanceToTop <= 0.0) {
    return 0.0;
  }
  int cascadeIndex = getFadedCascadeIndex(
    viewMatrix,
    worldPosition,
    shadowIntervals,
    cameraNear,
    shadowFar,
    jitter
  );
  return cascadeIndex >= 0
    ? sampleShadowOpticalDepthPCF(worldPosition, distanceToTop, radius, cascadeIndex)
    : 0.0;
}

float getShadowRadius(const vec3 worldPosition) {
  vec4 clip = shadowMatrices[0] * vec4(worldPosition, 1.0);
  clip /= clip.w;

  // Offset by 1px in each direction in shadow's clip coordinates.
  vec2 shadowSize = vec2(textureSize(shadowBuffer, 0));
  vec3 offset = vec3(2.0 / shadowSize, 0.0);
  vec4 clipX = clip + offset.xzzz;
  vec4 clipY = clip + offset.zyzz;

  // Convert back to world space.
  vec4 worldX = inverseShadowMatrices[0] * clipX;
  vec4 worldY = inverseShadowMatrices[0] * clipY;

  // Project into the main camera's clip space.
  mat4 viewProjectionMatrix = projectionMatrix * viewMatrix;
  vec4 projected = viewProjectionMatrix * vec4(worldPosition, 1.0);
  vec4 projectedX = viewProjectionMatrix * worldX;
  vec4 projectedY = viewProjectionMatrix * worldY;
  projected /= projected.w;
  projectedX /= projectedX.w;
  projectedY /= projectedY.w;

  // Take the mean of pixel sizes.
  vec2 center = (projected.xy * 0.5 + 0.5) * resolution;
  vec2 offsetX = (projectedX.xy * 0.5 + 0.5) * resolution;
  vec2 offsetY = (projectedY.xy * 0.5 + 0.5) * resolution;
  float size = max(length(offsetX - center), length(offsetY - center));

  return remapClamped(size, 10.0, 50.0, 0.0, shadowRadius);
}

#endif // HAS_SHADOW

void mainImage(const vec4 inputColor, const vec2 uv, out vec4 outputColor) {
  float shadowLength = 0.0;
  #ifdef HAS_SHADOW_LENGTH
  shadowLength = texture(shadowLengthBuffer, uv).r;
  #endif // HAS_SHADOW_LENGTH

  #ifdef HAS_OVERLAY
  vec4 overlay = texture(overlayBuffer, uv);
  if (overlay.a == 1.0) {
    outputColor = overlay;
    return;
  }
  #endif // HAS_OVERLAY

  float depth = readDepth(uv);
  if (depth >= 1.0 - 1e-7) {
    #ifdef SKY
    vec3 rayDirection = normalize(vRayDirection);
    outputColor.rgb = getSkyRadiance(
      vCameraPosition - vEllipsoidCenter,
      rayDirection,
      shadowLength,
      sunDirection,
      moonDirection,
      moonAngularRadius,
      lunarRadianceScale
    );
    outputColor.a = 1.0;
    #else // SKY
    outputColor = inputColor;
    #endif // SKY

    #ifdef HAS_OVERLAY
    outputColor.rgb = outputColor.rgb * (1.0 - overlay.a) + overlay.rgb;
    #endif // HAS_OVERLAY
    return;
  }
  depth = reverseLogDepth(depth, cameraNear, cameraFar);

  // Reconstruct position and normal in world space.
  vec3 viewPosition = screenToView(
    uv,
    depth,
    getViewZ(depth),
    projectionMatrix,
    inverseProjectionMatrix
  );
  vec3 viewNormal;
  #ifdef RECONSTRUCT_NORMAL
  vec3 dx = dFdx(viewPosition);
  vec3 dy = dFdy(viewPosition);
  viewNormal = normalize(cross(dx, dy));
  #else // RECONSTRUCT_NORMAL
  viewNormal = readNormal(uv);
  #endif // RECONSTRUCT_NORMAL

  vec3 worldPosition = (inverseViewMatrix * vec4(viewPosition, 1.0)).xyz;
  vec3 worldNormal = normalize(mat3(inverseViewMatrix) * viewNormal);
  mat3 rotation = mat3(inverseEllipsoidMatrix);
  vec3 positionECEF = rotation * worldPosition * METER_TO_LENGTH_UNIT - vGeometryEllipsoidCenter;
  vec3 normalECEF = rotation * worldNormal;

  #ifdef CORRECT_GEOMETRIC_ERROR
  correctGeometricError(positionECEF, normalECEF);
  #endif // CORRECT_GEOMETRIC_ERROR

  #ifdef HAS_SHADOW
  float stbn = getSTBN();
  float radius = getShadowRadius(worldPosition);
  float opticalDepth = sampleShadowOpticalDepth(worldPosition, positionECEF, radius, stbn);
  float sunTransmittance = exp(-opticalDepth);
  #else // HAS_SHADOW
  float sunTransmittance = 1.0;
  #endif // HAS_SHADOW

  vec3 radiance;
  #if defined(SUN_IRRADIANCE) || defined(SKY_IRRADIANCE)
  radiance = getSunSkyIrradiance(positionECEF, normalECEF, inputColor.rgb, sunTransmittance);
  #else // defined(SUN_IRRADIANCE) || defined(SKY_IRRADIANCE)
  radiance = inputColor.rgb;
  #endif // defined(SUN_IRRADIANCE) || defined(SKY_IRRADIANCE)

  #if defined(TRANSMITTANCE) || defined(INSCATTER)
  applyTransmittanceInscatter(positionECEF, shadowLength, radiance);
  #endif // defined(TRANSMITTANCE) || defined(INSCATTER)

  outputColor = vec4(radiance, inputColor.a);

  #ifdef HAS_OVERLAY
  outputColor.rgb = outputColor.rgb * (1.0 - overlay.a) + overlay.rgb;
  #endif // HAS_OVERLAY
}
`, Ur = `uniform mat4 inverseViewMatrix;
uniform mat4 inverseProjectionMatrix;
uniform vec3 cameraPosition;
uniform vec3 ellipsoidCenter;
uniform mat4 inverseEllipsoidMatrix;
uniform vec3 altitudeCorrection;
uniform vec3 ellipsoidRadii;
uniform float idealSphereAlpha;

varying vec3 vCameraPosition;
varying vec3 vRayDirection;
varying vec3 vEllipsoidCenter;
varying vec3 vGeometryEllipsoidCenter;
varying vec3 vEllipsoidRadiiSquared;

void getCameraRay(out vec3 origin, out vec3 direction) {
  bool isPerspective = inverseProjectionMatrix[2][3] != 0.0; // 4th entry in the 3rd column

  if (isPerspective) {
    // Calculate the camera ray for a perspective camera.
    vec4 viewPosition = inverseProjectionMatrix * vec4(position, 1.0);
    vec4 worldDirection = inverseViewMatrix * vec4(viewPosition.xyz, 0.0);
    origin = cameraPosition;
    direction = worldDirection.xyz;
  } else {
    // Unprojected points to calculate direction.
    vec4 nearPoint = inverseProjectionMatrix * vec4(position.xy, -1.0, 1.0);
    vec4 farPoint = inverseProjectionMatrix * vec4(position.xy, -0.9, 1.0);
    nearPoint /= nearPoint.w;
    farPoint /= farPoint.w;

    // Calculate world values.
    vec4 worldDirection = inverseViewMatrix * vec4(farPoint.xyz - nearPoint.xyz, 0.0);
    vec4 worldOrigin = inverseViewMatrix * nearPoint;

    // Outputs
    direction = worldDirection.xyz;
    origin = worldOrigin.xyz;
  }
}

void mainSupport() {
  vec3 direction, origin;
  getCameraRay(origin, direction);

  mat3 rotation = mat3(inverseEllipsoidMatrix);
  vCameraPosition = rotation * origin.xyz * METER_TO_LENGTH_UNIT;
  vRayDirection = rotation * direction.xyz;

  vEllipsoidCenter = (ellipsoidCenter + altitudeCorrection) * METER_TO_LENGTH_UNIT;
  #ifdef CORRECT_GEOMETRIC_ERROR
  // Gradually turn off altitude correction for aerial perspective as geometric
  // error correction takes effect.
  // See: https://github.com/takram-design-engineering/three-geospatial/pull/23#issuecomment-2542914656
  vGeometryEllipsoidCenter =
    (ellipsoidCenter + mix(altitudeCorrection, vec3(0.0), idealSphereAlpha)) * METER_TO_LENGTH_UNIT;
  #else
  vGeometryEllipsoidCenter = vEllipsoidCenter;
  #endif // CORRECT_GEOMETRIC_ERROR

  vec3 radii = ellipsoidRadii * METER_TO_LENGTH_UNIT;
  vEllipsoidRadiiSquared = radii * radii;
}
`, ut = `vec3 getLunarRadiance(const float moonAngularRadius) {
  // Not a physical number but the order of 10^-6 relative to the sun may fit.
  vec3 radiance = u_solar_irradiance * 0.000002 / (PI * moonAngularRadius * moonAngularRadius);
  #ifdef PHOTOMETRIC
  radiance *= SUN_SPECTRAL_RADIANCE_TO_LUMINANCE;
  #endif // PHOTOMETRIC
  return radiance;
}

float intersectSphere(const vec3 ray, const vec3 point, const float radius) {
  vec3 P = -point;
  float PoR = dot(P, ray);
  float D = dot(P, P) - radius * radius;
  return -PoR - sqrt(PoR * PoR - D);
}

float orenNayarDiffuse(const vec3 L, const vec3 V, const vec3 N) {
  float NoL = dot(N, L);
  float NoV = dot(N, V);
  float s = dot(L, V) - NoL * NoV;
  float t = mix(1.0, max(NoL, NoV), step(0.0, s));
  return max(0.0, NoL) * (0.62406015 + 0.41284404 * s / t);
}

vec3 getSkyRadiance(
  const vec3 cameraPosition,
  const vec3 rayDirection,
  float shadowLength,
  const vec3 sunDirection,
  const vec3 moonDirection,
  const float moonAngularRadius,
  const float lunarRadianceScale
) {
  vec3 transmittance;
  vec3 radiance = GetSkyRadiance(
    cameraPosition,
    rayDirection,
    shadowLength,
    sunDirection,
    transmittance
  );

  // Rendering celestial objects without perspective doesn't make sense.
  #ifdef PERSPECTIVE_CAMERA

  #if defined(SUN) || defined(MOON)
  vec3 ddx = dFdx(rayDirection);
  vec3 ddy = dFdy(rayDirection);
  float fragmentAngle = length(ddx + ddy) / length(rayDirection);
  #endif // defined(SUN) || defined(MOON)

  #ifdef SUN
  float viewDotSun = dot(rayDirection, sunDirection);
  if (viewDotSun > cos(u_sun_angular_radius)) {
    float angle = acos(clamp(viewDotSun, -1.0, 1.0));
    float antialias = smoothstep(u_sun_angular_radius, u_sun_angular_radius - fragmentAngle, angle);
    radiance += transmittance * GetSolarRadiance() * antialias;
  }
  #endif // SUN

  #ifdef MOON
  float intersection = intersectSphere(rayDirection, moonDirection, moonAngularRadius);
  if (intersection > 0.0) {
    vec3 normal = normalize(moonDirection - rayDirection * intersection);
    float diffuse = orenNayarDiffuse(-sunDirection, rayDirection, normal);
    float viewDotMoon = dot(rayDirection, moonDirection);
    float angle = acos(clamp(viewDotMoon, -1.0, 1.0));
    float antialias = smoothstep(moonAngularRadius, moonAngularRadius - fragmentAngle, angle);
    radiance +=
      transmittance *
      getLunarRadiance(moonAngularRadius) *
      lunarRadianceScale *
      diffuse *
      antialias;
  }
  #endif // MOON

  #endif // PERSPECTIVE_CAMERA

  return radiance;
}
`;
var Pr = Object.defineProperty, D0 = (t, e, n, a) => {
  for (var o = void 0, c = t.length - 1, u; c >= 0; c--)
    (u = t[c]) && (o = u(e, n, o) || o);
  return o && Pr(e, n, o), o;
};
const Lr = /* @__PURE__ */ new O(), br = /* @__PURE__ */ new O(), Fr = /* @__PURE__ */ new fr(), Hr = {
  blendFunction: Kt.NORMAL,
  octEncodedNormal: !1,
  reconstructNormal: !1,
  ellipsoid: Ue.WGS84,
  correctAltitude: !0,
  correctGeometricError: !0,
  photometric: !0,
  sunIrradiance: !1,
  skyIrradiance: !1,
  transmittance: !0,
  inscatter: !0,
  irradianceScale: 1,
  sky: !1,
  sun: !0,
  moon: !0,
  moonAngularRadius: 45e-4,
  // ≈ 15.5 arcminutes
  lunarRadianceScale: 1
};
class N0 extends Jt {
  constructor(e = new er(), n, a = ce.DEFAULT) {
    const {
      blendFunction: o,
      normalBuffer: c = null,
      octEncodedNormal: u,
      reconstructNormal: d,
      irradianceTexture: l = null,
      scatteringTexture: m = null,
      transmittanceTexture: S = null,
      ellipsoid: g,
      correctAltitude: I,
      correctGeometricError: D,
      photometric: U,
      sunDirection: P,
      sunIrradiance: H,
      skyIrradiance: J,
      transmittance: r0,
      inscatter: i0,
      irradianceScale: u0,
      sky: _0,
      sun: l0,
      moon: p0,
      moonDirection: n0,
      moonAngularRadius: z0,
      lunarRadianceScale: K0
    } = { ...Hr, ...n };
    super(
      "AerialPerspectiveEffect",
      hr(
        Se(Or, {
          core: {
            depth: yr,
            packing: Cr,
            math: Ar,
            transform: Rr,
            raySphereIntersection: st,
            cascadedShadowMaps: Tr,
            interleavedGradientNoise: wr,
            vogelDisk: gr
          },
          parameters: Ee,
          functions: xn,
          sky: ut
        })
      ),
      {
        blendFunction: o,
        vertexShader: Se(Ur, {
          parameters: Ee
        }),
        attributes: Qt.DEPTH,
        // prettier-ignore
        uniforms: new Map(
          Object.entries({
            normalBuffer: new C(c),
            projectionMatrix: new C(new t0()),
            viewMatrix: new C(new t0()),
            inverseProjectionMatrix: new C(new t0()),
            inverseViewMatrix: new C(new t0()),
            cameraPosition: new C(new O()),
            bottomRadius: new C(a.bottomRadius),
            ellipsoidRadii: new C(new O()),
            ellipsoidCenter: new C(new O()),
            inverseEllipsoidMatrix: new C(new t0()),
            altitudeCorrection: new C(new O()),
            sunDirection: new C((P == null ? void 0 : P.clone()) ?? new O()),
            irradianceScale: new C(u0),
            idealSphereAlpha: new C(0),
            moonDirection: new C((n0 == null ? void 0 : n0.clone()) ?? new O()),
            moonAngularRadius: new C(z0),
            lunarRadianceScale: new C(K0),
            // Composition and shadow
            overlayBuffer: new C(null),
            shadowBuffer: new C(null),
            shadowMapSize: new C(new Ke()),
            shadowIntervals: new C([]),
            shadowMatrices: new C([]),
            inverseShadowMatrices: new C([]),
            shadowFar: new C(0),
            shadowTopHeight: new C(0),
            shadowRadius: new C(3),
            stbnTexture: new C(null),
            frame: new C(0),
            shadowLengthBuffer: new C(null),
            // Uniforms for atmosphere functions
            u_solar_irradiance: new C(a.solarIrradiance),
            u_sun_angular_radius: new C(a.sunAngularRadius),
            u_bottom_radius: new C(a.bottomRadius * pe),
            u_top_radius: new C(a.topRadius * pe),
            u_rayleigh_scattering: new C(a.rayleighScattering),
            u_mie_scattering: new C(a.mieScattering),
            u_mie_phase_function_g: new C(a.miePhaseFunctionG),
            u_mu_s_min: new C(a.muSMin),
            u_irradiance_texture: new C(l),
            u_scattering_texture: new C(m),
            u_single_mie_scattering_texture: new C(m),
            u_transmittance_texture: new C(S)
          })
        ),
        // prettier-ignore
        defines: /* @__PURE__ */ new Map([
          ["TRANSMITTANCE_TEXTURE_WIDTH", en.toFixed(0)],
          ["TRANSMITTANCE_TEXTURE_HEIGHT", nn.toFixed(0)],
          ["SCATTERING_TEXTURE_R_SIZE", Mn.toFixed(0)],
          ["SCATTERING_TEXTURE_MU_SIZE", Dn.toFixed(0)],
          ["SCATTERING_TEXTURE_MU_S_SIZE", Nn.toFixed(0)],
          ["SCATTERING_TEXTURE_NU_SIZE", On.toFixed(0)],
          ["IRRADIANCE_TEXTURE_WIDTH", Je.toFixed(0)],
          ["IRRADIANCE_TEXTURE_HEIGHT", Qe.toFixed(0)],
          ["METER_TO_LENGTH_UNIT", pe.toFixed(7)],
          ["SUN_SPECTRAL_RADIANCE_TO_LUMINANCE", `vec3(${a.sunRadianceToRelativeLuminance.toArray().map((G0) => G0.toFixed(12)).join(",")})`],
          ["SKY_SPECTRAL_RADIANCE_TO_LUMINANCE", `vec3(${a.skyRadianceToRelativeLuminance.toArray().map((G0) => G0.toFixed(12)).join(",")})`]
        ])
      }
    ), this.camera = e, this.atmosphere = a, this.ellipsoidMatrix = new t0(), this.overlay = null, this.shadow = null, this.shadowLength = null, this.shadowSampleCount = 8, this.octEncodedNormal = u, this.reconstructNormal = d, this.ellipsoid = g, this.correctAltitude = I, this.correctGeometricError = D, this.photometric = U, this.sunIrradiance = H, this.skyIrradiance = J, this.transmittance = r0, this.inscatter = i0, this.sky = _0, this.sun = l0, this.moon = p0;
  }
  get mainCamera() {
    return this.camera;
  }
  set mainCamera(e) {
    this.camera = e;
  }
  copyCameraSettings(e) {
    const {
      projectionMatrix: n,
      matrixWorldInverse: a,
      projectionMatrixInverse: o,
      matrixWorld: c
    } = e, u = this.uniforms;
    u.get("projectionMatrix").value.copy(n), u.get("viewMatrix").value.copy(a), u.get("inverseProjectionMatrix").value.copy(o), u.get("inverseViewMatrix").value.copy(c);
    const d = e.getWorldPosition(
      u.get("cameraPosition").value
    ), l = u.get("inverseEllipsoidMatrix").value.copy(this.ellipsoidMatrix).invert(), m = Lr.copy(d).applyMatrix4(l).sub(u.get("ellipsoidCenter").value);
    try {
      const g = Fr.setFromECEF(m).height, I = br.set(0, this.ellipsoid.maximumRadius, -g).applyMatrix4(n);
      u.get("idealSphereAlpha").value = pr(
        mr(I.y, 41.5, 13.8, 0, 1)
      );
    } catch {
      return;
    }
    const S = u.get("altitudeCorrection");
    this.correctAltitude ? Un(
      m,
      this.atmosphere.bottomRadius,
      this.ellipsoid,
      S.value
    ) : S.value.setScalar(0);
  }
  updateComposition() {
    const { uniforms: e, defines: n, overlay: a, shadow: o, shadowLength: c } = this, u = n.has("HAS_OVERLAY"), d = a != null;
    d !== u && (d ? n.set("HAS_OVERLAY", "1") : (n.delete("HAS_OVERLAY"), e.get("overlayBuffer").value = null), this.setChanged()), d && (e.get("overlayBuffer").value = a.map);
    const l = n.has("HAS_SHADOW"), m = o != null;
    if (m !== l && (m ? n.set("HAS_SHADOW", "1") : (n.delete("HAS_SHADOW"), e.get("shadowBuffer").value = null), this.setChanged()), m) {
      const I = n.get("SHADOW_CASCADE_COUNT"), D = `${o.cascadeCount}`;
      I !== D && (n.set("SHADOW_CASCADE_COUNT", o.cascadeCount.toFixed(0)), this.setChanged()), e.get("shadowBuffer").value = o.map, e.get("shadowMapSize").value = o.mapSize, e.get("shadowIntervals").value = o.intervals, e.get("shadowMatrices").value = o.matrices, e.get("inverseShadowMatrices").value = o.inverseMatrices, e.get("shadowFar").value = o.far, e.get("shadowTopHeight").value = o.topHeight;
    }
    const S = n.has("HAS_SHADOW_LENGTH"), g = c != null;
    g !== S && (g ? n.set("HAS_SHADOW_LENGTH", "1") : (n.delete("HAS_SHADOW_LENGTH"), e.get("shadowLengthBuffer").value = null), this.setChanged()), g && (e.get("shadowLengthBuffer").value = c.map);
  }
  update(e, n, a) {
    this.copyCameraSettings(this.camera), this.updateComposition(), ++this.uniforms.get("frame").value;
  }
  get normalBuffer() {
    return this.uniforms.get("normalBuffer").value;
  }
  set normalBuffer(e) {
    this.uniforms.get("normalBuffer").value = e;
  }
  get irradianceTexture() {
    return this.uniforms.get("u_irradiance_texture").value;
  }
  set irradianceTexture(e) {
    this.uniforms.get("u_irradiance_texture").value = e;
  }
  get scatteringTexture() {
    return this.uniforms.get("u_scattering_texture").value;
  }
  set scatteringTexture(e) {
    this.uniforms.get("u_scattering_texture").value = e, this.uniforms.get("u_single_mie_scattering_texture").value = e;
  }
  get transmittanceTexture() {
    return this.uniforms.get("u_transmittance_texture").value;
  }
  set transmittanceTexture(e) {
    this.uniforms.get("u_transmittance_texture").value = e;
  }
  get ellipsoid() {
    return this._ellipsoid;
  }
  set ellipsoid(e) {
    this._ellipsoid = e, this.uniforms.get("ellipsoidRadii").value.copy(e.radii);
  }
  get ellipsoidCenter() {
    return this.uniforms.get("ellipsoidCenter").value;
  }
  get sunDirection() {
    return this.uniforms.get("sunDirection").value;
  }
  get irradianceScale() {
    return this.uniforms.get("irradianceScale").value;
  }
  set irradianceScale(e) {
    this.uniforms.get("irradianceScale").value = e;
  }
  get moonDirection() {
    return this.uniforms.get("moonDirection").value;
  }
  get moonAngularRadius() {
    return this.uniforms.get("moonAngularRadius").value;
  }
  set moonAngularRadius(e) {
    this.uniforms.get("moonAngularRadius").value = e;
  }
  get lunarRadianceScale() {
    return this.uniforms.get("lunarRadianceScale").value;
  }
  set lunarRadianceScale(e) {
    this.uniforms.get("lunarRadianceScale").value = e;
  }
  get stbnTexture() {
    return this.uniforms.get("stbnTexture").value;
  }
  set stbnTexture(e) {
    this.uniforms.get("stbnTexture").value = e;
  }
  get shadowRadius() {
    return this.uniforms.get("shadowRadius").value;
  }
  set shadowRadius(e) {
    this.uniforms.get("shadowRadius").value = e;
  }
}
D0([
  E0("OCT_ENCODED_NORMAL")
], N0.prototype, "octEncodedNormal");
D0([
  E0("RECONSTRUCT_NORMAL")
], N0.prototype, "reconstructNormal");
D0([
  E0("CORRECT_GEOMETRIC_ERROR")
], N0.prototype, "correctGeometricError");
D0([
  E0("PHOTOMETRIC")
], N0.prototype, "photometric");
D0([
  E0("SUN_IRRADIANCE")
], N0.prototype, "sunIrradiance");
D0([
  E0("SKY_IRRADIANCE")
], N0.prototype, "skyIrradiance");
D0([
  E0("TRANSMITTANCE")
], N0.prototype, "transmittance");
D0([
  E0("INSCATTER")
], N0.prototype, "inscatter");
D0([
  E0("SKY")
], N0.prototype, "sky");
D0([
  E0("SUN")
], N0.prototype, "sun");
D0([
  E0("MOON")
], N0.prototype, "moon");
D0([
  vr("SHADOW_SAMPLE_COUNT", { min: 1, max: 16 })
], N0.prototype, "shadowSampleCount");
var zr = Object.defineProperty, Gr = (t, e, n, a) => {
  for (var o = void 0, c = t.length - 1, u; c >= 0; c--)
    (u = t[c]) && (o = u(e, n, o) || o);
  return o && zr(e, n, o), o;
};
const kr = /* @__PURE__ */ new O();
function Br(t, e) {
  let n = "", a = "";
  for (let o = 1; o < e; ++o)
    n += `layout(location = ${o}) out float renderTarget${o};
`, a += `renderTarget${o} = 0.0;
`;
  return t.replace("#include <mrt_layout>", n).replace("#include <mrt_output>", a);
}
const Pn = {
  ellipsoid: Ue.WGS84,
  correctAltitude: !0,
  photometric: !0,
  renderTargetCount: 1
};
class Ln extends nr {
  constructor(e, n = ce.DEFAULT) {
    const {
      irradianceTexture: a = null,
      scatteringTexture: o = null,
      transmittanceTexture: c = null,
      ellipsoid: u,
      correctAltitude: d,
      photometric: l,
      sunDirection: m,
      sunAngularRadius: S,
      renderTargetCount: g,
      ...I
    } = { ...Pn, ...e };
    super({
      toneMapped: !1,
      depthWrite: !1,
      depthTest: !1,
      ...I,
      // prettier-ignore
      uniforms: {
        cameraPosition: new C(new O()),
        ellipsoidCenter: new C(new O()),
        inverseEllipsoidMatrix: new C(new t0()),
        altitudeCorrection: new C(new O()),
        sunDirection: new C((m == null ? void 0 : m.clone()) ?? new O()),
        // Uniforms for atmosphere functions
        u_solar_irradiance: new C(n.solarIrradiance),
        u_sun_angular_radius: new C(S ?? n.sunAngularRadius),
        u_bottom_radius: new C(n.bottomRadius * pe),
        u_top_radius: new C(n.topRadius * pe),
        u_rayleigh_scattering: new C(n.rayleighScattering),
        u_mie_scattering: new C(n.mieScattering),
        u_mie_phase_function_g: new C(n.miePhaseFunctionG),
        u_mu_s_min: new C(n.muSMin),
        u_irradiance_texture: new C(a),
        u_scattering_texture: new C(o),
        u_single_mie_scattering_texture: new C(o),
        u_transmittance_texture: new C(c),
        ...I.uniforms
      },
      // prettier-ignore
      defines: {
        PI: `${Math.PI}`,
        TRANSMITTANCE_TEXTURE_WIDTH: en.toFixed(0),
        TRANSMITTANCE_TEXTURE_HEIGHT: nn.toFixed(0),
        SCATTERING_TEXTURE_R_SIZE: Mn.toFixed(0),
        SCATTERING_TEXTURE_MU_SIZE: Dn.toFixed(0),
        SCATTERING_TEXTURE_MU_S_SIZE: Nn.toFixed(0),
        SCATTERING_TEXTURE_NU_SIZE: On.toFixed(0),
        IRRADIANCE_TEXTURE_WIDTH: Je.toFixed(0),
        IRRADIANCE_TEXTURE_HEIGHT: Qe.toFixed(0),
        METER_TO_LENGTH_UNIT: pe.toFixed(7),
        SUN_SPECTRAL_RADIANCE_TO_LUMINANCE: `vec3(${n.sunRadianceToRelativeLuminance.toArray().map((D) => D.toFixed(12)).join(",")})`,
        SKY_SPECTRAL_RADIANCE_TO_LUMINANCE: `vec3(${n.skyRadianceToRelativeLuminance.toArray().map((D) => D.toFixed(12)).join(",")})`,
        ...I.defines
      }
    }), this.atmosphere = n, this.ellipsoidMatrix = new t0(), this.atmosphere = n, this.ellipsoid = u, this.correctAltitude = d, this.photometric = l, this.renderTargetCount = g;
  }
  copyCameraSettings(e) {
    const n = this.uniforms, a = e.getWorldPosition(
      n.cameraPosition.value
    ), o = n.inverseEllipsoidMatrix.value.copy(this.ellipsoidMatrix).invert(), c = kr.copy(a).applyMatrix4(o).sub(n.ellipsoidCenter.value), u = n.altitudeCorrection.value;
    this.correctAltitude ? Un(
      c,
      this.atmosphere.bottomRadius,
      this.ellipsoid,
      u
    ) : u.setScalar(0);
  }
  onBeforeCompile(e, n) {
    e.fragmentShader = Br(
      e.fragmentShader,
      this.renderTargetCount
    );
  }
  onBeforeRender(e, n, a, o, c, u) {
    this.copyCameraSettings(a);
  }
  get irradianceTexture() {
    return this.uniforms.u_irradiance_texture.value;
  }
  set irradianceTexture(e) {
    this.uniforms.u_irradiance_texture.value = e;
  }
  get scatteringTexture() {
    return this.uniforms.u_scattering_texture.value;
  }
  set scatteringTexture(e) {
    this.uniforms.u_scattering_texture.value = e, this.uniforms.u_single_mie_scattering_texture.value = e;
  }
  get transmittanceTexture() {
    return this.uniforms.u_transmittance_texture.value;
  }
  set transmittanceTexture(e) {
    this.uniforms.u_transmittance_texture.value = e;
  }
  get ellipsoidCenter() {
    return this.uniforms.ellipsoidCenter.value;
  }
  get sunDirection() {
    return this.uniforms.sunDirection.value;
  }
  get sunAngularRadius() {
    return this.uniforms.u_sun_angular_radius.value;
  }
  set sunAngularRadius(e) {
    this.uniforms.u_sun_angular_radius.value = e;
  }
  /** @package */
  get renderTargetCount() {
    return this._renderTargetCount;
  }
  /** @package */
  set renderTargetCount(e) {
    e !== this.renderTargetCount && (this._renderTargetCount = e, this.needsUpdate = !0);
  }
}
Gr([
  E0("PHOTOMETRIC")
], Ln.prototype, "photometric");
/**
    @preserve

    Astronomy library for JavaScript (browser and Node.js).
    https://github.com/cosinekitty/astronomy

    MIT License

    Copyright (c) 2019-2023 Don Cross <cosinekitty@gmail.com>

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/
/**
 * @fileoverview Astronomy calculation library for browser scripting and Node.js.
 * @author Don Cross <cosinekitty@gmail.com>
 * @license MIT
 */
const Zr = 173.1446326846693, Wr = 14959787069098932e-8, _e = 0.017453292519943295, Xr = 365.24217, $n = /* @__PURE__ */ new Date("2000-01-01T12:00:00Z"), $0 = 2 * Math.PI, ne = 3600 * (180 / Math.PI), he = 484813681109536e-20, Vr = 180 * 60 * 60, Yr = 2 * Vr, $r = 6378.1366, jr = $r / Wr, qr = 81.30056, bn = 2959122082855911e-19, fn = 2825345909524226e-22, pn = 8459715185680659e-23, mn = 1292024916781969e-23, Sn = 1524358900784276e-23;
function sn(t) {
  if (!Number.isFinite(t))
    throw console.trace(), `Value is not a finite number: ${t}`;
  return t;
}
function ve(t) {
  return t - Math.floor(t);
}
var k;
(function(t) {
  t.Sun = "Sun", t.Moon = "Moon", t.Mercury = "Mercury", t.Venus = "Venus", t.Earth = "Earth", t.Mars = "Mars", t.Jupiter = "Jupiter", t.Saturn = "Saturn", t.Uranus = "Uranus", t.Neptune = "Neptune", t.Pluto = "Pluto", t.SSB = "SSB", t.EMB = "EMB", t.Star1 = "Star1", t.Star2 = "Star2", t.Star3 = "Star3", t.Star4 = "Star4", t.Star5 = "Star5", t.Star6 = "Star6", t.Star7 = "Star7", t.Star8 = "Star8";
})(k || (k = {}));
const Kr = [
  k.Star1,
  k.Star2,
  k.Star3,
  k.Star4,
  k.Star5,
  k.Star6,
  k.Star7,
  k.Star8
], Jr = [
  { ra: 0, dec: 0, dist: 0 },
  { ra: 0, dec: 0, dist: 0 },
  { ra: 0, dec: 0, dist: 0 },
  { ra: 0, dec: 0, dist: 0 },
  { ra: 0, dec: 0, dist: 0 },
  { ra: 0, dec: 0, dist: 0 },
  { ra: 0, dec: 0, dist: 0 },
  { ra: 0, dec: 0, dist: 0 }
];
function Qr(t) {
  const e = Kr.indexOf(t);
  return e >= 0 ? Jr[e] : null;
}
function lt(t) {
  const e = Qr(t);
  return e && e.dist > 0 ? e : null;
}
var q0;
(function(t) {
  t[t.From2000 = 0] = "From2000", t[t.Into2000 = 1] = "Into2000";
})(q0 || (q0 = {}));
const fe = {
  Mercury: [
    [
      [
        [4.40250710144, 0, 0],
        [0.40989414977, 1.48302034195, 26087.9031415742],
        [0.050462942, 4.47785489551, 52175.8062831484],
        [0.00855346844, 1.16520322459, 78263.70942472259],
        [0.00165590362, 4.11969163423, 104351.61256629678],
        [34561897e-11, 0.77930768443, 130439.51570787099],
        [7583476e-11, 3.71348404924, 156527.41884944518]
      ],
      [
        [26087.90313685529, 0, 0],
        [0.01131199811, 6.21874197797, 26087.9031415742],
        [0.00292242298, 3.04449355541, 52175.8062831484],
        [75775081e-11, 6.08568821653, 78263.70942472259],
        [19676525e-11, 2.80965111777, 104351.61256629678]
      ]
    ],
    [
      [
        [0.11737528961, 1.98357498767, 26087.9031415742],
        [0.02388076996, 5.03738959686, 52175.8062831484],
        [0.01222839532, 3.14159265359, 0],
        [0.0054325181, 1.79644363964, 78263.70942472259],
        [0.0012977877, 4.83232503958, 104351.61256629678],
        [31866927e-11, 1.58088495658, 130439.51570787099],
        [7963301e-11, 4.60972126127, 156527.41884944518]
      ],
      [
        [0.00274646065, 3.95008450011, 26087.9031415742],
        [99737713e-11, 3.14159265359, 0]
      ]
    ],
    [
      [
        [0.39528271651, 0, 0],
        [0.07834131818, 6.19233722598, 26087.9031415742],
        [0.00795525558, 2.95989690104, 52175.8062831484],
        [0.00121281764, 6.01064153797, 78263.70942472259],
        [21921969e-11, 2.77820093972, 104351.61256629678],
        [4354065e-11, 5.82894543774, 130439.51570787099]
      ],
      [
        [0.0021734774, 4.65617158665, 26087.9031415742],
        [44141826e-11, 1.42385544001, 52175.8062831484]
      ]
    ]
  ],
  Venus: [
    [
      [
        [3.17614666774, 0, 0],
        [0.01353968419, 5.59313319619, 10213.285546211],
        [89891645e-11, 5.30650047764, 20426.571092422],
        [5477194e-11, 4.41630661466, 7860.4193924392],
        [3455741e-11, 2.6996444782, 11790.6290886588],
        [2372061e-11, 2.99377542079, 3930.2096962196],
        [1317168e-11, 5.18668228402, 26.2983197998],
        [1664146e-11, 4.25018630147, 1577.3435424478],
        [1438387e-11, 4.15745084182, 9683.5945811164],
        [1200521e-11, 6.15357116043, 30639.856638633]
      ],
      [
        [10213.28554621638, 0, 0],
        [95617813e-11, 2.4640651111, 10213.285546211],
        [7787201e-11, 0.6247848222, 20426.571092422]
      ]
    ],
    [
      [
        [0.05923638472, 0.26702775812, 10213.285546211],
        [40107978e-11, 1.14737178112, 20426.571092422],
        [32814918e-11, 3.14159265359, 0]
      ],
      [
        [0.00287821243, 1.88964962838, 10213.285546211]
      ]
    ],
    [
      [
        [0.72334820891, 0, 0],
        [0.00489824182, 4.02151831717, 10213.285546211],
        [1658058e-11, 4.90206728031, 20426.571092422],
        [1378043e-11, 1.12846591367, 11790.6290886588],
        [1632096e-11, 2.84548795207, 7860.4193924392],
        [498395e-11, 2.58682193892, 9683.5945811164],
        [221985e-11, 2.01346696541, 19367.1891622328],
        [237454e-11, 2.55136053886, 15720.8387848784]
      ],
      [
        [34551041e-11, 0.89198706276, 10213.285546211]
      ]
    ]
  ],
  Earth: [
    [
      [
        [1.75347045673, 0, 0],
        [0.03341656453, 4.66925680415, 6283.0758499914],
        [34894275e-11, 4.62610242189, 12566.1516999828],
        [3417572e-11, 2.82886579754, 3.523118349],
        [3497056e-11, 2.74411783405, 5753.3848848968],
        [3135899e-11, 3.62767041756, 77713.7714681205],
        [2676218e-11, 4.41808345438, 7860.4193924392],
        [2342691e-11, 6.13516214446, 3930.2096962196],
        [1273165e-11, 2.03709657878, 529.6909650946],
        [1324294e-11, 0.74246341673, 11506.7697697936],
        [901854e-11, 2.04505446477, 26.2983197998],
        [1199167e-11, 1.10962946234, 1577.3435424478],
        [857223e-11, 3.50849152283, 398.1490034082],
        [779786e-11, 1.17882681962, 5223.6939198022],
        [99025e-10, 5.23268072088, 5884.9268465832],
        [753141e-11, 2.53339052847, 5507.5532386674],
        [505267e-11, 4.58292599973, 18849.2275499742],
        [492392e-11, 4.20505711826, 775.522611324],
        [356672e-11, 2.91954114478, 0.0673103028],
        [284125e-11, 1.89869240932, 796.2980068164],
        [242879e-11, 0.34481445893, 5486.777843175],
        [317087e-11, 5.84901948512, 11790.6290886588],
        [271112e-11, 0.31486255375, 10977.078804699],
        [206217e-11, 4.80646631478, 2544.3144198834],
        [205478e-11, 1.86953770281, 5573.1428014331],
        [202318e-11, 2.45767790232, 6069.7767545534],
        [126225e-11, 1.08295459501, 20.7753954924],
        [155516e-11, 0.83306084617, 213.299095438]
      ],
      [
        [6283.0758499914, 0, 0],
        [0.00206058863, 2.67823455808, 6283.0758499914],
        [4303419e-11, 2.63512233481, 12566.1516999828]
      ],
      [
        [8721859e-11, 1.07253635559, 6283.0758499914]
      ]
    ],
    [
      [],
      [
        [0.00227777722, 3.4137662053, 6283.0758499914],
        [3805678e-11, 3.37063423795, 12566.1516999828]
      ]
    ],
    [
      [
        [1.00013988784, 0, 0],
        [0.01670699632, 3.09846350258, 6283.0758499914],
        [13956024e-11, 3.05524609456, 12566.1516999828],
        [308372e-10, 5.19846674381, 77713.7714681205],
        [1628463e-11, 1.17387558054, 5753.3848848968],
        [1575572e-11, 2.84685214877, 7860.4193924392],
        [924799e-11, 5.45292236722, 11506.7697697936],
        [542439e-11, 4.56409151453, 3930.2096962196],
        [47211e-10, 3.66100022149, 5884.9268465832],
        [85831e-11, 1.27079125277, 161000.6857376741],
        [57056e-11, 2.01374292245, 83996.84731811189],
        [55736e-11, 5.2415979917, 71430.69561812909],
        [174844e-11, 3.01193636733, 18849.2275499742],
        [243181e-11, 4.2734953079, 11790.6290886588]
      ],
      [
        [0.00103018607, 1.10748968172, 6283.0758499914],
        [1721238e-11, 1.06442300386, 12566.1516999828]
      ],
      [
        [4359385e-11, 5.78455133808, 6283.0758499914]
      ]
    ]
  ],
  Mars: [
    [
      [
        [6.20347711581, 0, 0],
        [0.18656368093, 5.0503710027, 3340.6124266998],
        [0.01108216816, 5.40099836344, 6681.2248533996],
        [91798406e-11, 5.75478744667, 10021.8372800994],
        [27744987e-11, 5.97049513147, 3.523118349],
        [10610235e-11, 2.93958560338, 2281.2304965106],
        [12315897e-11, 0.84956094002, 2810.9214616052],
        [8926784e-11, 4.15697846427, 0.0172536522],
        [8715691e-11, 6.11005153139, 13362.4497067992],
        [6797556e-11, 0.36462229657, 398.1490034082],
        [7774872e-11, 3.33968761376, 5621.8429232104],
        [3575078e-11, 1.6618650571, 2544.3144198834],
        [4161108e-11, 0.22814971327, 2942.4634232916],
        [3075252e-11, 0.85696614132, 191.4482661116],
        [2628117e-11, 0.64806124465, 3337.0893083508],
        [2937546e-11, 6.07893711402, 0.0673103028],
        [2389414e-11, 5.03896442664, 796.2980068164],
        [2579844e-11, 0.02996736156, 3344.1355450488],
        [1528141e-11, 1.14979301996, 6151.533888305],
        [1798806e-11, 0.65634057445, 529.6909650946],
        [1264357e-11, 3.62275122593, 5092.1519581158],
        [1286228e-11, 3.06796065034, 2146.1654164752],
        [1546404e-11, 2.91579701718, 1751.539531416],
        [1024902e-11, 3.69334099279, 8962.4553499102],
        [891566e-11, 0.18293837498, 16703.062133499],
        [858759e-11, 2.4009381194, 2914.0142358238],
        [832715e-11, 2.46418619474, 3340.5951730476],
        [83272e-10, 4.49495782139, 3340.629680352],
        [712902e-11, 3.66335473479, 1059.3819301892],
        [748723e-11, 3.82248614017, 155.4203994342],
        [723861e-11, 0.67497311481, 3738.761430108],
        [635548e-11, 2.92182225127, 8432.7643848156],
        [655162e-11, 0.48864064125, 3127.3133312618],
        [550474e-11, 3.81001042328, 0.9803210682],
        [55275e-10, 4.47479317037, 1748.016413067],
        [425966e-11, 0.55364317304, 6283.0758499914],
        [415131e-11, 0.49662285038, 213.299095438],
        [472167e-11, 3.62547124025, 1194.4470102246],
        [306551e-11, 0.38052848348, 6684.7479717486],
        [312141e-11, 0.99853944405, 6677.7017350506],
        [293198e-11, 4.22131299634, 20.7753954924],
        [302375e-11, 4.48618007156, 3532.0606928114],
        [274027e-11, 0.54222167059, 3340.545116397],
        [281079e-11, 5.88163521788, 1349.8674096588],
        [231183e-11, 1.28242156993, 3870.3033917944],
        [283602e-11, 5.7688543494, 3149.1641605882],
        [236117e-11, 5.75503217933, 3333.498879699],
        [274033e-11, 0.13372524985, 3340.6797370026],
        [299395e-11, 2.78323740866, 6254.6266625236]
      ],
      [
        [3340.61242700512, 0, 0],
        [0.01457554523, 3.60433733236, 3340.6124266998],
        [0.00168414711, 3.92318567804, 6681.2248533996],
        [20622975e-11, 4.26108844583, 10021.8372800994],
        [3452392e-11, 4.7321039319, 3.523118349],
        [2586332e-11, 4.60670058555, 13362.4497067992],
        [841535e-11, 4.45864030426, 2281.2304965106]
      ],
      [
        [58152577e-11, 2.04961712429, 3340.6124266998],
        [13459579e-11, 2.45738706163, 6681.2248533996]
      ]
    ],
    [
      [
        [0.03197134986, 3.76832042431, 3340.6124266998],
        [0.00298033234, 4.10616996305, 6681.2248533996],
        [0.00289104742, 0, 0],
        [31365539e-11, 4.4465105309, 10021.8372800994],
        [34841e-9, 4.7881254926, 13362.4497067992]
      ],
      [
        [0.00217310991, 6.04472194776, 3340.6124266998],
        [20976948e-11, 3.14159265359, 0],
        [12834709e-11, 1.60810667915, 6681.2248533996]
      ]
    ],
    [
      [
        [1.53033488271, 0, 0],
        [0.1418495316, 3.47971283528, 3340.6124266998],
        [0.00660776362, 3.81783443019, 6681.2248533996],
        [46179117e-11, 4.15595316782, 10021.8372800994],
        [8109733e-11, 5.55958416318, 2810.9214616052],
        [7485318e-11, 1.77239078402, 5621.8429232104],
        [5523191e-11, 1.3643630377, 2281.2304965106],
        [382516e-10, 4.49407183687, 13362.4497067992],
        [2306537e-11, 0.09081579001, 2544.3144198834],
        [1999396e-11, 5.36059617709, 3337.0893083508],
        [2484394e-11, 4.9254563992, 2942.4634232916],
        [1960195e-11, 4.74249437639, 3344.1355450488],
        [1167119e-11, 2.11260868341, 5092.1519581158],
        [1102816e-11, 5.00908403998, 398.1490034082],
        [899066e-11, 4.40791133207, 529.6909650946],
        [992252e-11, 5.83861961952, 6151.533888305],
        [807354e-11, 2.10217065501, 1059.3819301892],
        [797915e-11, 3.44839203899, 796.2980068164],
        [740975e-11, 1.49906336885, 2146.1654164752]
      ],
      [
        [0.01107433345, 2.03250524857, 3340.6124266998],
        [0.00103175887, 2.37071847807, 6681.2248533996],
        [128772e-9, 0, 0],
        [1081588e-10, 2.70888095665, 10021.8372800994]
      ],
      [
        [44242249e-11, 0.47930604954, 3340.6124266998],
        [8138042e-11, 0.86998389204, 6681.2248533996]
      ]
    ]
  ],
  Jupiter: [
    [
      [
        [0.59954691494, 0, 0],
        [0.09695898719, 5.06191793158, 529.6909650946],
        [0.00573610142, 1.44406205629, 7.1135470008],
        [0.00306389205, 5.41734730184, 1059.3819301892],
        [97178296e-11, 4.14264726552, 632.7837393132],
        [72903078e-11, 3.64042916389, 522.5774180938],
        [64263975e-11, 3.41145165351, 103.0927742186],
        [39806064e-11, 2.29376740788, 419.4846438752],
        [38857767e-11, 1.27231755835, 316.3918696566],
        [27964629e-11, 1.7845459182, 536.8045120954],
        [1358973e-10, 5.7748104079, 1589.0728952838],
        [8246349e-11, 3.5822792584, 206.1855484372],
        [8768704e-11, 3.63000308199, 949.1756089698],
        [7368042e-11, 5.0810119427, 735.8765135318],
        [626315e-10, 0.02497628807, 213.299095438],
        [6114062e-11, 4.51319998626, 1162.4747044078],
        [4905396e-11, 1.32084470588, 110.2063212194],
        [5305285e-11, 1.30671216791, 14.2270940016],
        [5305441e-11, 4.18625634012, 1052.2683831884],
        [4647248e-11, 4.69958103684, 3.9321532631],
        [3045023e-11, 4.31676431084, 426.598190876],
        [2609999e-11, 1.56667394063, 846.0828347512],
        [2028191e-11, 1.06376530715, 3.1813937377],
        [1764763e-11, 2.14148655117, 1066.49547719],
        [1722972e-11, 3.88036268267, 1265.5674786264],
        [1920945e-11, 0.97168196472, 639.897286314],
        [1633223e-11, 3.58201833555, 515.463871093],
        [1431999e-11, 4.29685556046, 625.6701923124],
        [973272e-11, 4.09764549134, 95.9792272178]
      ],
      [
        [529.69096508814, 0, 0],
        [0.00489503243, 4.2208293947, 529.6909650946],
        [0.00228917222, 6.02646855621, 7.1135470008],
        [30099479e-11, 4.54540782858, 1059.3819301892],
        [2072092e-10, 5.45943156902, 522.5774180938],
        [12103653e-11, 0.16994816098, 536.8045120954],
        [6067987e-11, 4.42422292017, 103.0927742186],
        [5433968e-11, 3.98480737746, 419.4846438752],
        [4237744e-11, 5.89008707199, 14.2270940016]
      ],
      [
        [47233601e-11, 4.32148536482, 7.1135470008],
        [30649436e-11, 2.929777887, 529.6909650946],
        [14837605e-11, 3.14159265359, 0]
      ]
    ],
    [
      [
        [0.02268615702, 3.55852606721, 529.6909650946],
        [0.00109971634, 3.90809347197, 1059.3819301892],
        [0.00110090358, 0, 0],
        [8101428e-11, 3.60509572885, 522.5774180938],
        [6043996e-11, 4.25883108339, 1589.0728952838],
        [6437782e-11, 0.30627119215, 536.8045120954]
      ],
      [
        [78203446e-11, 1.52377859742, 529.6909650946]
      ]
    ],
    [
      [
        [5.20887429326, 0, 0],
        [0.25209327119, 3.49108639871, 529.6909650946],
        [0.00610599976, 3.84115365948, 1059.3819301892],
        [0.00282029458, 2.57419881293, 632.7837393132],
        [0.00187647346, 2.07590383214, 522.5774180938],
        [86792905e-11, 0.71001145545, 419.4846438752],
        [72062974e-11, 0.21465724607, 536.8045120954],
        [65517248e-11, 5.9799588479, 316.3918696566],
        [29134542e-11, 1.67759379655, 103.0927742186],
        [30135335e-11, 2.16132003734, 949.1756089698],
        [23453271e-11, 3.54023522184, 735.8765135318],
        [22283743e-11, 4.19362594399, 1589.0728952838],
        [23947298e-11, 0.2745803748, 7.1135470008],
        [13032614e-11, 2.96042965363, 1162.4747044078],
        [970336e-10, 1.90669633585, 206.1855484372],
        [12749023e-11, 2.71550286592, 1052.2683831884],
        [7057931e-11, 2.18184839926, 1265.5674786264],
        [6137703e-11, 6.26418240033, 846.0828347512],
        [2616976e-11, 2.00994012876, 1581.959348283]
      ],
      [
        [0.0127180152, 2.64937512894, 529.6909650946],
        [61661816e-11, 3.00076460387, 1059.3819301892],
        [53443713e-11, 3.89717383175, 522.5774180938],
        [31185171e-11, 4.88276958012, 536.8045120954],
        [41390269e-11, 0, 0]
      ]
    ]
  ],
  Saturn: [
    [
      [
        [0.87401354025, 0, 0],
        [0.11107659762, 3.96205090159, 213.299095438],
        [0.01414150957, 4.58581516874, 7.1135470008],
        [0.00398379389, 0.52112032699, 206.1855484372],
        [0.00350769243, 3.30329907896, 426.598190876],
        [0.00206816305, 0.24658372002, 103.0927742186],
        [792713e-9, 3.84007056878, 220.4126424388],
        [23990355e-11, 4.66976924553, 110.2063212194],
        [16573588e-11, 0.43719228296, 419.4846438752],
        [14906995e-11, 5.76903183869, 316.3918696566],
        [1582029e-10, 0.93809155235, 632.7837393132],
        [14609559e-11, 1.56518472, 3.9321532631],
        [13160301e-11, 4.44891291899, 14.2270940016],
        [15053543e-11, 2.71669915667, 639.897286314],
        [13005299e-11, 5.98119023644, 11.0457002639],
        [10725067e-11, 3.12939523827, 202.2533951741],
        [5863206e-11, 0.23656938524, 529.6909650946],
        [5227757e-11, 4.20783365759, 3.1813937377],
        [6126317e-11, 1.76328667907, 277.0349937414],
        [5019687e-11, 3.17787728405, 433.7117378768],
        [459255e-10, 0.61977744975, 199.0720014364],
        [4005867e-11, 2.24479718502, 63.7358983034],
        [2953796e-11, 0.98280366998, 95.9792272178],
        [387367e-10, 3.22283226966, 138.5174968707],
        [2461186e-11, 2.03163875071, 735.8765135318],
        [3269484e-11, 0.77492638211, 949.1756089698],
        [1758145e-11, 3.2658010994, 522.5774180938],
        [1640172e-11, 5.5050445305, 846.0828347512],
        [1391327e-11, 4.02333150505, 323.5054166574],
        [1580648e-11, 4.37265307169, 309.2783226558],
        [1123498e-11, 2.83726798446, 415.5524906121],
        [1017275e-11, 3.71700135395, 227.5261894396],
        [848642e-11, 3.1915017083, 209.3669421749]
      ],
      [
        [213.2990952169, 0, 0],
        [0.01297370862, 1.82834923978, 213.299095438],
        [0.00564345393, 2.88499717272, 7.1135470008],
        [93734369e-11, 1.06311793502, 426.598190876],
        [0.00107674962, 2.27769131009, 206.1855484372],
        [40244455e-11, 2.04108104671, 220.4126424388],
        [19941774e-11, 1.2795439047, 103.0927742186],
        [10511678e-11, 2.7488034213, 14.2270940016],
        [6416106e-11, 0.38238295041, 639.897286314],
        [4848994e-11, 2.43037610229, 419.4846438752],
        [4056892e-11, 2.92133209468, 110.2063212194],
        [3768635e-11, 3.6496533078, 3.9321532631]
      ],
      [
        [0.0011644133, 1.17988132879, 7.1135470008],
        [91841837e-11, 0.0732519584, 213.299095438],
        [36661728e-11, 0, 0],
        [15274496e-11, 4.06493179167, 206.1855484372]
      ]
    ],
    [
      [
        [0.04330678039, 3.60284428399, 213.299095438],
        [0.00240348302, 2.85238489373, 426.598190876],
        [84745939e-11, 0, 0],
        [30863357e-11, 3.48441504555, 220.4126424388],
        [34116062e-11, 0.57297307557, 206.1855484372],
        [1473407e-10, 2.11846596715, 639.897286314],
        [9916667e-11, 5.79003188904, 419.4846438752],
        [6993564e-11, 4.7360468972, 7.1135470008],
        [4807588e-11, 5.43305312061, 316.3918696566]
      ],
      [
        [0.00198927992, 4.93901017903, 213.299095438],
        [36947916e-11, 3.14159265359, 0],
        [17966989e-11, 0.5197943111, 426.598190876]
      ]
    ],
    [
      [
        [9.55758135486, 0, 0],
        [0.52921382865, 2.39226219573, 213.299095438],
        [0.01873679867, 5.2354960466, 206.1855484372],
        [0.01464663929, 1.64763042902, 426.598190876],
        [0.00821891141, 5.93520042303, 316.3918696566],
        [0.00547506923, 5.0153261898, 103.0927742186],
        [0.0037168465, 2.27114821115, 220.4126424388],
        [0.00361778765, 3.13904301847, 7.1135470008],
        [0.00140617506, 5.70406606781, 632.7837393132],
        [0.00108974848, 3.29313390175, 110.2063212194],
        [69006962e-11, 5.94099540992, 419.4846438752],
        [61053367e-11, 0.94037691801, 639.897286314],
        [48913294e-11, 1.55733638681, 202.2533951741],
        [34143772e-11, 0.19519102597, 277.0349937414],
        [32401773e-11, 5.47084567016, 949.1756089698],
        [20936596e-11, 0.46349251129, 735.8765135318],
        [9796004e-11, 5.20477537945, 1265.5674786264],
        [11993338e-11, 5.98050967385, 846.0828347512],
        [208393e-9, 1.52102476129, 433.7117378768],
        [15298404e-11, 3.0594381494, 529.6909650946],
        [6465823e-11, 0.17732249942, 1052.2683831884],
        [11380257e-11, 1.7310542704, 522.5774180938],
        [3419618e-11, 4.94550542171, 1581.959348283]
      ],
      [
        [0.0618298134, 0.2584351148, 213.299095438],
        [0.00506577242, 0.71114625261, 206.1855484372],
        [0.00341394029, 5.79635741658, 426.598190876],
        [0.00188491195, 0.47215589652, 220.4126424388],
        [0.00186261486, 3.14159265359, 0],
        [0.00143891146, 1.40744822888, 7.1135470008]
      ],
      [
        [0.00436902572, 4.78671677509, 213.299095438]
      ]
    ]
  ],
  Uranus: [
    [
      [
        [5.48129294297, 0, 0],
        [0.09260408234, 0.89106421507, 74.7815985673],
        [0.01504247898, 3.6271926092, 1.4844727083],
        [0.00365981674, 1.89962179044, 73.297125859],
        [0.00272328168, 3.35823706307, 149.5631971346],
        [70328461e-11, 5.39254450063, 63.7358983034],
        [68892678e-11, 6.09292483287, 76.2660712756],
        [61998615e-11, 2.26952066061, 2.9689454166],
        [61950719e-11, 2.85098872691, 11.0457002639],
        [2646877e-10, 3.14152083966, 71.8126531507],
        [25710476e-11, 6.11379840493, 454.9093665273],
        [2107885e-10, 4.36059339067, 148.0787244263],
        [17818647e-11, 1.74436930289, 36.6485629295],
        [14613507e-11, 4.73732166022, 3.9321532631],
        [11162509e-11, 5.8268179635, 224.3447957019],
        [1099791e-10, 0.48865004018, 138.5174968707],
        [9527478e-11, 2.95516862826, 35.1640902212],
        [7545601e-11, 5.236265824, 109.9456887885],
        [4220241e-11, 3.23328220918, 70.8494453042],
        [40519e-9, 2.277550173, 151.0476698429],
        [3354596e-11, 1.0654900738, 4.4534181249],
        [2926718e-11, 4.62903718891, 9.5612275556],
        [349034e-10, 5.48306144511, 146.594251718],
        [3144069e-11, 4.75199570434, 77.7505439839],
        [2922333e-11, 5.35235361027, 85.8272988312],
        [2272788e-11, 4.36600400036, 70.3281804424],
        [2051219e-11, 1.51773566586, 0.1118745846],
        [2148602e-11, 0.60745949945, 38.1330356378],
        [1991643e-11, 4.92437588682, 277.0349937414],
        [1376226e-11, 2.04283539351, 65.2203710117],
        [1666902e-11, 3.62744066769, 380.12776796],
        [1284107e-11, 3.11347961505, 202.2533951741],
        [1150429e-11, 0.93343589092, 3.1813937377],
        [1533221e-11, 2.58594681212, 52.6901980395],
        [1281604e-11, 0.54271272721, 222.8603229936],
        [1372139e-11, 4.19641530878, 111.4301614968],
        [1221029e-11, 0.1990065003, 108.4612160802],
        [946181e-11, 1.19253165736, 127.4717966068],
        [1150989e-11, 4.17898916639, 33.6796175129]
      ],
      [
        [74.7815986091, 0, 0],
        [0.00154332863, 5.24158770553, 74.7815985673],
        [24456474e-11, 1.71260334156, 1.4844727083],
        [9258442e-11, 0.4282973235, 11.0457002639],
        [8265977e-11, 1.50218091379, 63.7358983034],
        [915016e-10, 1.41213765216, 149.5631971346]
      ]
    ],
    [
      [
        [0.01346277648, 2.61877810547, 74.7815985673],
        [623414e-9, 5.08111189648, 149.5631971346],
        [61601196e-11, 3.14159265359, 0],
        [9963722e-11, 1.61603805646, 76.2660712756],
        [992616e-10, 0.57630380333, 73.297125859]
      ],
      [
        [34101978e-11, 0.01321929936, 74.7815985673]
      ]
    ],
    [
      [
        [19.21264847206, 0, 0],
        [0.88784984413, 5.60377527014, 74.7815985673],
        [0.03440836062, 0.32836099706, 73.297125859],
        [0.0205565386, 1.7829515933, 149.5631971346],
        [0.0064932241, 4.52247285911, 76.2660712756],
        [0.00602247865, 3.86003823674, 63.7358983034],
        [0.00496404167, 1.40139935333, 454.9093665273],
        [0.00338525369, 1.58002770318, 138.5174968707],
        [0.00243509114, 1.57086606044, 71.8126531507],
        [0.00190522303, 1.99809394714, 1.4844727083],
        [0.00161858838, 2.79137786799, 148.0787244263],
        [0.00143706183, 1.38368544947, 11.0457002639],
        [93192405e-11, 0.17437220467, 36.6485629295],
        [71424548e-11, 4.24509236074, 224.3447957019],
        [89806014e-11, 3.66105364565, 109.9456887885],
        [39009723e-11, 1.66971401684, 70.8494453042],
        [46677296e-11, 1.39976401694, 35.1640902212],
        [39025624e-11, 3.36234773834, 277.0349937414],
        [36755274e-11, 3.88649278513, 146.594251718],
        [30348723e-11, 0.70100838798, 151.0476698429],
        [29156413e-11, 3.180563367, 77.7505439839],
        [22637073e-11, 0.72518687029, 529.6909650946],
        [11959076e-11, 1.7504339214, 984.6003316219],
        [25620756e-11, 5.25656086672, 380.12776796]
      ],
      [
        [0.01479896629, 3.67205697578, 74.7815985673]
      ]
    ]
  ],
  Neptune: [
    [
      [
        [5.31188633046, 0, 0],
        [0.0179847553, 2.9010127389, 38.1330356378],
        [0.01019727652, 0.48580922867, 1.4844727083],
        [0.00124531845, 4.83008090676, 36.6485629295],
        [42064466e-11, 5.41054993053, 2.9689454166],
        [37714584e-11, 6.09221808686, 35.1640902212],
        [33784738e-11, 1.24488874087, 76.2660712756],
        [16482741e-11, 7727998e-11, 491.5579294568],
        [9198584e-11, 4.93747051954, 39.6175083461],
        [899425e-10, 0.27462171806, 175.1660598002]
      ],
      [
        [38.13303563957, 0, 0],
        [16604172e-11, 4.86323329249, 1.4844727083],
        [15744045e-11, 2.27887427527, 38.1330356378]
      ]
    ],
    [
      [
        [0.03088622933, 1.44104372644, 38.1330356378],
        [27780087e-11, 5.91271884599, 76.2660712756],
        [27623609e-11, 0, 0],
        [15355489e-11, 2.52123799551, 36.6485629295],
        [15448133e-11, 3.50877079215, 39.6175083461]
      ]
    ],
    [
      [
        [30.07013205828, 0, 0],
        [0.27062259632, 1.32999459377, 38.1330356378],
        [0.01691764014, 3.25186135653, 36.6485629295],
        [0.00807830553, 5.18592878704, 1.4844727083],
        [0.0053776051, 4.52113935896, 35.1640902212],
        [0.00495725141, 1.5710564165, 491.5579294568],
        [0.00274571975, 1.84552258866, 175.1660598002],
        [1201232e-10, 1.92059384991, 1021.2488945514],
        [0.00121801746, 5.79754470298, 76.2660712756],
        [0.00100896068, 0.3770272493, 73.297125859],
        [0.00135134092, 3.37220609835, 39.6175083461],
        [7571796e-11, 1.07149207335, 388.4651552382]
      ]
    ]
  ]
};
function ei(t) {
  var e, n, a, o, c, u, d;
  const l = 2e3 + (t - 14) / Xr;
  return l < -500 ? (e = (l - 1820) / 100, -20 + 32 * e * e) : l < 500 ? (e = l / 100, n = e * e, a = e * n, o = n * n, c = n * a, u = a * a, 10583.6 - 1014.41 * e + 33.78311 * n - 5.952053 * a - 0.1798452 * o + 0.022174192 * c + 0.0090316521 * u) : l < 1600 ? (e = (l - 1e3) / 100, n = e * e, a = e * n, o = n * n, c = n * a, u = a * a, 1574.2 - 556.01 * e + 71.23472 * n + 0.319781 * a - 0.8503463 * o - 5050998e-9 * c + 0.0083572073 * u) : l < 1700 ? (e = l - 1600, n = e * e, a = e * n, 120 - 0.9808 * e - 0.01532 * n + a / 7129) : l < 1800 ? (e = l - 1700, n = e * e, a = e * n, o = n * n, 8.83 + 0.1603 * e - 59285e-7 * n + 13336e-8 * a - o / 1174e3) : l < 1860 ? (e = l - 1800, n = e * e, a = e * n, o = n * n, c = n * a, u = a * a, d = a * o, 13.72 - 0.332447 * e + 68612e-7 * n + 41116e-7 * a - 37436e-8 * o + 121272e-10 * c - 1699e-10 * u + 875e-12 * d) : l < 1900 ? (e = l - 1860, n = e * e, a = e * n, o = n * n, c = n * a, 7.62 + 0.5737 * e - 0.251754 * n + 0.01680668 * a - 4473624e-10 * o + c / 233174) : l < 1920 ? (e = l - 1900, n = e * e, a = e * n, o = n * n, -2.79 + 1.494119 * e - 0.0598939 * n + 61966e-7 * a - 197e-6 * o) : l < 1941 ? (e = l - 1920, n = e * e, a = e * n, 21.2 + 0.84493 * e - 0.0761 * n + 20936e-7 * a) : l < 1961 ? (e = l - 1950, n = e * e, a = e * n, 29.07 + 0.407 * e - n / 233 + a / 2547) : l < 1986 ? (e = l - 1975, n = e * e, a = e * n, 45.45 + 1.067 * e - n / 260 - a / 718) : l < 2005 ? (e = l - 2e3, n = e * e, a = e * n, o = n * n, c = n * a, 63.86 + 0.3345 * e - 0.060374 * n + 17275e-7 * a + 651814e-9 * o + 2373599e-11 * c) : l < 2050 ? (e = l - 2e3, 62.92 + 0.32217 * e + 5589e-6 * e * e) : l < 2150 ? (e = (l - 1820) / 100, -20 + 32 * e * e - 0.5628 * (2150 - l)) : (e = (l - 1820) / 100, -20 + 32 * e * e);
}
let ni = ei;
function jn(t) {
  return t + ni(t) / 86400;
}
class ie {
  /**
   * @param {FlexibleDateTime} date
   *      A JavaScript Date object, a numeric UTC value expressed in J2000 days, or another AstroTime object.
   */
  constructor(e) {
    if (e instanceof ie) {
      this.date = e.date, this.ut = e.ut, this.tt = e.tt;
      return;
    }
    const n = 1e3 * 3600 * 24;
    if (e instanceof Date && Number.isFinite(e.getTime())) {
      this.date = e, this.ut = (e.getTime() - $n.getTime()) / n, this.tt = jn(this.ut);
      return;
    }
    if (Number.isFinite(e)) {
      this.date = new Date($n.getTime() + e * n), this.ut = e, this.tt = jn(this.ut);
      return;
    }
    throw "Argument must be a Date object, an AstroTime object, or a numeric UTC Julian date.";
  }
  /**
   * @brief Creates an `AstroTime` value from a Terrestrial Time (TT) day value.
   *
   * This function can be used in rare cases where a time must be based
   * on Terrestrial Time (TT) rather than Universal Time (UT).
   * Most developers will want to invoke `new AstroTime(ut)` with a universal time
   * instead of this function, because usually time is based on civil time adjusted
   * by leap seconds to match the Earth's rotation, rather than the uniformly
   * flowing TT used to calculate solar system dynamics. In rare cases
   * where the caller already knows TT, this function is provided to create
   * an `AstroTime` value that can be passed to Astronomy Engine functions.
   *
   * @param {number} tt
   *      The number of days since the J2000 epoch as expressed in Terrestrial Time.
   *
   * @returns {AstroTime}
   *      An `AstroTime` object for the specified terrestrial time.
   */
  static FromTerrestrialTime(e) {
    let n = new ie(e);
    for (; ; ) {
      const a = e - n.tt;
      if (Math.abs(a) < 1e-12)
        return n;
      n = n.AddDays(a);
    }
  }
  /**
   * Formats an `AstroTime` object as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
   * date/time string in UTC, to millisecond resolution.
   * Example: `2018-08-17T17:22:04.050Z`
   * @returns {string}
   */
  toString() {
    return this.date.toISOString();
  }
  /**
   * Returns a new `AstroTime` object adjusted by the floating point number of days.
   * Does NOT modify the original `AstroTime` object.
   *
   * @param {number} days
   *      The floating point number of days by which to adjust the given date and time.
   *      Positive values adjust the date toward the future, and
   *      negative values adjust the date toward the past.
   *
   * @returns {AstroTime}
   */
  AddDays(e) {
    return new ie(this.ut + e);
  }
}
function le(t) {
  return t instanceof ie ? t : new ie(t);
}
function ti(t) {
  function e(I) {
    return I % Yr * he;
  }
  const n = t.tt / 36525, a = e(128710479305e-5 + n * 1295965810481e-4), o = e(335779.526232 + n * 17395272628478e-4), c = e(107226070369e-5 + n * 1602961601209e-3), u = e(450160.398036 - n * 69628905431e-4);
  let d = Math.sin(u), l = Math.cos(u), m = (-172064161 - 174666 * n) * d + 33386 * l, S = (92052331 + 9086 * n) * l + 15377 * d, g = 2 * (o - c + u);
  return d = Math.sin(g), l = Math.cos(g), m += (-13170906 - 1675 * n) * d - 13696 * l, S += (5730336 - 3015 * n) * l - 4587 * d, g = 2 * (o + u), d = Math.sin(g), l = Math.cos(g), m += (-2276413 - 234 * n) * d + 2796 * l, S += (978459 - 485 * n) * l + 1374 * d, g = 2 * u, d = Math.sin(g), l = Math.cos(g), m += (2074554 + 207 * n) * d - 698 * l, S += (-897492 + 470 * n) * l - 291 * d, d = Math.sin(a), l = Math.cos(a), m += (1475877 - 3633 * n) * d + 11817 * l, S += (73871 - 184 * n) * l - 1924 * d, {
    dpsi: -135e-6 + m * 1e-7,
    deps: 388e-6 + S * 1e-7
  };
}
function dt(t) {
  var e = t.tt / 36525, n = ((((-434e-10 * e - 576e-9) * e + 20034e-7) * e - 1831e-7) * e - 46.836769) * e + 84381.406;
  return n / 3600;
}
var ze;
function vt(t) {
  if (!ze || Math.abs(ze.tt - t.tt) > 1e-6) {
    const e = ti(t), n = dt(t), a = n + e.deps / 3600;
    ze = {
      tt: t.tt,
      dpsi: e.dpsi,
      deps: e.deps,
      ee: e.dpsi * Math.cos(n * _e) / 15,
      mobl: n,
      tobl: a
    };
  }
  return ze;
}
function ri(t, e) {
  const n = t * _e, a = Math.cos(n), o = Math.sin(n);
  return [
    e[0],
    e[1] * a - e[2] * o,
    e[1] * o + e[2] * a
  ];
}
function ii(t, e) {
  return ri(dt(t), e);
}
function ai(t) {
  const e = t.tt / 36525;
  function n(z, B) {
    const q = [];
    let e0;
    for (e0 = 0; e0 <= B - z; ++e0)
      q.push(0);
    return { min: z, array: q };
  }
  function a(z, B, q, e0) {
    const a0 = [];
    for (let k0 = 0; k0 <= B - z; ++k0)
      a0.push(n(q, e0));
    return { min: z, array: a0 };
  }
  function o(z, B, q) {
    const e0 = z.array[B - z.min];
    return e0.array[q - e0.min];
  }
  function c(z, B, q, e0) {
    const a0 = z.array[B - z.min];
    a0.array[q - a0.min] = e0;
  }
  let u, d, l, m, S, g, I, D, U, P, H, J, r0, i0, u0, _0, l0, p0, n0, z0, K0, G0, d0, R0 = a(-6, 6, 1, 4), w0 = a(-6, 6, 1, 4);
  function Z0(z, B) {
    return o(R0, z, B);
  }
  function m0(z, B) {
    return o(w0, z, B);
  }
  function W0(z, B, q) {
    return c(R0, z, B, q);
  }
  function X0(z, B, q) {
    return c(w0, z, B, q);
  }
  function J0(z, B, q, e0, a0) {
    a0(z * q - B * e0, B * q + z * e0);
  }
  function b(z) {
    return Math.sin($0 * z);
  }
  I = e * e, U = 0, d0 = 0, H = 0, J = 3422.7;
  var O0 = b(0.19833 + 0.05611 * e), s0 = b(0.27869 + 0.04508 * e), U0 = b(0.16827 - 0.36903 * e), P0 = b(0.34734 - 5.37261 * e), V0 = b(0.10498 - 5.37899 * e), G = b(0.42681 - 0.41855 * e), L0 = b(0.14943 - 5.37511 * e);
  for (p0 = 0.84 * O0 + 0.31 * s0 + 14.27 * U0 + 7.26 * P0 + 0.28 * V0 + 0.24 * G, n0 = 2.94 * O0 + 0.31 * s0 + 14.27 * U0 + 9.34 * P0 + 1.12 * V0 + 0.83 * G, z0 = -6.4 * O0 - 1.89 * G, K0 = 0.21 * O0 + 0.31 * s0 + 14.27 * U0 - 88.7 * P0 - 15.3 * V0 + 0.24 * G - 1.86 * L0, G0 = p0 - z0, D = -3332e-9 * b(0.59734 - 5.37261 * e) - 539e-9 * b(0.35498 - 5.37899 * e) - 64e-9 * b(0.39943 - 5.37511 * e), r0 = $0 * ve(0.60643382 + 1336.85522467 * e - 313e-8 * I) + p0 / ne, i0 = $0 * ve(0.37489701 + 1325.55240982 * e + 2565e-8 * I) + n0 / ne, u0 = $0 * ve(0.99312619 + 99.99735956 * e - 44e-8 * I) + z0 / ne, _0 = $0 * ve(0.25909118 + 1342.2278298 * e - 892e-8 * I) + K0 / ne, l0 = $0 * ve(0.82736186 + 1236.85308708 * e - 397e-8 * I) + G0 / ne, S = 1; S <= 4; ++S) {
    switch (S) {
      case 1:
        l = i0, d = 4, m = 1.000002208;
        break;
      case 2:
        l = u0, d = 3, m = 0.997504612 - 2495388e-9 * e;
        break;
      case 3:
        l = _0, d = 4, m = 1.000002708 + 139.978 * D;
        break;
      case 4:
        l = l0, d = 6, m = 1;
        break;
      default:
        throw `Internal error: I = ${S}`;
    }
    for (W0(0, S, 1), W0(1, S, Math.cos(l) * m), X0(0, S, 0), X0(1, S, Math.sin(l) * m), g = 2; g <= d; ++g)
      J0(Z0(g - 1, S), m0(g - 1, S), Z0(1, S), m0(1, S), (z, B) => (W0(g, S, z), X0(g, S, B)));
    for (g = 1; g <= d; ++g)
      W0(-g, S, Z0(g, S)), X0(-g, S, -m0(g, S));
  }
  function A0(z, B, q, e0) {
    for (var a0 = { x: 1, y: 0 }, k0 = [0, z, B, q, e0], b0 = 1; b0 <= 4; ++b0)
      k0[b0] !== 0 && J0(a0.x, a0.y, Z0(k0[b0], b0), m0(k0[b0], b0), (we, Q0) => (a0.x = we, a0.y = Q0));
    return a0;
  }
  function p(z, B, q, e0, a0, k0, b0, we) {
    var Q0 = A0(a0, k0, b0, we);
    U += z * Q0.y, d0 += B * Q0.y, H += q * Q0.x, J += e0 * Q0.x;
  }
  p(13.902, 14.06, -1e-3, 0.2607, 0, 0, 0, 4), p(0.403, -4.01, 0.394, 23e-4, 0, 0, 0, 3), p(2369.912, 2373.36, 0.601, 28.2333, 0, 0, 0, 2), p(-125.154, -112.79, -0.725, -0.9781, 0, 0, 0, 1), p(1.979, 6.98, -0.445, 0.0433, 1, 0, 0, 4), p(191.953, 192.72, 0.029, 3.0861, 1, 0, 0, 2), p(-8.466, -13.51, 0.455, -0.1093, 1, 0, 0, 1), p(22639.5, 22609.07, 0.079, 186.5398, 1, 0, 0, 0), p(18.609, 3.59, -0.094, 0.0118, 1, 0, 0, -1), p(-4586.465, -4578.13, -0.077, 34.3117, 1, 0, 0, -2), p(3.215, 5.44, 0.192, -0.0386, 1, 0, 0, -3), p(-38.428, -38.64, 1e-3, 0.6008, 1, 0, 0, -4), p(-0.393, -1.43, -0.092, 86e-4, 1, 0, 0, -6), p(-0.289, -1.59, 0.123, -53e-4, 0, 1, 0, 4), p(-24.42, -25.1, 0.04, -0.3, 0, 1, 0, 2), p(18.023, 17.93, 7e-3, 0.1494, 0, 1, 0, 1), p(-668.146, -126.98, -1.302, -0.3997, 0, 1, 0, 0), p(0.56, 0.32, -1e-3, -37e-4, 0, 1, 0, -1), p(-165.145, -165.06, 0.054, 1.9178, 0, 1, 0, -2), p(-1.877, -6.46, -0.416, 0.0339, 0, 1, 0, -4), p(0.213, 1.02, -0.074, 54e-4, 2, 0, 0, 4), p(14.387, 14.78, -0.017, 0.2833, 2, 0, 0, 2), p(-0.586, -1.2, 0.054, -0.01, 2, 0, 0, 1), p(769.016, 767.96, 0.107, 10.1657, 2, 0, 0, 0), p(1.75, 2.01, -0.018, 0.0155, 2, 0, 0, -1), p(-211.656, -152.53, 5.679, -0.3039, 2, 0, 0, -2), p(1.225, 0.91, -0.03, -88e-4, 2, 0, 0, -3), p(-30.773, -34.07, -0.308, 0.3722, 2, 0, 0, -4), p(-0.57, -1.4, -0.074, 0.0109, 2, 0, 0, -6), p(-2.921, -11.75, 0.787, -0.0484, 1, 1, 0, 2), p(1.267, 1.52, -0.022, 0.0164, 1, 1, 0, 1), p(-109.673, -115.18, 0.461, -0.949, 1, 1, 0, 0), p(-205.962, -182.36, 2.056, 1.4437, 1, 1, 0, -2), p(0.233, 0.36, 0.012, -25e-4, 1, 1, 0, -3), p(-4.391, -9.66, -0.471, 0.0673, 1, 1, 0, -4), p(0.283, 1.53, -0.111, 6e-3, 1, -1, 0, 4), p(14.577, 31.7, -1.54, 0.2302, 1, -1, 0, 2), p(147.687, 138.76, 0.679, 1.1528, 1, -1, 0, 0), p(-1.089, 0.55, 0.021, 0, 1, -1, 0, -1), p(28.475, 23.59, -0.443, -0.2257, 1, -1, 0, -2), p(-0.276, -0.38, -6e-3, -36e-4, 1, -1, 0, -3), p(0.636, 2.27, 0.146, -0.0102, 1, -1, 0, -4), p(-0.189, -1.68, 0.131, -28e-4, 0, 2, 0, 2), p(-7.486, -0.66, -0.037, -86e-4, 0, 2, 0, 0), p(-8.096, -16.35, -0.74, 0.0918, 0, 2, 0, -2), p(-5.741, -0.04, 0, -9e-4, 0, 0, 2, 2), p(0.255, 0, 0, 0, 0, 0, 2, 1), p(-411.608, -0.2, 0, -0.0124, 0, 0, 2, 0), p(0.584, 0.84, 0, 71e-4, 0, 0, 2, -1), p(-55.173, -52.14, 0, -0.1052, 0, 0, 2, -2), p(0.254, 0.25, 0, -17e-4, 0, 0, 2, -3), p(0.025, -1.67, 0, 31e-4, 0, 0, 2, -4), p(1.06, 2.96, -0.166, 0.0243, 3, 0, 0, 2), p(36.124, 50.64, -1.3, 0.6215, 3, 0, 0, 0), p(-13.193, -16.4, 0.258, -0.1187, 3, 0, 0, -2), p(-1.187, -0.74, 0.042, 74e-4, 3, 0, 0, -4), p(-0.293, -0.31, -2e-3, 46e-4, 3, 0, 0, -6), p(-0.29, -1.45, 0.116, -51e-4, 2, 1, 0, 2), p(-7.649, -10.56, 0.259, -0.1038, 2, 1, 0, 0), p(-8.627, -7.59, 0.078, -0.0192, 2, 1, 0, -2), p(-2.74, -2.54, 0.022, 0.0324, 2, 1, 0, -4), p(1.181, 3.32, -0.212, 0.0213, 2, -1, 0, 2), p(9.703, 11.67, -0.151, 0.1268, 2, -1, 0, 0), p(-0.352, -0.37, 1e-3, -28e-4, 2, -1, 0, -1), p(-2.494, -1.17, -3e-3, -17e-4, 2, -1, 0, -2), p(0.36, 0.2, -0.012, -43e-4, 2, -1, 0, -4), p(-1.167, -1.25, 8e-3, -0.0106, 1, 2, 0, 0), p(-7.412, -6.12, 0.117, 0.0484, 1, 2, 0, -2), p(-0.311, -0.65, -0.032, 44e-4, 1, 2, 0, -4), p(0.757, 1.82, -0.105, 0.0112, 1, -2, 0, 2), p(2.58, 2.32, 0.027, 0.0196, 1, -2, 0, 0), p(2.533, 2.4, -0.014, -0.0212, 1, -2, 0, -2), p(-0.344, -0.57, -0.025, 36e-4, 0, 3, 0, -2), p(-0.992, -0.02, 0, 0, 1, 0, 2, 2), p(-45.099, -0.02, 0, -1e-3, 1, 0, 2, 0), p(-0.179, -9.52, 0, -0.0833, 1, 0, 2, -2), p(-0.301, -0.33, 0, 14e-4, 1, 0, 2, -4), p(-6.382, -3.37, 0, -0.0481, 1, 0, -2, 2), p(39.528, 85.13, 0, -0.7136, 1, 0, -2, 0), p(9.366, 0.71, 0, -0.0112, 1, 0, -2, -2), p(0.202, 0.02, 0, 0, 1, 0, -2, -4), p(0.415, 0.1, 0, 13e-4, 0, 1, 2, 0), p(-2.152, -2.26, 0, -66e-4, 0, 1, 2, -2), p(-1.44, -1.3, 0, 14e-4, 0, 1, -2, 2), p(0.384, -0.04, 0, 0, 0, 1, -2, -2), p(1.938, 3.6, -0.145, 0.0401, 4, 0, 0, 0), p(-0.952, -1.58, 0.052, -0.013, 4, 0, 0, -2), p(-0.551, -0.94, 0.032, -97e-4, 3, 1, 0, 0), p(-0.482, -0.57, 5e-3, -45e-4, 3, 1, 0, -2), p(0.681, 0.96, -0.026, 0.0115, 3, -1, 0, 0), p(-0.297, -0.27, 2e-3, -9e-4, 2, 2, 0, -2), p(0.254, 0.21, -3e-3, 0, 2, -2, 0, -2), p(-0.25, -0.22, 4e-3, 14e-4, 1, 3, 0, -2), p(-3.996, 0, 0, 4e-4, 2, 0, 2, 0), p(0.557, -0.75, 0, -9e-3, 2, 0, 2, -2), p(-0.459, -0.38, 0, -53e-4, 2, 0, -2, 2), p(-1.298, 0.74, 0, 4e-4, 2, 0, -2, 0), p(0.538, 1.14, 0, -0.0141, 2, 0, -2, -2), p(0.263, 0.02, 0, 0, 1, 1, 2, 0), p(0.426, 0.07, 0, -6e-4, 1, 1, -2, -2), p(-0.304, 0.03, 0, 3e-4, 1, -1, 2, 0), p(-0.372, -0.19, 0, -27e-4, 1, -1, -2, 2), p(0.418, 0, 0, 0, 0, 0, 4, 0), p(-0.33, -0.04, 0, 0, 3, 0, 2, 0);
  function C0(z, B, q, e0, a0) {
    return z * A0(B, q, e0, a0).y;
  }
  P = 0, P += C0(-526.069, 0, 0, 1, -2), P += C0(-3.352, 0, 0, 1, -4), P += C0(44.297, 1, 0, 1, -2), P += C0(-6, 1, 0, 1, -4), P += C0(20.599, -1, 0, 1, 0), P += C0(-30.598, -1, 0, 1, -2), P += C0(-24.649, -2, 0, 1, 0), P += C0(-2, -2, 0, 1, -2), P += C0(-22.571, 0, 1, 1, -2), P += C0(10.985, 0, -1, 1, -2), U += 0.82 * b(0.7736 - 62.5512 * e) + 0.31 * b(0.0466 - 125.1025 * e) + 0.35 * b(0.5785 - 25.1042 * e) + 0.66 * b(0.4591 + 1335.8075 * e) + 0.64 * b(0.313 - 91.568 * e) + 1.14 * b(0.148 + 1331.2898 * e) + 0.21 * b(0.5918 + 1056.5859 * e) + 0.44 * b(0.5784 + 1322.8595 * e) + 0.24 * b(0.2275 - 5.7374 * e) + 0.28 * b(0.2965 + 2.6929 * e) + 0.33 * b(0.3132 + 6.3368 * e), u = _0 + d0 / ne;
  let be = (1.000002708 + 139.978 * D) * (18518.511 + 1.189 + H) * Math.sin(u) - 6.24 * Math.sin(3 * u) + P;
  return {
    geo_eclip_lon: $0 * ve((r0 + U / ne) / $0),
    geo_eclip_lat: Math.PI / (180 * 3600) * be,
    distance_au: ne * jr / (0.999953253 * J)
  };
}
function oi(t, e) {
  return [
    t.rot[0][0] * e[0] + t.rot[1][0] * e[1] + t.rot[2][0] * e[2],
    t.rot[0][1] * e[0] + t.rot[1][1] * e[1] + t.rot[2][1] * e[2],
    t.rot[0][2] * e[0] + t.rot[1][2] * e[1] + t.rot[2][2] * e[2]
  ];
}
function si(t, e, n) {
  const a = ht(e, n);
  return oi(a, t);
}
function ht(t, e) {
  const n = t.tt / 36525;
  let a = 84381.406, o = ((((-951e-10 * n + 132851e-9) * n - 114045e-8) * n - 1.0790069) * n + 5038.481507) * n, c = ((((3337e-10 * n - 467e-9) * n - 772503e-8) * n + 0.0512623) * n - 0.025754) * n + a, u = ((((-56e-9 * n + 170663e-9) * n - 121197e-8) * n - 2.3814292) * n + 10.556403) * n;
  a *= he, o *= he, c *= he, u *= he;
  const d = Math.sin(a), l = Math.cos(a), m = Math.sin(-o), S = Math.cos(-o), g = Math.sin(-c), I = Math.cos(-c), D = Math.sin(u), U = Math.cos(u), P = U * S - m * D * I, H = U * m * l + D * I * S * l - d * D * g, J = U * m * d + D * I * S * d + l * D * g, r0 = -D * S - m * U * I, i0 = -D * m * l + U * I * S * l - d * U * g, u0 = -D * m * d + U * I * S * d + l * U * g, _0 = m * g, l0 = -g * S * l - d * I, p0 = -g * S * d + I * l;
  if (e === q0.Into2000)
    return new ge([
      [P, H, J],
      [r0, i0, u0],
      [_0, l0, p0]
    ]);
  if (e === q0.From2000)
    return new ge([
      [P, r0, _0],
      [H, i0, l0],
      [J, u0, p0]
    ]);
  throw "Invalid precess direction";
}
function ci(t) {
  const e = 0.779057273264 + 0.00273781191135448 * t.ut, n = t.ut % 1;
  let a = 360 * ((e + n) % 1);
  return a < 0 && (a += 360), a;
}
let Ge;
function ui(t) {
  if (!Ge || Ge.tt !== t.tt) {
    const e = t.tt / 36525;
    let n = 15 * vt(t).ee;
    const a = ci(t);
    let c = ((n + 0.014506 + ((((-368e-10 * e - 29956e-9) * e - 44e-8) * e + 1.3915817) * e + 4612.156534) * e) / 3600 + a) % 360 / 15;
    c < 0 && (c += 24), Ge = {
      tt: t.tt,
      st: c
    };
  }
  return Ge.st;
}
function li(t) {
  const e = le(t);
  return ui(e);
}
function di(t, e) {
  const n = vt(t), a = n.mobl * _e, o = n.tobl * _e, c = n.dpsi * he, u = Math.cos(a), d = Math.sin(a), l = Math.cos(o), m = Math.sin(o), S = Math.cos(c), g = Math.sin(c), I = S, D = -g * u, U = -g * d, P = g * l, H = S * u * l + d * m, J = S * d * l - u * m, r0 = g * m, i0 = S * u * m - d * l, u0 = S * d * m + u * l;
  if (e === q0.From2000)
    return new ge([
      [I, P, r0],
      [D, H, i0],
      [U, J, u0]
    ]);
  if (e === q0.Into2000)
    return new ge([
      [I, D, U],
      [P, H, J],
      [r0, i0, u0]
    ]);
  throw "Invalid precess direction";
}
class H0 {
  constructor(e, n, a, o) {
    this.x = e, this.y = n, this.z = a, this.t = o;
  }
  /**
   * Returns the length of the vector in astronomical units (AU).
   * @returns {number}
   */
  Length() {
    return Math.hypot(this.x, this.y, this.z);
  }
}
class vi {
  constructor(e, n, a, o, c, u, d) {
    this.x = e, this.y = n, this.z = a, this.vx = o, this.vy = c, this.vz = u, this.t = d;
  }
}
class hi {
  constructor(e, n, a) {
    this.lat = sn(e), this.lon = sn(n), this.dist = sn(a);
  }
}
class ge {
  constructor(e) {
    this.rot = e;
  }
}
function En(t) {
  const e = le(t), n = ai(e), a = n.distance_au * Math.cos(n.geo_eclip_lat), o = [
    a * Math.cos(n.geo_eclip_lon),
    a * Math.sin(n.geo_eclip_lon),
    n.distance_au * Math.sin(n.geo_eclip_lat)
  ], c = ii(e, o), u = si(c, e, q0.Into2000);
  return new H0(u[0], u[1], u[2], e);
}
function me(t, e, n) {
  let a = 1, o = 0;
  for (let c of t) {
    let u = 0;
    for (let [l, m, S] of c)
      u += l * Math.cos(m + e * S);
    let d = a * u;
    n && (d %= $0), o += d, a *= e;
  }
  return o;
}
function cn(t, e) {
  let n = 1, a = 0, o = 0, c = 0;
  for (let u of t) {
    let d = 0, l = 0;
    for (let [m, S, g] of u) {
      let I = S + e * g;
      d += m * g * Math.sin(I), c > 0 && (l += m * Math.cos(I));
    }
    o += c * a * l - n * d, a = n, n *= e, ++c;
  }
  return o;
}
const Me = 365250, _n = 0, gn = 1, wn = 2;
function Tn(t) {
  return new f0(t[0] + 44036e-11 * t[1] - 190919e-12 * t[2], -479966e-12 * t[0] + 0.917482137087 * t[1] - 0.397776982902 * t[2], 0.397776982902 * t[1] + 0.917482137087 * t[2]);
}
function ft(t, e, n) {
  const a = n * Math.cos(e), o = Math.cos(t), c = Math.sin(t);
  return [
    a * o,
    a * c,
    n * Math.sin(e)
  ];
}
function Xe(t, e) {
  const n = e.tt / Me, a = me(t[_n], n, !0), o = me(t[gn], n, !1), c = me(t[wn], n, !1), u = ft(a, o, c);
  return Tn(u).ToAstroVector(e);
}
function fi(t, e) {
  const n = e / Me, a = me(t[_n], n, !0), o = me(t[gn], n, !1), c = me(t[wn], n, !1), u = cn(t[_n], n), d = cn(t[gn], n), l = cn(t[wn], n), m = Math.cos(a), S = Math.sin(a), g = Math.cos(o), I = Math.sin(o), D = +(l * g * m) - c * I * m * d - c * g * S * u, U = +(l * g * S) - c * I * S * d + c * g * m * u, P = +(l * I) + c * g * d, H = ft(a, o, c), J = [
    D / Me,
    U / Me,
    P / Me
  ], r0 = Tn(H), i0 = Tn(J);
  return new ue(e, r0, i0);
}
function ke(t, e, n, a) {
  const o = a / (a + bn), c = Xe(fe[n], e);
  t.x += o * c.x, t.y += o * c.y, t.z += o * c.z;
}
function pi(t) {
  const e = new H0(0, 0, 0, t);
  return ke(e, t, k.Jupiter, fn), ke(e, t, k.Saturn, pn), ke(e, t, k.Uranus, mn), ke(e, t, k.Neptune, Sn), e;
}
const Rn = 51, mi = 29200, Ye = 146, j0 = 201, se = [
  [-73e4, [-26.118207232108, -14.376168177825, 3.384402515299], [0.0016339372163656, -0.0027861699588508, -0.0013585880229445]],
  [-700800, [41.974905202127, -0.448502952929, -12.770351505989], [73458569351457e-17, 0.0022785014891658, 48619778602049e-17]],
  [-671600, [14.706930780744, 44.269110540027, 9.353698474772], [-0.00210001479998, 22295915939915e-17, 70143443551414e-17]],
  [-642400, [-29.441003929957, -6.43016153057, 6.858481011305], [84495803960544e-17, -0.0030783914758711, -0.0012106305981192]],
  [-613200, [39.444396946234, -6.557989760571, -13.913760296463], [0.0011480029005873, 0.0022400006880665, 35168075922288e-17]],
  [-584e3, [20.2303809507, 43.266966657189, 7.382966091923], [-0.0019754081700585, 53457141292226e-17, 75929169129793e-17]],
  [-554800, [-30.65832536462, 2.093818874552, 9.880531138071], [61010603013347e-18, -0.0031326500935382, -99346125151067e-17]],
  [-525600, [35.737703251673, -12.587706024764, -14.677847247563], [0.0015802939375649, 0.0021347678412429, 19074436384343e-17]],
  [-496400, [25.466295188546, 41.367478338417, 5.216476873382], [-0.0018054401046468, 8328308359951e-16, 80260156912107e-17]],
  [-467200, [-29.847174904071, 10.636426313081, 12.297904180106], [-63257063052907e-17, -0.0029969577578221, -74476074151596e-17]],
  [-438e3, [30.774692107687, -18.236637015304, -14.945535879896], [0.0020113162005465, 0.0019353827024189, -20937793168297e-19]],
  [-408800, [30.243153324028, 38.656267888503, 2.938501750218], [-0.0016052508674468, 0.0011183495337525, 83333973416824e-17]],
  [-379600, [-27.288984772533, 18.643162147874, 14.023633623329], [-0.0011856388898191, -0.0027170609282181, -49015526126399e-17]],
  [-350400, [24.519605196774, -23.245756064727, -14.626862367368], [0.0024322321483154, 0.0016062008146048, -23369181613312e-17]],
  [-321200, [34.505274805875, 35.125338586954, 0.557361475637], [-0.0013824391637782, 0.0013833397561817, 84823598806262e-17]],
  [-292e3, [-23.275363915119, 25.818514298769, 15.055381588598], [-0.0016062295460975, -0.0023395961498533, -24377362639479e-17]],
  [-262800, [17.050384798092, -27.180376290126, -13.608963321694], [0.0028175521080578, 0.0011358749093955, -49548725258825e-17]],
  [-233600, [38.093671910285, 30.880588383337, -1.843688067413], [-0.0011317697153459, 0.0016128814698472, 84177586176055e-17]],
  [-204400, [-18.197852930878, 31.932869934309, 15.438294826279], [-0.0019117272501813, -0.0019146495909842, -19657304369835e-18]],
  [-175200, [8.528924039997, -29.618422200048, -11.805400994258], [0.0031034370787005, 5139363329243e-16, -77293066202546e-17]],
  [-146e3, [40.94685725864, 25.904973592021, -4.256336240499], [-83652705194051e-17, 0.0018129497136404, 8156422827306e-16]],
  [-116800, [-12.326958895325, 36.881883446292, 15.217158258711], [-0.0021166103705038, -0.001481442003599, 17401209844705e-17]],
  [-87600, [-0.633258375909, -30.018759794709, -9.17193287495], [0.0032016994581737, -25279858672148e-17, -0.0010411088271861]],
  [-58400, [42.936048423883, 20.344685584452, -6.588027007912], [-50525450073192e-17, 0.0019910074335507, 77440196540269e-17]],
  [-29200, [-5.975910552974, 40.61180995846, 14.470131723673], [-0.0022184202156107, -0.0010562361130164, 33652250216211e-17]],
  [0, [-9.875369580774, -27.978926224737, -5.753711824704], [0.0030287533248818, -0.0011276087003636, -0.0012651326732361]],
  [29200, [43.958831986165, 14.214147973292, -8.808306227163], [-14717608981871e-17, 0.0021404187242141, 71486567806614e-17]],
  [58400, [0.67813676352, 43.094461639362, 13.243238780721], [-0.0022358226110718, -63233636090933e-17, 47664798895648e-17]],
  [87600, [-18.282602096834, -23.30503958666, -1.766620508028], [0.0025567245263557, -0.0019902940754171, -0.0013943491701082]],
  [116800, [43.873338744526, 7.700705617215, -10.814273666425], [23174803055677e-17, 0.0022402163127924, 62988756452032e-17]],
  [146e3, [7.392949027906, 44.382678951534, 11.629500214854], [-0.002193281545383, -21751799585364e-17, 59556516201114e-17]],
  [175200, [-24.981690229261, -16.204012851426, 2.466457544298], [0.001819398914958, -0.0026765419531201, -0.0013848283502247]],
  [204400, [42.530187039511, 0.845935508021, -12.554907527683], [65059779150669e-17, 0.0022725657282262, 51133743202822e-17]],
  [233600, [13.999526486822, 44.462363044894, 9.669418486465], [-0.0021079296569252, 17533423831993e-17, 69128485798076e-17]],
  [262800, [-29.184024803031, -7.371243995762, 6.493275957928], [93581363109681e-17, -0.0030610357109184, -0.0012364201089345]],
  [292e3, [39.831980671753, -6.078405766765, -13.909815358656], [0.0011117769689167, 0.0022362097830152, 36230548231153e-17]],
  [321200, [20.294955108476, 43.417190420251, 7.450091985932], [-0.0019742157451535, 53102050468554e-17, 75938408813008e-17]],
  [350400, [-30.66999230216, 2.318743558955, 9.973480913858], [45605107450676e-18, -0.0031308219926928, -99066533301924e-17]],
  [379600, [35.626122155983, -12.897647509224, -14.777586508444], [0.0016015684949743, 0.0021171931182284, 18002516202204e-17]],
  [408800, [26.133186148561, 41.232139187599, 5.00640132622], [-0.0017857704419579, 86046232702817e-17, 80614690298954e-17]],
  [438e3, [-29.57674022923, 11.863535943587, 12.631323039872], [-72292830060955e-17, -0.0029587820140709, -708242964503e-15]],
  [467200, [29.910805787391, -19.159019294, -15.013363865194], [0.0020871080437997, 0.0018848372554514, -38528655083926e-18]],
  [496400, [31.375957451819, 38.050372720763, 2.433138343754], [-0.0015546055556611, 0.0011699815465629, 83565439266001e-17]],
  [525600, [-26.360071336928, 20.662505904952, 14.414696258958], [-0.0013142373118349, -0.0026236647854842, -42542017598193e-17]],
  [554800, [22.599441488648, -24.508879898306, -14.484045731468], [0.0025454108304806, 0.0014917058755191, -30243665086079e-17]],
  [584e3, [35.877864013014, 33.894226366071, -0.224524636277], [-0.0012941245730845, 0.0014560427668319, 84762160640137e-17]],
  [613200, [-21.538149762417, 28.204068269761, 15.321973799534], [-0.001731211740901, -0.0021939631314577, -1631691327518e-16]],
  [642400, [13.971521374415, -28.339941764789, -13.083792871886], [0.0029334630526035, 91860931752944e-17, -59939422488627e-17]],
  [671600, [39.526942044143, 28.93989736011, -2.872799527539], [-0.0010068481658095, 0.001702113288809, 83578230511981e-17]],
  [700800, [-15.576200701394, 34.399412961275, 15.466033737854], [-0.0020098814612884, -0.0017191109825989, 70414782780416e-18]],
  [73e4, [4.24325283709, -30.118201690825, -10.707441231349], [0.0031725847067411, 1609846120227e-16, -90672150593868e-17]]
];
class f0 {
  constructor(e, n, a) {
    this.x = e, this.y = n, this.z = a;
  }
  clone() {
    return new f0(this.x, this.y, this.z);
  }
  ToAstroVector(e) {
    return new H0(this.x, this.y, this.z, e);
  }
  static zero() {
    return new f0(0, 0, 0);
  }
  quadrature() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  add(e) {
    return new f0(this.x + e.x, this.y + e.y, this.z + e.z);
  }
  sub(e) {
    return new f0(this.x - e.x, this.y - e.y, this.z - e.z);
  }
  incr(e) {
    this.x += e.x, this.y += e.y, this.z += e.z;
  }
  decr(e) {
    this.x -= e.x, this.y -= e.y, this.z -= e.z;
  }
  mul(e) {
    return new f0(e * this.x, e * this.y, e * this.z);
  }
  div(e) {
    return new f0(this.x / e, this.y / e, this.z / e);
  }
  mean(e) {
    return new f0((this.x + e.x) / 2, (this.y + e.y) / 2, (this.z + e.z) / 2);
  }
  neg() {
    return new f0(-this.x, -this.y, -this.z);
  }
}
class ue {
  constructor(e, n, a) {
    this.tt = e, this.r = n, this.v = a;
  }
  clone() {
    return new ue(this.tt, this.r, this.v);
  }
  sub(e) {
    return new ue(this.tt, this.r.sub(e.r), this.v.sub(e.v));
  }
}
function Si(t) {
  let [e, [n, a, o], [c, u, d]] = t;
  return new ue(e, new f0(n, a, o), new f0(c, u, d));
}
function Be(t, e, n, a) {
  const o = a / (a + bn), c = fi(fe[n], e);
  return t.r.incr(c.r.mul(o)), t.v.incr(c.v.mul(o)), c;
}
function Ie(t, e, n) {
  const a = n.sub(t), o = a.quadrature();
  return a.mul(e / (o * Math.sqrt(o)));
}
class Fn {
  constructor(e) {
    let n = new ue(e, new f0(0, 0, 0), new f0(0, 0, 0));
    this.Jupiter = Be(n, e, k.Jupiter, fn), this.Saturn = Be(n, e, k.Saturn, pn), this.Uranus = Be(n, e, k.Uranus, mn), this.Neptune = Be(n, e, k.Neptune, Sn), this.Jupiter.r.decr(n.r), this.Jupiter.v.decr(n.v), this.Saturn.r.decr(n.r), this.Saturn.v.decr(n.v), this.Uranus.r.decr(n.r), this.Uranus.v.decr(n.v), this.Neptune.r.decr(n.r), this.Neptune.v.decr(n.v), this.Sun = new ue(e, n.r.mul(-1), n.v.mul(-1));
  }
  Acceleration(e) {
    let n = Ie(e, bn, this.Sun.r);
    return n.incr(Ie(e, fn, this.Jupiter.r)), n.incr(Ie(e, pn, this.Saturn.r)), n.incr(Ie(e, mn, this.Uranus.r)), n.incr(Ie(e, Sn, this.Neptune.r)), n;
  }
}
class tn {
  constructor(e, n, a, o) {
    this.tt = e, this.r = n, this.v = a, this.a = o;
  }
  clone() {
    return new tn(this.tt, this.r.clone(), this.v.clone(), this.a.clone());
  }
}
class pt {
  constructor(e, n) {
    this.bary = e, this.grav = n;
  }
}
function $e(t, e, n, a) {
  return new f0(e.x + t * (n.x + t * a.x / 2), e.y + t * (n.y + t * a.y / 2), e.z + t * (n.z + t * a.z / 2));
}
function qn(t, e, n) {
  return new f0(e.x + t * n.x, e.y + t * n.y, e.z + t * n.z);
}
function An(t, e) {
  const n = t - e.tt, a = new Fn(t), o = $e(n, e.r, e.v, e.a), c = a.Acceleration(o).mean(e.a), u = $e(n, e.r, e.v, c), d = e.v.add(c.mul(n)), l = a.Acceleration(u), m = new tn(t, u, d, l);
  return new pt(a, m);
}
const Ei = [];
function mt(t, e) {
  const n = Math.floor(t);
  return n < 0 ? 0 : n >= e ? e - 1 : n;
}
function Cn(t) {
  const e = Si(t), n = new Fn(e.tt), a = e.r.add(n.Sun.r), o = e.v.add(n.Sun.v), c = n.Acceleration(a), u = new tn(e.tt, a, o, c);
  return new pt(n, u);
}
function _i(t, e) {
  const n = se[0][0];
  if (e < n || e > se[Rn - 1][0])
    return null;
  const a = mt((e - n) / mi, Rn - 1);
  if (!t[a]) {
    const c = t[a] = [];
    c[0] = Cn(se[a]).grav, c[j0 - 1] = Cn(se[a + 1]).grav;
    let u, d = c[0].tt;
    for (u = 1; u < j0 - 1; ++u)
      c[u] = An(d += Ye, c[u - 1]).grav;
    d = c[j0 - 1].tt;
    var o = [];
    for (o[j0 - 1] = c[j0 - 1], u = j0 - 2; u > 0; --u)
      o[u] = An(d -= Ye, o[u + 1]).grav;
    for (u = j0 - 2; u > 0; --u) {
      const l = u / (j0 - 1);
      c[u].r = c[u].r.mul(1 - l).add(o[u].r.mul(l)), c[u].v = c[u].v.mul(1 - l).add(o[u].v.mul(l)), c[u].a = c[u].a.mul(1 - l).add(o[u].a.mul(l));
    }
  }
  return t[a];
}
function Kn(t, e, n) {
  let a = Cn(t);
  const o = Math.ceil((e - a.grav.tt) / n);
  for (let c = 0; c < o; ++c)
    a = An(c + 1 === o ? e : a.grav.tt + n, a.grav);
  return a;
}
function gi(t, e) {
  let n, a, o;
  const c = _i(Ei, t.tt);
  if (c) {
    const u = mt((t.tt - c[0].tt) / Ye, j0 - 1), d = c[u], l = c[u + 1], m = d.a.mean(l.a), S = $e(t.tt - d.tt, d.r, d.v, m), g = qn(t.tt - d.tt, d.v, m), I = $e(t.tt - l.tt, l.r, l.v, m), D = qn(t.tt - l.tt, l.v, m), U = (t.tt - d.tt) / Ye;
    n = S.mul(1 - U).add(I.mul(U)), a = g.mul(1 - U).add(D.mul(U));
  } else {
    let u;
    t.tt < se[0][0] ? u = Kn(se[0], t.tt, -146) : u = Kn(se[Rn - 1], t.tt, 146), n = u.grav.r, a = u.grav.v, o = u.bary;
  }
  return o || (o = new Fn(t.tt)), n = n.sub(o.Sun.r), a = a.sub(o.Sun.v), new vi(n.x, n.y, n.z, a.x, a.y, a.z, t);
}
function Ne(t, e) {
  var n = le(e);
  if (t in fe)
    return Xe(fe[t], n);
  if (t === k.Pluto) {
    const u = gi(n);
    return new H0(u.x, u.y, u.z, n);
  }
  if (t === k.Sun)
    return new H0(0, 0, 0, n);
  if (t === k.Moon) {
    var a = Xe(fe.Earth, n), o = En(n);
    return new H0(a.x + o.x, a.y + o.y, a.z + o.z, n);
  }
  if (t === k.EMB) {
    const u = Xe(fe.Earth, n), d = En(n), l = 1 + qr;
    return new H0(u.x + d.x / l, u.y + d.y / l, u.z + d.z / l, n);
  }
  if (t === k.SSB)
    return pi(n);
  const c = lt(t);
  if (c) {
    const u = new hi(c.dec, 15 * c.ra, c.dist);
    return Ci(u, n);
  }
  throw `HelioVector: Unknown body "${t}"`;
}
function wi(t, e) {
  let n = e, a = 0;
  for (let o = 0; o < 10; ++o) {
    const c = t(n), u = c.Length() / Zr;
    if (u > 1)
      throw "Object is too distant for light-travel solver.";
    const d = e.AddDays(-u);
    if (a = Math.abs(d.tt - n.tt), a < 1e-9)
      return c;
    n = d;
  }
  throw `Light-travel time solver did not converge: dt = ${a}`;
}
class Ti {
  constructor(e, n, a, o) {
    this.observerBody = e, this.targetBody = n, this.aberration = a, this.observerPos = o;
  }
  Position(e) {
    this.aberration && (this.observerPos = Ne(this.observerBody, e));
    const n = Ne(this.targetBody, e);
    return new H0(n.x - this.observerPos.x, n.y - this.observerPos.y, n.z - this.observerPos.z, e);
  }
}
function Ri(t, e, n, a) {
  const o = le(t);
  if (lt(n)) {
    const d = Ne(n, o), l = Ne(e, o);
    return new H0(d.x - l.x, d.y - l.y, d.z - l.z, o);
  }
  let c;
  c = Ne(e, o);
  const u = new Ti(e, n, a, c);
  return wi((d) => u.Position(d), o);
}
function Ai(t, e, n) {
  const a = le(e);
  switch (t) {
    case k.Earth:
      return new H0(0, 0, 0, a);
    case k.Moon:
      return En(a);
    default:
      const o = Ri(a, k.Earth, t, n);
      return o.t = a, o;
  }
}
var Jn;
(function(t) {
  t[t.Pericenter = 0] = "Pericenter", t[t.Apocenter = 1] = "Apocenter";
})(Jn || (Jn = {}));
function St(t, e) {
  return new ge([
    [
      e.rot[0][0] * t.rot[0][0] + e.rot[1][0] * t.rot[0][1] + e.rot[2][0] * t.rot[0][2],
      e.rot[0][1] * t.rot[0][0] + e.rot[1][1] * t.rot[0][1] + e.rot[2][1] * t.rot[0][2],
      e.rot[0][2] * t.rot[0][0] + e.rot[1][2] * t.rot[0][1] + e.rot[2][2] * t.rot[0][2]
    ],
    [
      e.rot[0][0] * t.rot[1][0] + e.rot[1][0] * t.rot[1][1] + e.rot[2][0] * t.rot[1][2],
      e.rot[0][1] * t.rot[1][0] + e.rot[1][1] * t.rot[1][1] + e.rot[2][1] * t.rot[1][2],
      e.rot[0][2] * t.rot[1][0] + e.rot[1][2] * t.rot[1][1] + e.rot[2][2] * t.rot[1][2]
    ],
    [
      e.rot[0][0] * t.rot[2][0] + e.rot[1][0] * t.rot[2][1] + e.rot[2][0] * t.rot[2][2],
      e.rot[0][1] * t.rot[2][0] + e.rot[1][1] * t.rot[2][1] + e.rot[2][1] * t.rot[2][2],
      e.rot[0][2] * t.rot[2][0] + e.rot[1][2] * t.rot[2][1] + e.rot[2][2] * t.rot[2][2]
    ]
  ]);
}
function Ci(t, e) {
  e = le(e);
  const n = t.lat * _e, a = t.lon * _e, o = t.dist * Math.cos(n);
  return new H0(o * Math.cos(a), o * Math.sin(a), t.dist * Math.sin(n), e);
}
function yi(t) {
  t = le(t);
  const e = ht(t, q0.From2000), n = di(t, q0.From2000);
  return St(e, n);
}
var Qn;
(function(t) {
  t.Penumbral = "penumbral", t.Partial = "partial", t.Annular = "annular", t.Total = "total";
})(Qn || (Qn = {}));
var et;
(function(t) {
  t[t.Invalid = 0] = "Invalid", t[t.Ascending = 1] = "Ascending", t[t.Descending = -1] = "Descending";
})(et || (et = {}));
const Ii = /* @__PURE__ */ new t0();
function xi(t) {
  const e = Math.cos(t), n = Math.sin(t);
  return new ge([
    [e, -n, 0],
    [n, e, 0],
    [0, 0, 1]
  ]);
}
function Pe(t) {
  return t instanceof ie ? t : new ie(t instanceof Date ? t : new Date(t));
}
function Mi(t, e = new t0()) {
  const n = Pe(t), a = yi(n), o = xi(li(n) * (-Math.PI / 12)), { rot: c } = St(a, o);
  return e.set(
    c[0][0],
    c[0][1],
    c[0][2],
    0,
    c[1][0],
    c[1][1],
    c[1][2],
    0,
    c[2][0],
    c[2][1],
    c[2][2],
    0,
    0,
    0,
    0,
    1
  );
}
function Hn(t, e, n) {
  const { x: a, y: o, z: c } = Ai(t, e, !1);
  return n.set(a, o, c).normalize();
}
function Et(t, e, n) {
  const a = Mi(e, Ii);
  return Hn(t, e, n).applyMatrix4(a);
}
function D1(t, e = new O()) {
  return Hn(k.Sun, Pe(t), e);
}
function N1(t, e = new O()) {
  return Hn(k.Moon, Pe(t), e);
}
function O1(t, e = new O()) {
  return Et(k.Sun, Pe(t), e);
}
function U1(t, e = new O()) {
  return Et(k.Moon, Pe(t), e);
}
function _t(t) {
  return Math.sqrt(Math.max(t, 0));
}
function Di(t) {
  return Math.max(t, 0);
}
function Ni(t, e, n) {
  const { bottomRadius: a } = t;
  return n < 0 && e ** 2 * (n ** 2 - 1) + a ** 2 >= 0;
}
function Oi(t, e, n) {
  const { topRadius: a } = t, o = e ** 2 * (n ** 2 - 1) + a ** 2;
  return Di(-e * n + _t(o));
}
function je(t, e) {
  return 0.5 / e + t * (1 - 1 / e);
}
var Ui = process.env.NODE_ENV === "production", nt = "Invariant failed";
function Pi(t, e) {
  if (!t) {
    if (Ui)
      throw new Error(nt);
    var n = nt;
    throw new Error(n);
  }
}
const Li = /* @__PURE__ */ new O(), tt = /* @__PURE__ */ new O(), bi = /* @__PURE__ */ new O();
function Ze(t, e, n) {
  const a = e * 4;
  return n.set(t[a], t[a + 1], t[a + 2]);
}
function gt(t, e, n) {
  const { width: a, height: o } = t.image;
  Pi(Sr(t.image.data));
  let c = t.image.data;
  t.type === oe && c instanceof Uint16Array && (c = new ot(c.buffer));
  const u = Xn(e.x, 0, 1) * (a - 1), d = Xn(e.y, 0, 1) * (o - 1), l = Math.floor(u), m = Math.floor(d), S = u - l, g = d - m, I = S, D = g, U = l % a, P = (U + 1) % a, H = m % o, J = (H + 1) % o, r0 = Ze(c, H * a + U, Li), i0 = Ze(c, H * a + P, tt), u0 = r0.lerp(i0, I), _0 = Ze(c, J * a + U, tt), l0 = Ze(c, J * a + P, bi), p0 = _0.lerp(l0, I);
  return n.copy(u0.lerp(p0, D));
}
function Fi(t, e, n, a) {
  const { topRadius: o, bottomRadius: c } = t, u = Math.sqrt(o ** 2 - c ** 2), d = _t(e ** 2 - c ** 2), l = Oi(t, e, n), m = o - e, S = d + u, g = (l - m) / (S - m), I = d / u;
  return a.set(
    je(g, en),
    je(I, nn)
  );
}
const Hi = /* @__PURE__ */ new O(), un = /* @__PURE__ */ new O(), zi = /* @__PURE__ */ new Ke();
function Gi(t, e, n, a = new it(), {
  ellipsoid: o = Ue.WGS84,
  correctAltitude: c = !0,
  photometric: u = !0
} = {}, d = ce.DEFAULT) {
  const l = Hi.copy(e);
  if (c) {
    const P = o.projectOnSurface(
      e,
      un
    );
    P != null && l.sub(
      o.getOsculatingSphereCenter(
        P,
        d.bottomRadius,
        un
      )
    );
  }
  const m = un;
  let S = l.length(), g = l.dot(n);
  const { topRadius: I } = d, D = -g - Math.sqrt(g ** 2 - S ** 2 + I ** 2);
  if (D > 0 && (S = I, g += D), S > I)
    m.set(1, 1, 1);
  else {
    const P = g / S;
    if (Ni(d, S, P))
      m.setScalar(0);
    else {
      const J = Fi(d, S, P, zi);
      gt(t, J, m);
    }
  }
  const U = m.multiply(d.solarIrradiance);
  return u && U.multiply(d.sunRadianceToRelativeLuminance), a.setFromVector3(U);
}
const ki = parseInt(tr.replace(/\D+/g, ""));
var M0 = Uint8Array, re = Uint16Array, yn = Uint32Array, wt = new M0([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), Tt = new M0([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), Bi = new M0([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), Rt = function(t, e) {
  for (var n = new re(31), a = 0; a < 31; ++a)
    n[a] = e += 1 << t[a - 1];
  for (var o = new yn(n[30]), a = 1; a < 30; ++a)
    for (var c = n[a]; c < n[a + 1]; ++c)
      o[c] = c - n[a] << 5 | a;
  return [n, o];
}, At = Rt(wt, 2), Ct = At[0], Zi = At[1];
Ct[28] = 258, Zi[258] = 28;
var Wi = Rt(Tt, 0), Xi = Wi[0], In = new re(32768);
for (var j = 0; j < 32768; ++j) {
  var te = (j & 43690) >>> 1 | (j & 21845) << 1;
  te = (te & 52428) >>> 2 | (te & 13107) << 2, te = (te & 61680) >>> 4 | (te & 3855) << 4, In[j] = ((te & 65280) >>> 8 | (te & 255) << 8) >>> 1;
}
var Oe = function(t, e, n) {
  for (var a = t.length, o = 0, c = new re(e); o < a; ++o)
    ++c[t[o] - 1];
  var u = new re(e);
  for (o = 0; o < e; ++o)
    u[o] = u[o - 1] + c[o - 1] << 1;
  var d;
  if (n) {
    d = new re(1 << e);
    var l = 15 - e;
    for (o = 0; o < a; ++o)
      if (t[o])
        for (var m = o << 4 | t[o], S = e - t[o], g = u[t[o] - 1]++ << S, I = g | (1 << S) - 1; g <= I; ++g)
          d[In[g] >>> l] = m;
  } else
    for (d = new re(a), o = 0; o < a; ++o)
      t[o] && (d[o] = In[u[t[o] - 1]++] >>> 15 - t[o]);
  return d;
}, Le = new M0(288);
for (var j = 0; j < 144; ++j)
  Le[j] = 8;
for (var j = 144; j < 256; ++j)
  Le[j] = 9;
for (var j = 256; j < 280; ++j)
  Le[j] = 7;
for (var j = 280; j < 288; ++j)
  Le[j] = 8;
var yt = new M0(32);
for (var j = 0; j < 32; ++j)
  yt[j] = 5;
var Vi = /* @__PURE__ */ Oe(Le, 9, 1), Yi = /* @__PURE__ */ Oe(yt, 5, 1), ln = function(t) {
  for (var e = t[0], n = 1; n < t.length; ++n)
    t[n] > e && (e = t[n]);
  return e;
}, F0 = function(t, e, n) {
  var a = e / 8 | 0;
  return (t[a] | t[a + 1] << 8) >> (e & 7) & n;
}, dn = function(t, e) {
  var n = e / 8 | 0;
  return (t[n] | t[n + 1] << 8 | t[n + 2] << 16) >> (e & 7);
}, $i = function(t) {
  return (t / 8 | 0) + (t & 7 && 1);
}, ji = function(t, e, n) {
  (n == null || n > t.length) && (n = t.length);
  var a = new (t instanceof re ? re : t instanceof yn ? yn : M0)(n - e);
  return a.set(t.subarray(e, n)), a;
}, qi = function(t, e, n) {
  var a = t.length;
  if (!a || n && !n.l && a < 5)
    return e || new M0(0);
  var o = !e || n, c = !n || n.i;
  n || (n = {}), e || (e = new M0(a * 3));
  var u = function(G) {
    var L0 = e.length;
    if (G > L0) {
      var A0 = new M0(Math.max(L0 * 2, G));
      A0.set(e), e = A0;
    }
  }, d = n.f || 0, l = n.p || 0, m = n.b || 0, S = n.l, g = n.d, I = n.m, D = n.n, U = a * 8;
  do {
    if (!S) {
      n.f = d = F0(t, l, 1);
      var P = F0(t, l + 1, 3);
      if (l += 3, P)
        if (P == 1)
          S = Vi, g = Yi, I = 9, D = 5;
        else if (P == 2) {
          var i0 = F0(t, l, 31) + 257, u0 = F0(t, l + 10, 15) + 4, _0 = i0 + F0(t, l + 5, 31) + 1;
          l += 14;
          for (var l0 = new M0(_0), p0 = new M0(19), n0 = 0; n0 < u0; ++n0)
            p0[Bi[n0]] = F0(t, l + n0 * 3, 7);
          l += u0 * 3;
          for (var z0 = ln(p0), K0 = (1 << z0) - 1, G0 = Oe(p0, z0, 1), n0 = 0; n0 < _0; ) {
            var d0 = G0[F0(t, l, K0)];
            l += d0 & 15;
            var H = d0 >>> 4;
            if (H < 16)
              l0[n0++] = H;
            else {
              var R0 = 0, w0 = 0;
              for (H == 16 ? (w0 = 3 + F0(t, l, 3), l += 2, R0 = l0[n0 - 1]) : H == 17 ? (w0 = 3 + F0(t, l, 7), l += 3) : H == 18 && (w0 = 11 + F0(t, l, 127), l += 7); w0--; )
                l0[n0++] = R0;
            }
          }
          var Z0 = l0.subarray(0, i0), m0 = l0.subarray(i0);
          I = ln(Z0), D = ln(m0), S = Oe(Z0, I, 1), g = Oe(m0, D, 1);
        } else
          throw "invalid block type";
      else {
        var H = $i(l) + 4, J = t[H - 4] | t[H - 3] << 8, r0 = H + J;
        if (r0 > a) {
          if (c)
            throw "unexpected EOF";
          break;
        }
        o && u(m + J), e.set(t.subarray(H, r0), m), n.b = m += J, n.p = l = r0 * 8;
        continue;
      }
      if (l > U) {
        if (c)
          throw "unexpected EOF";
        break;
      }
    }
    o && u(m + 131072);
    for (var W0 = (1 << I) - 1, X0 = (1 << D) - 1, J0 = l; ; J0 = l) {
      var R0 = S[dn(t, l) & W0], b = R0 >>> 4;
      if (l += R0 & 15, l > U) {
        if (c)
          throw "unexpected EOF";
        break;
      }
      if (!R0)
        throw "invalid length/literal";
      if (b < 256)
        e[m++] = b;
      else if (b == 256) {
        J0 = l, S = null;
        break;
      } else {
        var O0 = b - 254;
        if (b > 264) {
          var n0 = b - 257, s0 = wt[n0];
          O0 = F0(t, l, (1 << s0) - 1) + Ct[n0], l += s0;
        }
        var U0 = g[dn(t, l) & X0], P0 = U0 >>> 4;
        if (!U0)
          throw "invalid distance";
        l += U0 & 15;
        var m0 = Xi[P0];
        if (P0 > 3) {
          var s0 = Tt[P0];
          m0 += dn(t, l) & (1 << s0) - 1, l += s0;
        }
        if (l > U) {
          if (c)
            throw "unexpected EOF";
          break;
        }
        o && u(m + 131072);
        for (var V0 = m + O0; m < V0; m += 4)
          e[m] = e[m - m0], e[m + 1] = e[m + 1 - m0], e[m + 2] = e[m + 2 - m0], e[m + 3] = e[m + 3 - m0];
        m = V0;
      }
    }
    n.l = S, n.p = J0, n.b = m, S && (d = 1, n.m = I, n.d = g, n.n = D);
  } while (!d);
  return m == e.length ? e : ji(e, 0, m);
}, Ki = /* @__PURE__ */ new M0(0), Ji = function(t) {
  if ((t[0] & 15) != 8 || t[0] >>> 4 > 7 || (t[0] << 8 | t[1]) % 31)
    throw "invalid zlib data";
  if (t[1] & 32)
    throw "invalid zlib data: preset dictionaries not supported";
};
function We(t, e) {
  return qi((Ji(t), t.subarray(2, -4)), e);
}
var Qi = typeof TextDecoder < "u" && /* @__PURE__ */ new TextDecoder(), e1 = 0;
try {
  Qi.decode(Ki, { stream: !0 }), e1 = 1;
} catch {
}
const xe = ki >= 152;
class rt extends rr {
  constructor(e) {
    super(e), this.type = oe;
  }
  parse(e) {
    const z0 = Math.pow(2.7182818, 2.2);
    function K0(r, i) {
      for (var s = 0, v = 0; v < 65536; ++v)
        (v == 0 || r[v >> 3] & 1 << (v & 7)) && (i[s++] = v);
      for (var h = s - 1; s < 65536; )
        i[s++] = 0;
      return h;
    }
    function G0(r) {
      for (var i = 0; i < 16384; i++)
        r[i] = {}, r[i].len = 0, r[i].lit = 0, r[i].p = null;
    }
    const d0 = { l: 0, c: 0, lc: 0 };
    function R0(r, i, s, v, h) {
      for (; s < r; )
        i = i << 8 | kn(v, h), s += 8;
      s -= r, d0.l = i >> s & (1 << r) - 1, d0.c = i, d0.lc = s;
    }
    const w0 = new Array(59);
    function Z0(r) {
      for (var i = 0; i <= 58; ++i)
        w0[i] = 0;
      for (var i = 0; i < 65537; ++i)
        w0[r[i]] += 1;
      for (var s = 0, i = 58; i > 0; --i) {
        var v = s + w0[i] >> 1;
        w0[i] = s, s = v;
      }
      for (var i = 0; i < 65537; ++i) {
        var h = r[i];
        h > 0 && (r[i] = h | w0[h]++ << 6);
      }
    }
    function m0(r, i, s, v, h, f, _) {
      for (var E = s, R = 0, T = 0; h <= f; h++) {
        if (E.value - s.value > v)
          return !1;
        R0(6, R, T, r, E);
        var A = d0.l;
        if (R = d0.c, T = d0.lc, _[h] = A, A == 63) {
          if (E.value - s.value > v)
            throw "Something wrong with hufUnpackEncTable";
          R0(8, R, T, r, E);
          var w = d0.l + 6;
          if (R = d0.c, T = d0.lc, h + w > f + 1)
            throw "Something wrong with hufUnpackEncTable";
          for (; w--; )
            _[h++] = 0;
          h--;
        } else if (A >= 59) {
          var w = A - 59 + 2;
          if (h + w > f + 1)
            throw "Something wrong with hufUnpackEncTable";
          for (; w--; )
            _[h++] = 0;
          h--;
        }
      }
      Z0(_);
    }
    function W0(r) {
      return r & 63;
    }
    function X0(r) {
      return r >> 6;
    }
    function J0(r, i, s, v) {
      for (; i <= s; i++) {
        var h = X0(r[i]), f = W0(r[i]);
        if (h >> f)
          throw "Invalid table entry";
        if (f > 14) {
          var _ = v[h >> f - 14];
          if (_.len)
            throw "Invalid table entry";
          if (_.lit++, _.p) {
            var E = _.p;
            _.p = new Array(_.lit);
            for (var R = 0; R < _.lit - 1; ++R)
              _.p[R] = E[R];
          } else
            _.p = new Array(1);
          _.p[_.lit - 1] = i;
        } else if (f)
          for (var T = 0, R = 1 << 14 - f; R > 0; R--) {
            var _ = v[(h << 14 - f) + T];
            if (_.len || _.p)
              throw "Invalid table entry";
            _.len = f, _.lit = i, T++;
          }
      }
      return !0;
    }
    const b = { c: 0, lc: 0 };
    function O0(r, i, s, v) {
      r = r << 8 | kn(s, v), i += 8, b.c = r, b.lc = i;
    }
    const s0 = { c: 0, lc: 0 };
    function U0(r, i, s, v, h, f, _, E, R, T) {
      if (r == i) {
        v < 8 && (O0(s, v, h, _), s = b.c, v = b.lc), v -= 8;
        var A = s >> v, A = new Uint8Array([A])[0];
        if (R.value + A > T)
          return !1;
        for (var w = E[R.value - 1]; A-- > 0; )
          E[R.value++] = w;
      } else if (R.value < T)
        E[R.value++] = r;
      else
        return !1;
      s0.c = s, s0.lc = v;
    }
    function P0(r) {
      return r & 65535;
    }
    function V0(r) {
      var i = P0(r);
      return i > 32767 ? i - 65536 : i;
    }
    const G = { a: 0, b: 0 };
    function L0(r, i) {
      var s = V0(r), v = V0(i), h = v, f = s + (h & 1) + (h >> 1), _ = f, E = f - h;
      G.a = _, G.b = E;
    }
    function A0(r, i) {
      var s = P0(r), v = P0(i), h = s - (v >> 1) & 65535, f = v + h - 32768 & 65535;
      G.a = f, G.b = h;
    }
    function p(r, i, s, v, h, f, _) {
      for (var E = _ < 16384, R = s > h ? h : s, T = 1, A; T <= R; )
        T <<= 1;
      for (T >>= 1, A = T, T >>= 1; T >= 1; ) {
        for (var w = 0, Q = w + f * (h - A), x = f * T, M = f * A, N = v * T, L = v * A, W, V, o0, S0; w <= Q; w += M) {
          for (var Y = w, B0 = w + v * (s - A); Y <= B0; Y += L) {
            var $ = Y + N, c0 = Y + x, Y0 = c0 + N;
            E ? (L0(r[Y + i], r[c0 + i]), W = G.a, o0 = G.b, L0(r[$ + i], r[Y0 + i]), V = G.a, S0 = G.b, L0(W, V), r[Y + i] = G.a, r[$ + i] = G.b, L0(o0, S0), r[c0 + i] = G.a, r[Y0 + i] = G.b) : (A0(r[Y + i], r[c0 + i]), W = G.a, o0 = G.b, A0(r[$ + i], r[Y0 + i]), V = G.a, S0 = G.b, A0(W, V), r[Y + i] = G.a, r[$ + i] = G.b, A0(o0, S0), r[c0 + i] = G.a, r[Y0 + i] = G.b);
          }
          if (s & T) {
            var c0 = Y + x;
            E ? L0(r[Y + i], r[c0 + i]) : A0(r[Y + i], r[c0 + i]), W = G.a, r[c0 + i] = G.b, r[Y + i] = W;
          }
        }
        if (h & T)
          for (var Y = w, B0 = w + v * (s - A); Y <= B0; Y += L) {
            var $ = Y + N;
            E ? L0(r[Y + i], r[$ + i]) : A0(r[Y + i], r[$ + i]), W = G.a, r[$ + i] = G.b, r[Y + i] = W;
          }
        A = T, T >>= 1;
      }
      return w;
    }
    function C0(r, i, s, v, h, f, _, E, R, T) {
      for (var A = 0, w = 0, Q = E, x = Math.trunc(h.value + (f + 7) / 8); h.value < x; )
        for (O0(A, w, s, h), A = b.c, w = b.lc; w >= 14; ) {
          var M = A >> w - 14 & 16383, N = i[M];
          if (N.len)
            w -= N.len, U0(N.lit, _, A, w, s, v, h, R, T, Q), A = s0.c, w = s0.lc;
          else {
            if (!N.p)
              throw "hufDecode issues";
            var L;
            for (L = 0; L < N.lit; L++) {
              for (var W = W0(r[N.p[L]]); w < W && h.value < x; )
                O0(A, w, s, h), A = b.c, w = b.lc;
              if (w >= W && X0(r[N.p[L]]) == (A >> w - W & (1 << W) - 1)) {
                w -= W, U0(
                  N.p[L],
                  _,
                  A,
                  w,
                  s,
                  v,
                  h,
                  R,
                  T,
                  Q
                ), A = s0.c, w = s0.lc;
                break;
              }
            }
            if (L == N.lit)
              throw "hufDecode issues";
          }
        }
      var V = 8 - f & 7;
      for (A >>= V, w -= V; w > 0; ) {
        var N = i[A << 14 - w & 16383];
        if (N.len)
          w -= N.len, U0(N.lit, _, A, w, s, v, h, R, T, Q), A = s0.c, w = s0.lc;
        else
          throw "hufDecode issues";
      }
      return !0;
    }
    function be(r, i, s, v, h, f) {
      var _ = { value: 0 }, E = s.value, R = g0(i, s), T = g0(i, s);
      s.value += 4;
      var A = g0(i, s);
      if (s.value += 4, R < 0 || R >= 65537 || T < 0 || T >= 65537)
        throw "Something wrong with HUF_ENCSIZE";
      var w = new Array(65537), Q = new Array(16384);
      G0(Q);
      var x = v - (s.value - E);
      if (m0(r, i, s, x, R, T, w), A > 8 * (v - (s.value - E)))
        throw "Something wrong with hufUncompress";
      J0(w, R, T, Q), C0(w, Q, r, i, s, A, T, f, h, _);
    }
    function z(r, i, s) {
      for (var v = 0; v < s; ++v)
        i[v] = r[i[v]];
    }
    function B(r) {
      for (var i = 1; i < r.length; i++) {
        var s = r[i - 1] + r[i] - 128;
        r[i] = s;
      }
    }
    function q(r, i) {
      for (var s = 0, v = Math.floor((r.length + 1) / 2), h = 0, f = r.length - 1; !(h > f || (i[h++] = r[s++], h > f)); )
        i[h++] = r[v++];
    }
    function e0(r) {
      for (var i = r.byteLength, s = new Array(), v = 0, h = new DataView(r); i > 0; ) {
        var f = h.getInt8(v++);
        if (f < 0) {
          var _ = -f;
          i -= _ + 1;
          for (var E = 0; E < _; E++)
            s.push(h.getUint8(v++));
        } else {
          var _ = f;
          i -= 2;
          for (var R = h.getUint8(v++), E = 0; E < _ + 1; E++)
            s.push(R);
        }
      }
      return s;
    }
    function a0(r, i, s, v, h, f) {
      var $ = new DataView(f.buffer), _ = s[r.idx[0]].width, E = s[r.idx[0]].height, R = 3, T = Math.floor(_ / 8), A = Math.ceil(_ / 8), w = Math.ceil(E / 8), Q = _ - (A - 1) * 8, x = E - (w - 1) * 8, M = { value: 0 }, N = new Array(R), L = new Array(R), W = new Array(R), V = new Array(R), o0 = new Array(R);
      for (let X = 0; X < R; ++X)
        o0[X] = i[r.idx[X]], N[X] = X < 1 ? 0 : N[X - 1] + A * w, L[X] = new Float32Array(64), W[X] = new Uint16Array(64), V[X] = new Uint16Array(A * 64);
      for (let X = 0; X < w; ++X) {
        var S0 = 8;
        X == w - 1 && (S0 = x);
        var Y = 8;
        for (let K = 0; K < A; ++K) {
          K == A - 1 && (Y = Q);
          for (let Z = 0; Z < R; ++Z)
            W[Z].fill(0), W[Z][0] = h[N[Z]++], k0(M, v, W[Z]), b0(W[Z], L[Z]), we(L[Z]);
          Q0(L);
          for (let Z = 0; Z < R; ++Z)
            Mt(L[Z], V[Z], K * 64);
        }
        let h0 = 0;
        for (let K = 0; K < R; ++K) {
          const Z = s[r.idx[K]].type;
          for (let x0 = 8 * X; x0 < 8 * X + S0; ++x0) {
            h0 = o0[K][x0];
            for (let ae = 0; ae < T; ++ae) {
              const T0 = ae * 64 + (x0 & 7) * 8;
              $.setUint16(h0 + 0 * 2 * Z, V[K][T0 + 0], !0), $.setUint16(h0 + 1 * 2 * Z, V[K][T0 + 1], !0), $.setUint16(h0 + 2 * 2 * Z, V[K][T0 + 2], !0), $.setUint16(h0 + 3 * 2 * Z, V[K][T0 + 3], !0), $.setUint16(h0 + 4 * 2 * Z, V[K][T0 + 4], !0), $.setUint16(h0 + 5 * 2 * Z, V[K][T0 + 5], !0), $.setUint16(h0 + 6 * 2 * Z, V[K][T0 + 6], !0), $.setUint16(h0 + 7 * 2 * Z, V[K][T0 + 7], !0), h0 += 8 * 2 * Z;
            }
          }
          if (T != A)
            for (let x0 = 8 * X; x0 < 8 * X + S0; ++x0) {
              const ae = o0[K][x0] + 8 * T * 2 * Z, T0 = T * 64 + (x0 & 7) * 8;
              for (let ee = 0; ee < Y; ++ee)
                $.setUint16(ae + ee * 2 * Z, V[K][T0 + ee], !0);
            }
        }
      }
      for (var B0 = new Uint16Array(_), $ = new DataView(f.buffer), c0 = 0; c0 < R; ++c0) {
        s[r.idx[c0]].decoded = !0;
        var Y0 = s[r.idx[c0]].type;
        if (s[c0].type == 2)
          for (var ye = 0; ye < E; ++ye) {
            const X = o0[c0][ye];
            for (var I0 = 0; I0 < _; ++I0)
              B0[I0] = $.getUint16(X + I0 * 2 * Y0, !0);
            for (var I0 = 0; I0 < _; ++I0)
              $.setFloat32(X + I0 * 2 * Y0, y(B0[I0]), !0);
          }
      }
    }
    function k0(r, i, s) {
      for (var v, h = 1; h < 64; )
        v = i[r.value], v == 65280 ? h = 64 : v >> 8 == 255 ? h += v & 255 : (s[h] = v, h++), r.value++;
    }
    function b0(r, i) {
      i[0] = y(r[0]), i[1] = y(r[1]), i[2] = y(r[5]), i[3] = y(r[6]), i[4] = y(r[14]), i[5] = y(r[15]), i[6] = y(r[27]), i[7] = y(r[28]), i[8] = y(r[2]), i[9] = y(r[4]), i[10] = y(r[7]), i[11] = y(r[13]), i[12] = y(r[16]), i[13] = y(r[26]), i[14] = y(r[29]), i[15] = y(r[42]), i[16] = y(r[3]), i[17] = y(r[8]), i[18] = y(r[12]), i[19] = y(r[17]), i[20] = y(r[25]), i[21] = y(r[30]), i[22] = y(r[41]), i[23] = y(r[43]), i[24] = y(r[9]), i[25] = y(r[11]), i[26] = y(r[18]), i[27] = y(r[24]), i[28] = y(r[31]), i[29] = y(r[40]), i[30] = y(r[44]), i[31] = y(r[53]), i[32] = y(r[10]), i[33] = y(r[19]), i[34] = y(r[23]), i[35] = y(r[32]), i[36] = y(r[39]), i[37] = y(r[45]), i[38] = y(r[52]), i[39] = y(r[54]), i[40] = y(r[20]), i[41] = y(r[22]), i[42] = y(r[33]), i[43] = y(r[38]), i[44] = y(r[46]), i[45] = y(r[51]), i[46] = y(r[55]), i[47] = y(r[60]), i[48] = y(r[21]), i[49] = y(r[34]), i[50] = y(r[37]), i[51] = y(r[47]), i[52] = y(r[50]), i[53] = y(r[56]), i[54] = y(r[59]), i[55] = y(r[61]), i[56] = y(r[35]), i[57] = y(r[36]), i[58] = y(r[48]), i[59] = y(r[49]), i[60] = y(r[57]), i[61] = y(r[58]), i[62] = y(r[62]), i[63] = y(r[63]);
    }
    function we(r) {
      const i = 0.5 * Math.cos(0.7853975), s = 0.5 * Math.cos(3.14159 / 16), v = 0.5 * Math.cos(3.14159 / 8), h = 0.5 * Math.cos(3 * 3.14159 / 16), f = 0.5 * Math.cos(5 * 3.14159 / 16), _ = 0.5 * Math.cos(3 * 3.14159 / 8), E = 0.5 * Math.cos(7 * 3.14159 / 16);
      for (var R = new Array(4), T = new Array(4), A = new Array(4), w = new Array(4), Q = 0; Q < 8; ++Q) {
        var x = Q * 8;
        R[0] = v * r[x + 2], R[1] = _ * r[x + 2], R[2] = v * r[x + 6], R[3] = _ * r[x + 6], T[0] = s * r[x + 1] + h * r[x + 3] + f * r[x + 5] + E * r[x + 7], T[1] = h * r[x + 1] - E * r[x + 3] - s * r[x + 5] - f * r[x + 7], T[2] = f * r[x + 1] - s * r[x + 3] + E * r[x + 5] + h * r[x + 7], T[3] = E * r[x + 1] - f * r[x + 3] + h * r[x + 5] - s * r[x + 7], A[0] = i * (r[x + 0] + r[x + 4]), A[3] = i * (r[x + 0] - r[x + 4]), A[1] = R[0] + R[3], A[2] = R[1] - R[2], w[0] = A[0] + A[1], w[1] = A[3] + A[2], w[2] = A[3] - A[2], w[3] = A[0] - A[1], r[x + 0] = w[0] + T[0], r[x + 1] = w[1] + T[1], r[x + 2] = w[2] + T[2], r[x + 3] = w[3] + T[3], r[x + 4] = w[3] - T[3], r[x + 5] = w[2] - T[2], r[x + 6] = w[1] - T[1], r[x + 7] = w[0] - T[0];
      }
      for (var M = 0; M < 8; ++M)
        R[0] = v * r[16 + M], R[1] = _ * r[16 + M], R[2] = v * r[48 + M], R[3] = _ * r[48 + M], T[0] = s * r[8 + M] + h * r[24 + M] + f * r[40 + M] + E * r[56 + M], T[1] = h * r[8 + M] - E * r[24 + M] - s * r[40 + M] - f * r[56 + M], T[2] = f * r[8 + M] - s * r[24 + M] + E * r[40 + M] + h * r[56 + M], T[3] = E * r[8 + M] - f * r[24 + M] + h * r[40 + M] - s * r[56 + M], A[0] = i * (r[M] + r[32 + M]), A[3] = i * (r[M] - r[32 + M]), A[1] = R[0] + R[3], A[2] = R[1] - R[2], w[0] = A[0] + A[1], w[1] = A[3] + A[2], w[2] = A[3] - A[2], w[3] = A[0] - A[1], r[0 + M] = w[0] + T[0], r[8 + M] = w[1] + T[1], r[16 + M] = w[2] + T[2], r[24 + M] = w[3] + T[3], r[32 + M] = w[3] - T[3], r[40 + M] = w[2] - T[2], r[48 + M] = w[1] - T[1], r[56 + M] = w[0] - T[0];
    }
    function Q0(r) {
      for (var i = 0; i < 64; ++i) {
        var s = r[0][i], v = r[1][i], h = r[2][i];
        r[0][i] = s + 1.5747 * h, r[1][i] = s - 0.1873 * v - 0.4682 * h, r[2][i] = s + 1.8556 * v;
      }
    }
    function Mt(r, i, s) {
      for (var v = 0; v < 64; ++v)
        i[s + v] = Zn.toHalfFloat(Dt(r[v]));
    }
    function Dt(r) {
      return r <= 1 ? Math.sign(r) * Math.pow(Math.abs(r), 2.2) : Math.sign(r) * Math.pow(z0, Math.abs(r) - 1);
    }
    function zn(r) {
      return new DataView(r.array.buffer, r.offset.value, r.size);
    }
    function Nt(r) {
      var i = r.viewer.buffer.slice(r.offset.value, r.offset.value + r.size), s = new Uint8Array(e0(i)), v = new Uint8Array(s.length);
      return B(s), q(s, v), new DataView(v.buffer);
    }
    function rn(r) {
      var i = r.array.slice(r.offset.value, r.offset.value + r.size), s = We(i), v = new Uint8Array(s.length);
      return B(s), q(s, v), new DataView(v.buffer);
    }
    function Ot(r) {
      for (var i = r.viewer, s = { value: r.offset.value }, v = new Uint16Array(r.width * r.scanlineBlockSize * (r.channels * r.type)), h = new Uint8Array(8192), f = 0, _ = new Array(r.channels), E = 0; E < r.channels; E++)
        _[E] = {}, _[E].start = f, _[E].end = _[E].start, _[E].nx = r.width, _[E].ny = r.lines, _[E].size = r.type, f += _[E].nx * _[E].ny * _[E].size;
      var R = Re(i, s), T = Re(i, s);
      if (T >= 8192)
        throw "Something is wrong with PIZ_COMPRESSION BITMAP_SIZE";
      if (R <= T)
        for (var E = 0; E < T - R + 1; E++)
          h[E + R] = de(i, s);
      var A = new Uint16Array(65536), w = K0(h, A), Q = g0(i, s);
      be(r.array, i, s, Q, v, f);
      for (var E = 0; E < r.channels; ++E)
        for (var x = _[E], M = 0; M < _[E].size; ++M)
          p(v, x.start + M, x.nx, x.size, x.ny, x.nx * x.size, w);
      z(A, v, f);
      for (var N = 0, L = new Uint8Array(v.buffer.byteLength), W = 0; W < r.lines; W++)
        for (var V = 0; V < r.channels; V++) {
          var x = _[V], o0 = x.nx * x.size, S0 = new Uint8Array(v.buffer, x.end * 2, o0 * 2);
          L.set(S0, N), N += o0 * 2, x.end += o0;
        }
      return new DataView(L.buffer);
    }
    function Ut(r) {
      var i = r.array.slice(r.offset.value, r.offset.value + r.size), s = We(i);
      const v = r.lines * r.channels * r.width, h = r.type == 1 ? new Uint16Array(v) : new Uint32Array(v);
      let f = 0, _ = 0;
      const E = new Array(4);
      for (let R = 0; R < r.lines; R++)
        for (let T = 0; T < r.channels; T++) {
          let A = 0;
          switch (r.type) {
            case 1:
              E[0] = f, E[1] = E[0] + r.width, f = E[1] + r.width;
              for (let w = 0; w < r.width; ++w) {
                const Q = s[E[0]++] << 8 | s[E[1]++];
                A += Q, h[_] = A, _++;
              }
              break;
            case 2:
              E[0] = f, E[1] = E[0] + r.width, E[2] = E[1] + r.width, f = E[2] + r.width;
              for (let w = 0; w < r.width; ++w) {
                const Q = s[E[0]++] << 24 | s[E[1]++] << 16 | s[E[2]++] << 8;
                A += Q, h[_] = A, _++;
              }
              break;
          }
        }
      return new DataView(h.buffer);
    }
    function Gn(r) {
      var i = r.viewer, s = { value: r.offset.value }, v = new Uint8Array(r.width * r.lines * (r.channels * r.type * 2)), h = {
        version: y0(i, s),
        unknownUncompressedSize: y0(i, s),
        unknownCompressedSize: y0(i, s),
        acCompressedSize: y0(i, s),
        dcCompressedSize: y0(i, s),
        rleCompressedSize: y0(i, s),
        rleUncompressedSize: y0(i, s),
        rleRawSize: y0(i, s),
        totalAcUncompressedCount: y0(i, s),
        totalDcUncompressedCount: y0(i, s),
        acCompression: y0(i, s)
      };
      if (h.version < 2)
        throw "EXRLoader.parse: " + Ce.compression + " version " + h.version + " is unsupported";
      for (var f = new Array(), _ = Re(i, s) - 2; _ > 0; ) {
        var E = Fe(i.buffer, s), R = de(i, s), T = R >> 2 & 3, A = (R >> 4) - 1, w = new Int8Array([A])[0], Q = de(i, s);
        f.push({
          name: E,
          index: w,
          type: Q,
          compression: T
        }), _ -= E.length + 3;
      }
      for (var x = Ce.channels, M = new Array(r.channels), N = 0; N < r.channels; ++N) {
        var L = M[N] = {}, W = x[N];
        L.name = W.name, L.compression = 0, L.decoded = !1, L.type = W.pixelType, L.pLinear = W.pLinear, L.width = r.width, L.height = r.lines;
      }
      for (var V = {
        idx: new Array(3)
      }, o0 = 0; o0 < r.channels; ++o0)
        for (var L = M[o0], N = 0; N < f.length; ++N) {
          var S0 = f[N];
          L.name == S0.name && (L.compression = S0.compression, S0.index >= 0 && (V.idx[S0.index] = o0), L.offset = o0);
        }
      if (h.acCompressedSize > 0)
        switch (h.acCompression) {
          case 0:
            var $ = new Uint16Array(h.totalAcUncompressedCount);
            be(
              r.array,
              i,
              s,
              h.acCompressedSize,
              $,
              h.totalAcUncompressedCount
            );
            break;
          case 1:
            var Y = r.array.slice(s.value, s.value + h.totalAcUncompressedCount), B0 = We(Y), $ = new Uint16Array(B0.buffer);
            s.value += h.totalAcUncompressedCount;
            break;
        }
      if (h.dcCompressedSize > 0) {
        var c0 = {
          array: r.array,
          offset: s,
          size: h.dcCompressedSize
        }, Y0 = new Uint16Array(rn(c0).buffer);
        s.value += h.dcCompressedSize;
      }
      if (h.rleRawSize > 0) {
        var Y = r.array.slice(s.value, s.value + h.rleCompressedSize), B0 = We(Y), ye = e0(B0.buffer);
        s.value += h.rleCompressedSize;
      }
      for (var I0 = 0, X = new Array(M.length), N = 0; N < X.length; ++N)
        X[N] = new Array();
      for (var h0 = 0; h0 < r.lines; ++h0)
        for (var K = 0; K < M.length; ++K)
          X[K].push(I0), I0 += M[K].width * r.type * 2;
      a0(V, X, M, $, Y0, v);
      for (var N = 0; N < M.length; ++N) {
        var L = M[N];
        if (!L.decoded)
          switch (L.compression) {
            case 2:
              for (var Z = 0, x0 = 0, h0 = 0; h0 < r.lines; ++h0) {
                for (var ae = X[N][Z], T0 = 0; T0 < L.width; ++T0) {
                  for (var ee = 0; ee < 2 * L.type; ++ee)
                    v[ae++] = ye[x0 + ee * L.width * L.height];
                  x0++;
                }
                Z++;
              }
              break;
            case 1:
            default:
              throw "EXRLoader.parse: unsupported channel compression";
          }
      }
      return new DataView(v.buffer);
    }
    function Fe(r, i) {
      for (var s = new Uint8Array(r), v = 0; s[i.value + v] != 0; )
        v += 1;
      var h = new TextDecoder().decode(s.slice(i.value, i.value + v));
      return i.value = i.value + v + 1, h;
    }
    function Pt(r, i, s) {
      var v = new TextDecoder().decode(new Uint8Array(r).slice(i.value, i.value + s));
      return i.value = i.value + s, v;
    }
    function Lt(r, i) {
      var s = Te(r, i), v = g0(r, i);
      return [s, v];
    }
    function bt(r, i) {
      var s = g0(r, i), v = g0(r, i);
      return [s, v];
    }
    function Te(r, i) {
      var s = r.getInt32(i.value, !0);
      return i.value = i.value + 4, s;
    }
    function g0(r, i) {
      var s = r.getUint32(i.value, !0);
      return i.value = i.value + 4, s;
    }
    function kn(r, i) {
      var s = r[i.value];
      return i.value = i.value + 1, s;
    }
    function de(r, i) {
      var s = r.getUint8(i.value);
      return i.value = i.value + 1, s;
    }
    const y0 = function(r, i) {
      let s;
      return "getBigInt64" in DataView.prototype ? s = Number(r.getBigInt64(i.value, !0)) : s = r.getUint32(i.value + 4, !0) + Number(r.getUint32(i.value, !0) << 32), i.value += 8, s;
    };
    function v0(r, i) {
      var s = r.getFloat32(i.value, !0);
      return i.value += 4, s;
    }
    function Ft(r, i) {
      return Zn.toHalfFloat(v0(r, i));
    }
    function y(r) {
      var i = (r & 31744) >> 10, s = r & 1023;
      return (r >> 15 ? -1 : 1) * (i ? i === 31 ? s ? NaN : 1 / 0 : Math.pow(2, i - 15) * (1 + s / 1024) : 6103515625e-14 * (s / 1024));
    }
    function Re(r, i) {
      var s = r.getUint16(i.value, !0);
      return i.value += 2, s;
    }
    function Ht(r, i) {
      return y(Re(r, i));
    }
    function zt(r, i, s, v) {
      for (var h = s.value, f = []; s.value < h + v - 1; ) {
        var _ = Fe(i, s), E = Te(r, s), R = de(r, s);
        s.value += 3;
        var T = Te(r, s), A = Te(r, s);
        f.push({
          name: _,
          pixelType: E,
          pLinear: R,
          xSampling: T,
          ySampling: A
        });
      }
      return s.value += 1, f;
    }
    function Gt(r, i) {
      var s = v0(r, i), v = v0(r, i), h = v0(r, i), f = v0(r, i), _ = v0(r, i), E = v0(r, i), R = v0(r, i), T = v0(r, i);
      return {
        redX: s,
        redY: v,
        greenX: h,
        greenY: f,
        blueX: _,
        blueY: E,
        whiteX: R,
        whiteY: T
      };
    }
    function kt(r, i) {
      var s = [
        "NO_COMPRESSION",
        "RLE_COMPRESSION",
        "ZIPS_COMPRESSION",
        "ZIP_COMPRESSION",
        "PIZ_COMPRESSION",
        "PXR24_COMPRESSION",
        "B44_COMPRESSION",
        "B44A_COMPRESSION",
        "DWAA_COMPRESSION",
        "DWAB_COMPRESSION"
      ], v = de(r, i);
      return s[v];
    }
    function Bt(r, i) {
      var s = g0(r, i), v = g0(r, i), h = g0(r, i), f = g0(r, i);
      return { xMin: s, yMin: v, xMax: h, yMax: f };
    }
    function Zt(r, i) {
      var s = ["INCREASING_Y"], v = de(r, i);
      return s[v];
    }
    function Wt(r, i) {
      var s = v0(r, i), v = v0(r, i);
      return [s, v];
    }
    function Xt(r, i) {
      var s = v0(r, i), v = v0(r, i), h = v0(r, i);
      return [s, v, h];
    }
    function Vt(r, i, s, v, h) {
      if (v === "string" || v === "stringvector" || v === "iccProfile")
        return Pt(i, s, h);
      if (v === "chlist")
        return zt(r, i, s, h);
      if (v === "chromaticities")
        return Gt(r, s);
      if (v === "compression")
        return kt(r, s);
      if (v === "box2i")
        return Bt(r, s);
      if (v === "lineOrder")
        return Zt(r, s);
      if (v === "float")
        return v0(r, s);
      if (v === "v2f")
        return Wt(r, s);
      if (v === "v3f")
        return Xt(r, s);
      if (v === "int")
        return Te(r, s);
      if (v === "rational")
        return Lt(r, s);
      if (v === "timecode")
        return bt(r, s);
      if (v === "preview")
        return s.value += h, "skipped";
      s.value += h;
    }
    function Yt(r, i, s) {
      const v = {};
      if (r.getUint32(0, !0) != 20000630)
        throw "THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.";
      v.version = r.getUint8(4);
      const h = r.getUint8(5);
      v.spec = {
        singleTile: !!(h & 2),
        longName: !!(h & 4),
        deepFormat: !!(h & 8),
        multiPart: !!(h & 16)
      }, s.value = 8;
      for (var f = !0; f; ) {
        var _ = Fe(i, s);
        if (_ == 0)
          f = !1;
        else {
          var E = Fe(i, s), R = g0(r, s), T = Vt(r, i, s, E, R);
          T === void 0 ? console.warn(`EXRLoader.parse: skipped unknown header attribute type '${E}'.`) : v[_] = T;
        }
      }
      if ((h & -5) != 0)
        throw console.error("EXRHeader:", v), "THREE.EXRLoader: provided file is currently unsupported.";
      return v;
    }
    function $t(r, i, s, v, h) {
      const f = {
        size: 0,
        viewer: i,
        array: s,
        offset: v,
        width: r.dataWindow.xMax - r.dataWindow.xMin + 1,
        height: r.dataWindow.yMax - r.dataWindow.yMin + 1,
        channels: r.channels.length,
        bytesPerLine: null,
        lines: null,
        inputSize: null,
        type: r.channels[0].pixelType,
        uncompress: null,
        getter: null,
        format: null,
        [xe ? "colorSpace" : "encoding"]: null
      };
      switch (r.compression) {
        case "NO_COMPRESSION":
          f.lines = 1, f.uncompress = zn;
          break;
        case "RLE_COMPRESSION":
          f.lines = 1, f.uncompress = Nt;
          break;
        case "ZIPS_COMPRESSION":
          f.lines = 1, f.uncompress = rn;
          break;
        case "ZIP_COMPRESSION":
          f.lines = 16, f.uncompress = rn;
          break;
        case "PIZ_COMPRESSION":
          f.lines = 32, f.uncompress = Ot;
          break;
        case "PXR24_COMPRESSION":
          f.lines = 16, f.uncompress = Ut;
          break;
        case "DWAA_COMPRESSION":
          f.lines = 32, f.uncompress = Gn;
          break;
        case "DWAB_COMPRESSION":
          f.lines = 256, f.uncompress = Gn;
          break;
        default:
          throw "EXRLoader.parse: " + r.compression + " is unsupported";
      }
      if (f.scanlineBlockSize = f.lines, f.type == 1)
        switch (h) {
          case De:
            f.getter = Ht, f.inputSize = 2;
            break;
          case oe:
            f.getter = Re, f.inputSize = 2;
            break;
        }
      else if (f.type == 2)
        switch (h) {
          case De:
            f.getter = v0, f.inputSize = 4;
            break;
          case oe:
            f.getter = Ft, f.inputSize = 4;
        }
      else
        throw "EXRLoader.parse: unsupported pixelType " + f.type + " for " + r.compression + ".";
      f.blockCount = (r.dataWindow.yMax + 1) / f.scanlineBlockSize;
      for (var _ = 0; _ < f.blockCount; _++)
        y0(i, v);
      f.outputChannels = f.channels == 3 ? 4 : f.channels;
      const E = f.width * f.height * f.outputChannels;
      switch (h) {
        case De:
          f.byteArray = new Float32Array(E), f.channels < f.outputChannels && f.byteArray.fill(1, 0, E);
          break;
        case oe:
          f.byteArray = new Uint16Array(E), f.channels < f.outputChannels && f.byteArray.fill(15360, 0, E);
          break;
        default:
          console.error("THREE.EXRLoader: unsupported type: ", h);
          break;
      }
      return f.bytesPerLine = f.width * f.inputSize * f.channels, f.outputChannels == 4 ? f.format = ir : f.format = ar, xe ? f.colorSpace = "srgb-linear" : f.encoding = 3e3, f;
    }
    const He = new DataView(e), jt = new Uint8Array(e), Ae = { value: 0 }, Ce = Yt(He, e, Ae), F = $t(Ce, He, jt, Ae, this.type), Bn = { value: 0 }, qt = { R: 0, G: 1, B: 2, A: 3, Y: 0 };
    for (let r = 0; r < F.height / F.scanlineBlockSize; r++) {
      const i = g0(He, Ae);
      F.size = g0(He, Ae), F.lines = i + F.scanlineBlockSize > F.height ? F.height - i : F.scanlineBlockSize;
      const v = F.size < F.lines * F.bytesPerLine ? F.uncompress(F) : zn(F);
      Ae.value += F.size;
      for (let h = 0; h < F.scanlineBlockSize; h++) {
        const f = h + r * F.scanlineBlockSize;
        if (f >= F.height)
          break;
        for (let _ = 0; _ < F.channels; _++) {
          const E = qt[Ce.channels[_].name];
          for (let R = 0; R < F.width; R++) {
            Bn.value = (h * (F.channels * F.width) + _ * F.width + R) * F.inputSize;
            const T = (F.height - 1 - f) * (F.width * F.outputChannels) + R * F.outputChannels + E;
            F.byteArray[T] = F.getter(v, Bn);
          }
        }
      }
    }
    return {
      header: Ce,
      width: F.width,
      height: F.height,
      data: F.byteArray,
      format: F.format,
      [xe ? "colorSpace" : "encoding"]: F[xe ? "colorSpace" : "encoding"],
      type: this.type
    };
  }
  setDataType(e) {
    return this.type = e, this;
  }
  load(e, n, a, o) {
    function c(u, d) {
      xe ? u.colorSpace = d.colorSpace : u.encoding = d.encoding, u.minFilter = Ve, u.magFilter = Ve, u.generateMipmaps = !1, u.flipY = !1, n && n(u, d);
    }
    return super.load(e, c, a, o);
  }
}
function n1(t) {
  var e = [];
  if (t.length === 0)
    return "";
  if (typeof t[0] != "string")
    throw new TypeError("Url must be a string. Received " + t[0]);
  if (t[0].match(/^[^/:]+:\/*$/) && t.length > 1) {
    var n = t.shift();
    t[0] = n + t[0];
  }
  t[0].match(/^file:\/\/\//) ? t[0] = t[0].replace(/^([^/:]+):\/*/, "$1:///") : t[0] = t[0].replace(/^([^/:]+):\/*/, "$1://");
  for (var a = 0; a < t.length; a++) {
    var o = t[a];
    if (typeof o != "string")
      throw new TypeError("Url must be a string. Received " + o);
    o !== "" && (a > 0 && (o = o.replace(/^[\/]+/, "")), a < t.length - 1 ? o = o.replace(/[\/]+$/, "") : o = o.replace(/[\/]+$/, "/"), e.push(o));
  }
  var c = e.join("/");
  c = c.replace(/\/(\?|&|#[^!])/g, "$1");
  var u = c.split("?");
  return c = u.shift() + (u.length > 0 ? "?" : "") + u.join("&"), c;
}
function t1() {
  var t;
  return typeof arguments[0] == "object" ? t = arguments[0] : t = [].slice.call(arguments), n1(t);
}
class P1 extends or {
  constructor() {
    super(...arguments), this.format = "exr", this.type = oe;
  }
  setTypeFromRenderer(e) {
    return this.type = e.getContext().getExtension("OES_texture_float_linear") == null ? oe : De, this;
  }
  load(e, n, a, o) {
    const c = {}, u = (d, { loader: l, extension: m }) => {
      l.setRequestHeader(this.requestHeader), l.setPath(this.path), l.setWithCredentials(this.withCredentials), l.load(
        t1(e, `${d}${m}`),
        (S) => {
          S.minFilter = Ve, S.magFilter = Ve, S.type = this.type, this.type === De && (S.image.data = new Float32Array(
            new ot(S.image.data.buffer)
          )), c[`${d}Texture`] = S, c.irradianceTexture != null && c.scatteringTexture != null && c.transmittanceTexture != null && n(c);
        },
        a,
        o
      );
    };
    this.format === "exr" ? (u("irradiance", {
      loader: new rt(this.manager),
      extension: ".exr"
    }), u("scattering", {
      loader: new Er(this.manager).setDepth(
        Yn
      ),
      extension: ".exr"
    }), u("transmittance", {
      loader: new rt(this.manager),
      extension: ".exr"
    })) : (u("irradiance", {
      loader: Vn(on, {
        width: Je,
        height: Qe
      }),
      extension: ".bin"
    }), u("scattering", {
      loader: _r(on, {
        width: Mr,
        height: Dr,
        depth: Yn
      }),
      extension: ".bin"
    }), u("transmittance", {
      loader: Vn(on, {
        width: en,
        height: nn
      }),
      extension: ".bin"
    }));
  }
}
function r1({ topRadius: t, bottomRadius: e }, n, a, o) {
  const c = (n - e) / (t - e), u = a * 0.5 + 0.5;
  return o.set(
    je(u, Je),
    je(c, Qe)
  );
}
const i1 = 1 / Math.sqrt(Math.PI), vn = Math.sqrt(3) / (2 * Math.sqrt(Math.PI)), a1 = /* @__PURE__ */ new O(), hn = /* @__PURE__ */ new O(), o1 = /* @__PURE__ */ new Ke(), s1 = /* @__PURE__ */ new t0(), c1 = {
  ellipsoid: Ue.WGS84,
  correctAltitude: !0,
  photometric: !0
};
class L1 extends sr {
  constructor(e, n = ce.DEFAULT) {
    super(), this.atmosphere = n, this.ellipsoidCenter = new O(), this.ellipsoidMatrix = new t0();
    const {
      irradianceTexture: a = null,
      ellipsoid: o,
      correctAltitude: c,
      photometric: u,
      sunDirection: d
    } = { ...c1, ...e };
    this.irradianceTexture = a, this.ellipsoid = o, this.correctAltitude = c, this.photometric = u, this.sunDirection = (d == null ? void 0 : d.clone()) ?? new O();
  }
  update() {
    if (this.irradianceTexture == null)
      return;
    const e = s1.copy(this.ellipsoidMatrix).invert(), a = this.getWorldPosition(a1).applyMatrix4(e).sub(this.ellipsoidCenter);
    if (this.correctAltitude) {
      const S = this.ellipsoid.projectOnSurface(
        a,
        hn
      );
      S != null && a.sub(
        Un(
          S,
          this.atmosphere.bottomRadius,
          this.ellipsoid,
          hn
        )
      );
    }
    const o = a.length(), c = a.dot(this.sunDirection) / o, u = r1(this.atmosphere, o, c, o1), d = gt(this.irradianceTexture, u, hn);
    this.photometric && d.multiply(this.atmosphere.skyRadianceToRelativeLuminance);
    const l = this.ellipsoid.getSurfaceNormal(a).applyMatrix4(this.ellipsoidMatrix), m = this.sh.coefficients;
    m[0].copy(d).multiplyScalar(i1), m[1].copy(d).multiplyScalar(vn * l.y), m[2].copy(d).multiplyScalar(vn * l.z), m[3].copy(d).multiplyScalar(vn * l.x);
  }
}
const u1 = `precision highp float;
precision highp sampler3D;

#define RECIPROCAL_PI (0.3183098861837907)

#include "core/raySphereIntersection"
#include "parameters"
#include "functions"
#include "sky"

uniform vec3 sunDirection;
uniform vec3 moonDirection;
uniform float moonAngularRadius;
uniform float lunarRadianceScale;
uniform vec3 groundAlbedo;

#ifdef HAS_SHADOW_LENGTH
uniform sampler2D shadowLengthBuffer;
#endif // HAS_SHADOW_LENGTH

in vec2 vUv;
in vec3 vCameraPosition;
in vec3 vRayDirection;
in vec3 vEllipsoidCenter;

layout(location = 0) out vec4 outputColor;

#include <mrt_layout>

bool rayIntersectsGround(const vec3 cameraPosition, const vec3 rayDirection) {
  float r = length(cameraPosition);
  float mu = dot(cameraPosition, rayDirection) / r;
  return mu < 0.0 && r * r * (mu * mu - 1.0) + u_bottom_radius * u_bottom_radius >= 0.0;
}

void main() {
  float shadowLength = 0.0;
  #ifdef HAS_SHADOW_LENGTH
  shadowLength = texture(shadowLengthBuffer, vUv).r;
  #endif // HAS_SHADOW_LENGTH

  vec3 cameraPosition = vCameraPosition - vEllipsoidCenter;
  vec3 rayDirection = normalize(vRayDirection);

  #ifdef GROUND_ALBEDO

  bool intersectsGround = rayIntersectsGround(cameraPosition, rayDirection);
  if (intersectsGround) {
    float distanceToGround = raySphereFirstIntersection(
      cameraPosition,
      rayDirection,
      u_bottom_radius
    );
    vec3 groundPosition = rayDirection * distanceToGround + cameraPosition;
    vec3 surfaceNormal = normalize(groundPosition);
    vec3 skyIrradiance;
    vec3 sunIrradiance = GetSunAndSkyIrradiance(
      cameraPosition,
      surfaceNormal,
      sunDirection,
      skyIrradiance
    );
    vec3 transmittance;
    vec3 inscatter = GetSkyRadianceToPoint(
      cameraPosition,
      u_bottom_radius * surfaceNormal,
      shadowLength,
      sunDirection,
      transmittance
    );
    vec3 radiance = groundAlbedo * RECIPROCAL_PI * (sunIrradiance + skyIrradiance);
    outputColor.rgb = radiance * transmittance + inscatter;
  } else {
    outputColor.rgb = getSkyRadiance(
      cameraPosition,
      rayDirection,
      shadowLength,
      sunDirection,
      moonDirection,
      moonAngularRadius,
      lunarRadianceScale
    );
  }

  #else // GROUND_ALBEDO

  outputColor.rgb = getSkyRadiance(
    cameraPosition,
    rayDirection,
    shadowLength,
    sunDirection,
    moonDirection,
    moonAngularRadius,
    lunarRadianceScale
  );

  #endif // GROUND_ALBEDO

  outputColor.a = 1.0;

  #include <mrt_output>
}
`, l1 = `precision highp float;
precision highp sampler3D;

#include "parameters"

uniform mat4 inverseProjectionMatrix;
uniform mat4 inverseViewMatrix;
uniform vec3 cameraPosition;
uniform vec3 ellipsoidCenter;
uniform mat4 inverseEllipsoidMatrix;
uniform vec3 altitudeCorrection;

layout(location = 0) in vec3 position;

out vec2 vUv;
out vec3 vCameraPosition;
out vec3 vRayDirection;
out vec3 vEllipsoidCenter;

void getCameraRay(out vec3 origin, out vec3 direction) {
  bool isPerspective = inverseProjectionMatrix[2][3] != 0.0; // 4th entry in the 3rd column

  if (isPerspective) {
    // Calculate the camera ray for a perspective camera.
    vec4 viewPosition = inverseProjectionMatrix * vec4(position, 1.0);
    vec4 worldDirection = inverseViewMatrix * vec4(viewPosition.xyz, 0.0);
    origin = cameraPosition;
    direction = worldDirection.xyz;
  } else {
    // Unprojected points to calculate direction.
    vec4 nearPoint = inverseProjectionMatrix * vec4(position.xy, -1.0, 1.0);
    vec4 farPoint = inverseProjectionMatrix * vec4(position.xy, -0.9, 1.0);
    nearPoint /= nearPoint.w;
    farPoint /= farPoint.w;

    // Calculate world values
    vec4 worldDirection = inverseViewMatrix * vec4(farPoint.xyz - nearPoint.xyz, 0.0);
    vec4 worldOrigin = inverseViewMatrix * nearPoint;

    // Outputs
    direction = worldDirection.xyz;
    origin = worldOrigin.xyz;
  }
}

void main() {
  vUv = position.xy * 0.5 + 0.5;

  vec3 direction, origin;
  getCameraRay(origin, direction);

  mat3 rotation = mat3(inverseEllipsoidMatrix);
  vCameraPosition = rotation * origin.xyz * METER_TO_LENGTH_UNIT;
  vRayDirection = rotation * direction.xyz;
  vEllipsoidCenter = (ellipsoidCenter + altitudeCorrection) * METER_TO_LENGTH_UNIT;

  gl_Position = vec4(position.xy, 1.0, 1.0);
}
`;
var d1 = Object.defineProperty, It = (t, e, n, a) => {
  for (var o = void 0, c = t.length - 1, u; c >= 0; c--)
    (u = t[c]) && (o = u(e, n, o) || o);
  return o && d1(e, n, o), o;
};
const v1 = {
  ...Pn,
  sun: !0,
  moon: !0,
  moonAngularRadius: 45e-4,
  // ≈ 15.5 arcminutes
  lunarRadianceScale: 1
};
class xt extends Ln {
  constructor(e) {
    const {
      sun: n,
      moon: a,
      moonDirection: o,
      moonAngularRadius: c,
      lunarRadianceScale: u,
      groundAlbedo: d,
      ...l
    } = { ...v1, ...e };
    super({
      name: "SkyMaterial",
      glslVersion: at,
      vertexShader: Se(l1, {
        parameters: Ee
      }),
      fragmentShader: Se(u1, {
        core: { raySphereIntersection: st },
        parameters: Ee,
        functions: xn,
        sky: ut
      }),
      ...l,
      uniforms: {
        inverseProjectionMatrix: new C(new t0()),
        inverseViewMatrix: new C(new t0()),
        moonDirection: new C((o == null ? void 0 : o.clone()) ?? new O()),
        moonAngularRadius: new C(c),
        lunarRadianceScale: new C(u),
        groundAlbedo: new C((d == null ? void 0 : d.clone()) ?? new it(0)),
        shadowLengthBuffer: new C(null),
        ...l.uniforms
      },
      defines: {
        PERSPECTIVE_CAMERA: "1"
      },
      depthTest: !0
    }), this.shadowLength = null, this.sun = n, this.moon = a;
  }
  onBeforeRender(e, n, a, o, c, u) {
    super.onBeforeRender(e, n, a, o, c, u);
    const { uniforms: d, defines: l } = this;
    d.inverseProjectionMatrix.value.copy(a.projectionMatrixInverse), d.inverseViewMatrix.value.copy(a.matrixWorld);
    const m = l.PERSPECTIVE_CAMERA != null, S = a.isPerspectiveCamera === !0;
    S !== m && (S ? l.PERSPECTIVE_CAMERA = "1" : delete l.PERSPECTIVE_CAMERA, this.needsUpdate = !0);
    const g = this.groundAlbedo, I = l.GROUND_ALBEDO != null, D = g.r !== 0 || g.g !== 0 || g.b !== 0;
    D !== I && (D ? this.defines.GROUND_ALBEDO = "1" : delete this.defines.GROUND_ALBEDO, this.needsUpdate = !0);
    const U = this.shadowLength, P = l.HAS_SHADOW_LENGTH != null, H = U != null;
    H !== P && (H ? l.HAS_SHADOW_LENGTH = "1" : (delete l.HAS_SHADOW_LENGTH, d.shadowLengthBuffer.value = null), this.needsUpdate = !0), H && (d.shadowLengthBuffer.value = U.map);
  }
  get moonDirection() {
    return this.uniforms.moonDirection.value;
  }
  get moonAngularRadius() {
    return this.uniforms.moonAngularRadius.value;
  }
  set moonAngularRadius(e) {
    this.uniforms.moonAngularRadius.value = e;
  }
  get lunarRadianceScale() {
    return this.uniforms.lunarRadianceScale.value;
  }
  set lunarRadianceScale(e) {
    this.uniforms.lunarRadianceScale.value = e;
  }
  get groundAlbedo() {
    return this.uniforms.groundAlbedo.value;
  }
}
It([
  E0("SUN")
], xt.prototype, "sun");
It([
  E0("MOON")
], xt.prototype, "moon");
class b1 extends cr {
  constructor(e) {
    super();
    const n = new Int16Array(e), a = new Uint8Array(e), o = new Wn(n, 5), c = new Wn(a, 10);
    this.setAttribute(
      "position",
      new an(o, 3, 0, !0)
    ), this.setAttribute(
      "magnitude",
      new an(c, 1, 6, !0)
    ), this.setAttribute(
      "color",
      new an(c, 3, 7, !0)
    ), this.boundingSphere = new ur(new O(), 1);
  }
}
const h1 = `precision highp float;
precision highp sampler3D;

#include "parameters"
#include "functions"

uniform vec3 sunDirection;

in vec3 vCameraPosition;
in vec3 vRayDirection;
in vec3 vEllipsoidCenter;

layout(location = 0) out vec4 outputColor;

#include <mrt_layout>

in vec3 vColor;

void main() {
  #if !defined(PERSPECTIVE_CAMERA)
  outputColor = vec4(0.0);
  discard; // Rendering celestial objects without perspective doesn't make sense.
  #endif // !defined(PERSPECTIVE_CAMERA)

  #ifdef BACKGROUND
  vec3 cameraPosition = vCameraPosition - vEllipsoidCenter;
  vec3 rayDirection = normalize(vRayDirection);
  float r = length(cameraPosition);
  float mu = dot(cameraPosition, rayDirection) / r;

  if (RayIntersectsGround(r, mu)) {
    discard;
  }

  vec3 transmittance;
  vec3 radiance = GetSkyRadiance(
    vCameraPosition - vEllipsoidCenter,
    normalize(vRayDirection),
    0.0,
    sunDirection,
    transmittance
  );
  radiance += transmittance * vColor;
  outputColor = vec4(radiance, 1.0);
  #else // BACKGROUND
  outputColor = vec4(vColor, 1.0);
  #endif // BACKGROUND

  #include <mrt_output>
}
`, f1 = `precision highp float;
precision highp sampler3D;

#include "parameters"

#define saturate(x) clamp(x, 0.0, 1.0)

uniform mat4 projectionMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 viewMatrix;
uniform mat4 matrixWorld;
uniform vec3 cameraPosition;
uniform float cameraFar;
uniform vec3 ellipsoidCenter;
uniform mat4 inverseEllipsoidMatrix;
uniform vec3 altitudeCorrection;
uniform float pointSize;
uniform vec2 magnitudeRange;
uniform float radianceScale;

layout(location = 0) in vec3 position;
layout(location = 1) in float magnitude;
layout(location = 2) in vec3 color;

out vec3 vCameraPosition;
out vec3 vRayDirection;
out vec3 vEllipsoidCenter;
out vec3 vColor;

void main() {
  // Magnitude is stored between 0 to 1 within the given range.
  float m = mix(magnitudeRange.x, magnitudeRange.y, magnitude);
  vec3 v = pow(vec3(10.0), -vec3(magnitudeRange, m) / 2.5);
  vColor = vec3(radianceScale * color);
  vColor *= saturate((v.z - v.y) / (v.x - v.y));

  #ifdef BACKGROUND
  vec3 worldDirection = normalize(matrixWorld * vec4(position, 1.0)).xyz;
  mat3 rotation = mat3(inverseEllipsoidMatrix);
  vCameraPosition = rotation * cameraPosition * METER_TO_LENGTH_UNIT;
  vRayDirection = rotation * worldDirection;
  vEllipsoidCenter = (ellipsoidCenter + altitudeCorrection) * METER_TO_LENGTH_UNIT;
  gl_Position =
    projectionMatrix * viewMatrix * vec4(cameraPosition + worldDirection * cameraFar, 1.0);
  #else // BACKGROUND
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  #endif // BACKGROUND

  gl_PointSize = pointSize;
}
`;
var p1 = Object.defineProperty, m1 = (t, e, n, a) => {
  for (var o = void 0, c = t.length - 1, u; c >= 0; c--)
    (u = t[c]) && (o = u(e, n, o) || o);
  return o && p1(e, n, o), o;
};
const S1 = {
  ...Pn,
  pointSize: 1,
  radianceScale: 1,
  background: !0
};
class E1 extends Ln {
  constructor(e) {
    const { pointSize: n, radianceScale: a, background: o, ...c } = {
      ...S1,
      ...e
    };
    super({
      name: "StarsMaterial",
      glslVersion: at,
      vertexShader: Se(f1, {
        parameters: Ee
      }),
      fragmentShader: Se(h1, {
        parameters: Ee,
        functions: xn
      }),
      ...c,
      uniforms: {
        projectionMatrix: new C(new t0()),
        modelViewMatrix: new C(new t0()),
        viewMatrix: new C(new t0()),
        matrixWorld: new C(new t0()),
        cameraFar: new C(0),
        pointSize: new C(0),
        magnitudeRange: new C(new Ke(-2, 8)),
        radianceScale: new C(a),
        ...c.uniforms
      },
      defines: {
        PERSPECTIVE_CAMERA: "1"
      }
    }), this.pointSize = n, this.background = o;
  }
  onBeforeRender(e, n, a, o, c, u) {
    super.onBeforeRender(e, n, a, o, c, u);
    const d = this.uniforms;
    d.projectionMatrix.value.copy(a.projectionMatrix), d.modelViewMatrix.value.copy(a.modelViewMatrix), d.viewMatrix.value.copy(a.matrixWorldInverse), d.matrixWorld.value.copy(c.matrixWorld), d.cameraFar.value = a.far, d.pointSize.value = this.pointSize * e.getPixelRatio();
    const l = a.isPerspectiveCamera === !0;
    this.defines.PERSPECTIVE_CAMERA != null !== l && (l ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = !0);
  }
  get magnitudeRange() {
    return this.uniforms.magnitudeRange.value;
  }
  get radianceScale() {
    return this.uniforms.radianceScale.value;
  }
  set radianceScale(e) {
    this.uniforms.radianceScale.value = e;
  }
}
m1([
  E0("BACKGROUND")
], E1.prototype, "background");
const _1 = /* @__PURE__ */ new O(), g1 = /* @__PURE__ */ new t0(), w1 = {
  ellipsoid: Ue.WGS84,
  correctAltitude: !0,
  photometric: !0,
  distance: 1
};
class F1 extends lr {
  constructor(e, n = ce.DEFAULT) {
    super(), this.atmosphere = n, this.ellipsoidCenter = new O(), this.ellipsoidMatrix = new t0();
    const {
      irradianceTexture: a = null,
      ellipsoid: o,
      correctAltitude: c,
      photometric: u,
      sunDirection: d,
      distance: l
    } = { ...w1, ...e };
    this.transmittanceTexture = a, this.ellipsoid = o, this.correctAltitude = c, this.photometric = u, this.sunDirection = (d == null ? void 0 : d.clone()) ?? new O(), this.distance = l;
  }
  update() {
    if (this.position.copy(this.sunDirection).applyMatrix4(this.ellipsoidMatrix).normalize().multiplyScalar(this.distance).add(this.target.position), this.transmittanceTexture == null)
      return;
    const e = g1.copy(this.ellipsoidMatrix).invert(), n = this.target.getWorldPosition(_1).applyMatrix4(e).sub(this.ellipsoidCenter);
    Gi(
      this.transmittanceTexture,
      n,
      this.sunDirection,
      this.color,
      {
        ellipsoid: this.ellipsoid,
        correctAltitude: this.correctAltitude,
        photometric: this.photometric
      },
      this.atmosphere
    );
  }
}
export {
  N0 as A,
  S1 as B,
  E1 as C,
  x1 as D,
  w1 as E,
  F1 as F,
  Je as I,
  pe as M,
  P1 as P,
  Mn as S,
  en as T,
  Hr as a,
  Pn as b,
  Ln as c,
  ce as d,
  D1 as e,
  N1 as f,
  Mi as g,
  O1 as h,
  U1 as i,
  Qe as j,
  Dn as k,
  Nn as l,
  On as m,
  Mr as n,
  Dr as o,
  Yn as p,
  nn as q,
  I1 as r,
  M1 as s,
  Un as t,
  Gi as u,
  c1 as v,
  L1 as w,
  v1 as x,
  xt as y,
  b1 as z
};
//# sourceMappingURL=shared.js.map
