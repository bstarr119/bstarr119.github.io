import { jsx as g, jsxs as N, Fragment as O } from "react/jsx-runtime";
import { useThree as R, useFrame as v, extend as _, useLoader as I } from "@react-three/fiber";
import { EffectComposerContext as z } from "@react-three/postprocessing";
import { RenderPass as G } from "postprocessing";
import { createContext as W, forwardRef as C, useRef as P, useState as E, useEffect as D, useMemo as T, useImperativeHandle as H, useContext as w } from "react";
import { Matrix4 as k, Vector3 as A, Texture as K, Object3D as Q } from "three";
import { Ellipsoid as V, DEFAULT_STBN_URL as X, STBNLoader as Y, ArrayBufferLoader as q } from "@takram/three-geospatial";
import { D as B, P as j, g as J, e as Z, f as $, a as ee, A as te, x as re, y as oe, r as U, w as ne, v as se, B as ie, s as ae, z as ce, C as le, F as ue, E as pe } from "./shared.js";
import { ScreenQuad as de } from "@react-three/drei";
const M = /* @__PURE__ */ W({}), Ce = /* @__PURE__ */ C(function({
  textures: t = B,
  ellipsoid: n = V.WGS84,
  correctAltitude: s = !0,
  photometric: o = !0,
  date: r,
  children: d
}, a) {
  const p = P({
    sunDirection: new A(),
    moonDirection: new A(),
    rotationMatrix: new k(),
    ellipsoidCenter: new A(),
    ellipsoidMatrix: new k(),
    overlay: null,
    shadow: null,
    shadowLength: null
  }), l = R(({ gl: u }) => u), [c, f] = E(
    typeof t != "string" ? t : void 0
  );
  D(() => {
    if (typeof t == "string") {
      const u = new j();
      u.setTypeFromRenderer(l), (async () => {
        f(await u.loadAsync(t));
      })().catch((h) => {
        console.error(h);
      });
    } else
      f(t);
  }, [t, l]);
  const y = T(
    () => ({
      textures: c,
      ellipsoid: n,
      correctAltitude: s,
      photometric: o,
      transientStates: p.current
    }),
    [c, n, s, o]
  ), m = T(() => {
    const { sunDirection: u, moonDirection: h, rotationMatrix: S } = p.current;
    return (x) => {
      J(x, S), Z(x, u).applyMatrix4(S), $(x, h).applyMatrix4(S);
    };
  }, []), e = r != null && !isNaN(+r) ? +r : void 0;
  return D(() => {
    e != null && m(e);
  }, [e, m]), H(
    a,
    () => ({
      ...p.current,
      textures: c,
      updateByDate: m
    }),
    [c, m]
  ), /* @__PURE__ */ g(M.Provider, { value: y, children: d });
});
function b(i) {
  const {
    irradianceTexture: t,
    scatteringTexture: n,
    transmittanceTexture: s,
    ellipsoid: o,
    correctAltitude: r,
    photometric: d,
    sunDirection: a,
    sunAngularRadius: p,
    renderTargetCount: l,
    ...c
  } = i;
  return [
    {
      irradianceTexture: t,
      scatteringTexture: n,
      transmittanceTexture: s,
      ellipsoid: o,
      correctAltitude: r,
      photometric: d,
      sunDirection: a,
      sunAngularRadius: p,
      renderTargetCount: l
    },
    c
  ];
}
function me(i) {
  const [t, n] = E(
    typeof i != "string" ? i ?? null : null
  );
  return D(() => {
    if (typeof i == "string") {
      const s = new Y();
      (async () => {
        n(await s.loadAsync(i));
      })().catch((o) => {
        console.error(o);
      });
    } else
      n(i ?? null);
  }, [i]), t;
}
const Me = /* @__PURE__ */ C(function({ stbnTexture: t = X, ...n }, s) {
  const { textures: o, transientStates: r, ...d } = w(M), [a, { blendFunction: p, ...l }] = b({
    ...ee,
    ...d,
    ...o,
    ...n
  }), c = w(z), { normalPass: f, camera: y } = c, m = "geometryPass" in c && c.geometryPass instanceof G && "geometryTexture" in c.geometryPass && c.geometryPass.geometryTexture instanceof K ? c.geometryPass.geometryTexture : void 0, e = T(
    () => new te(void 0, { blendFunction: p }),
    [p]
  );
  D(() => () => {
    e.dispose();
  }, [e]);
  const [u, h] = E(!1);
  v(() => {
    r != null && (e.sunDirection.copy(r.sunDirection), e.moonDirection.copy(r.moonDirection), e.ellipsoidCenter.copy(r.ellipsoidCenter), e.ellipsoidMatrix.copy(r.ellipsoidMatrix), e.overlay = r.overlay, e.shadow = r.shadow, e.shadowLength = r.shadowLength, !u && e.shadow != null && h(!0));
  });
  const S = me(
    u ? t : void 0
  );
  return /* @__PURE__ */ g(
    "primitive",
    {
      ref: s,
      object: e,
      mainCamera: y,
      normalBuffer: m ?? (f == null ? void 0 : f.texture) ?? null,
      ...a,
      ...l,
      stbnTexture: S,
      octEncodedNormal: m != null
    }
  );
}), ve = /* @__PURE__ */ C(
  function(t, n) {
    const { textures: s, transientStates: o, ...r } = w(M), [
      d,
      {
        sun: a,
        moon: p,
        moonDirection: l,
        moonAngularRadius: c,
        lunarRadianceScale: f,
        groundAlbedo: y,
        ...m
      }
    ] = b({
      ...re,
      ...r,
      ...s,
      ...t
    }), e = T(() => new oe(), []);
    return D(() => () => {
      e.dispose();
    }, [e]), v(() => {
      o != null && (e.sunDirection.copy(o.sunDirection), e.moonDirection.copy(o.moonDirection), e.ellipsoidCenter.copy(o.ellipsoidCenter), e.ellipsoidMatrix.copy(o.ellipsoidMatrix), e.shadowLength = o.shadowLength);
    }), /* @__PURE__ */ g(
      de,
      {
        renderOrder: U,
        ...m,
        ref: n,
        children: /* @__PURE__ */ g(
          "primitive",
          {
            object: e,
            ...d,
            sun: a,
            moon: p,
            moonDirection: l,
            moonAngularRadius: c,
            lunarRadianceScale: f,
            groundAlbedo: y
          }
        )
      }
    );
  }
);
function F(i) {
  return (t) => {
    i.forEach((n) => {
      typeof n == "function" ? n(t) : n != null && (n.current = t);
    });
  };
}
const Le = /* @__PURE__ */ C(
  function(t, n) {
    const { textures: s, transientStates: o, ...r } = w(M), d = P(null);
    return v(() => {
      const a = d.current;
      a != null && o != null && (a.sunDirection.copy(o.sunDirection), a.ellipsoidCenter.copy(o.ellipsoidCenter), a.ellipsoidMatrix.copy(o.ellipsoidMatrix), a.update());
    }), _({ SkyLightProbe: ne }), /* @__PURE__ */ g(
      "skyLightProbe",
      {
        ref: F([d, n]),
        ...se,
        ...r,
        ...s,
        ...t
      }
    );
  }
), Pe = /* @__PURE__ */ C(
  function({ data: t = ae, ...n }, s) {
    const { textures: o, transientStates: r, ...d } = w(M), [
      a,
      { pointSize: p, radianceScale: l, background: c, ...f }
    ] = b({
      ...ie,
      ...d,
      ...o,
      ...n
    }), [y, m] = E(
      typeof t != "string" ? t : void 0
    );
    D(() => {
      if (typeof t == "string") {
        const x = new q();
        (async () => {
          m(await x.loadAsync(t));
        })().catch((L) => {
          console.error(L);
        });
      } else
        m(t);
    }, [t]);
    const e = T(
      () => y != null ? new ce(y) : void 0,
      [y]
    );
    D(() => () => {
      e == null || e.dispose();
    }, [e]);
    const u = T(() => new le(), []);
    D(() => () => {
      u.dispose();
    }, [u]);
    const h = P(null);
    v(({ camera: x }) => {
      var L;
      r != null && x.isPerspectiveCamera === !0 && (u.sunDirection.copy(r.sunDirection), (L = h.current) == null || L.setRotationFromMatrix(r.rotationMatrix), u.ellipsoidCenter.copy(r.ellipsoidCenter), u.ellipsoidMatrix.copy(r.ellipsoidMatrix));
    });
    const S = R(({ camera: x }) => x);
    return e == null || S.isPerspectiveCamera !== !0 ? null : /* @__PURE__ */ N(
      "points",
      {
        ref: F([h, s]),
        frustumCulled: !1,
        renderOrder: U + 1,
        ...f,
        children: [
          /* @__PURE__ */ g("primitive", { object: e }),
          /* @__PURE__ */ g(
            "primitive",
            {
              object: u,
              ...a,
              pointSize: p,
              radianceScale: l,
              background: c,
              depthTest: !0,
              depthWrite: !1
            }
          )
        ]
      }
    );
  }
), Ee = /* @__PURE__ */ C(function({ position: t, ...n }, s) {
  const { textures: o, transientStates: r, ...d } = w(M), a = P(null);
  v(() => {
    const l = a.current;
    l != null && r != null && (l.sunDirection.copy(r.sunDirection), l.ellipsoidCenter.copy(r.ellipsoidCenter), l.ellipsoidMatrix.copy(r.ellipsoidMatrix), l.update());
  });
  const p = T(() => new Q(), []);
  return _({ SunDirectionalLight: ue }), /* @__PURE__ */ N(O, { children: [
    /* @__PURE__ */ g(
      "sunDirectionalLight",
      {
        ref: F([a, s]),
        ...pe,
        ...d,
        ...o,
        ...n,
        target: p
      }
    ),
    /* @__PURE__ */ g("primitive", { object: p, position: t })
  ] });
});
function Ae(i = B) {
  const t = R(({ gl: s }) => s);
  return { textures: I(j, i, (s) => {
    s.setTypeFromRenderer(t);
  }) };
}
export {
  Me as AerialPerspective,
  Ce as Atmosphere,
  M as AtmosphereContext,
  ve as Sky,
  Le as SkyLight,
  Pe as Stars,
  Ee as SunLight,
  b as separateProps,
  Ae as useAtmosphereTextureProps
};
//# sourceMappingURL=r3f.js.map
