import { BlendFunction, Effect } from 'postprocessing';
import { Camera, Matrix4, Uniform, Vector2, Vector3, Data3DTexture, DataTexture, Texture, WebGLRenderer, WebGLRenderTarget } from 'three';
import { Ellipsoid, UniformMap } from '@takram/three-geospatial';
import { AtmosphereParameters } from './AtmosphereParameters';
import { AtmosphereOverlay, AtmosphereShadow, AtmosphereShadowLength } from './types';
export interface AerialPerspectiveEffectOptions {
    blendFunction?: BlendFunction;
    normalBuffer?: Texture | null;
    octEncodedNormal?: boolean;
    reconstructNormal?: boolean;
    irradianceTexture?: DataTexture | null;
    scatteringTexture?: Data3DTexture | null;
    transmittanceTexture?: DataTexture | null;
    ellipsoid?: Ellipsoid;
    correctAltitude?: boolean;
    correctGeometricError?: boolean;
    photometric?: boolean;
    sunDirection?: Vector3;
    sunIrradiance?: boolean;
    skyIrradiance?: boolean;
    transmittance?: boolean;
    inscatter?: boolean;
    irradianceScale?: number;
    sky?: boolean;
    sun?: boolean;
    moon?: boolean;
    moonDirection?: Vector3;
    moonAngularRadius?: number;
    lunarRadianceScale?: number;
}
export interface AerialPerspectiveEffectUniforms {
    normalBuffer: Uniform<Texture | null>;
    projectionMatrix: Uniform<Matrix4>;
    viewMatrix: Uniform<Matrix4>;
    inverseProjectionMatrix: Uniform<Matrix4>;
    inverseViewMatrix: Uniform<Matrix4>;
    cameraPosition: Uniform<Vector3>;
    bottomRadius: Uniform<number>;
    ellipsoidRadii: Uniform<Vector3>;
    ellipsoidCenter: Uniform<Vector3>;
    inverseEllipsoidMatrix: Uniform<Matrix4>;
    altitudeCorrection: Uniform<Vector3>;
    sunDirection: Uniform<Vector3>;
    irradianceScale: Uniform<number>;
    idealSphereAlpha: Uniform<number>;
    moonDirection: Uniform<Vector3>;
    moonAngularRadius: Uniform<number>;
    lunarRadianceScale: Uniform<number>;
    overlayBuffer: Uniform<Texture | null>;
    shadowBuffer: Uniform<Texture | null>;
    shadowMapSize: Uniform<Vector2>;
    shadowIntervals: Uniform<Vector2[]>;
    shadowMatrices: Uniform<Matrix4[]>;
    inverseShadowMatrices: Uniform<Matrix4[]>;
    shadowFar: Uniform<number>;
    shadowTopHeight: Uniform<number>;
    shadowRadius: Uniform<number>;
    stbnTexture: Uniform<Data3DTexture | null>;
    frame: Uniform<number>;
    shadowLengthBuffer: Uniform<Texture | null>;
    u_solar_irradiance: Uniform<Vector3>;
    u_sun_angular_radius: Uniform<number>;
    u_bottom_radius: Uniform<number>;
    u_top_radius: Uniform<number>;
    u_rayleigh_scattering: Uniform<Vector3>;
    u_mie_scattering: Uniform<Vector3>;
    u_mie_phase_function_g: Uniform<number>;
    u_mu_s_min: Uniform<number>;
    u_irradiance_texture: Uniform<DataTexture | null>;
    u_scattering_texture: Uniform<Data3DTexture | null>;
    u_single_mie_scattering_texture: Uniform<Data3DTexture | null>;
    u_transmittance_texture: Uniform<DataTexture | null>;
}
export declare const aerialPerspectiveEffectOptionsDefaults: {
    blendFunction: BlendFunction;
    octEncodedNormal: false;
    reconstructNormal: false;
    ellipsoid: Ellipsoid;
    correctAltitude: true;
    correctGeometricError: true;
    photometric: true;
    sunIrradiance: false;
    skyIrradiance: false;
    transmittance: true;
    inscatter: true;
    irradianceScale: number;
    sky: false;
    sun: true;
    moon: true;
    moonAngularRadius: number;
    lunarRadianceScale: number;
};
export declare class AerialPerspectiveEffect extends Effect {
    private camera;
    private readonly atmosphere;
    uniforms: UniformMap<AerialPerspectiveEffectUniforms>;
    private _ellipsoid;
    readonly ellipsoidMatrix: Matrix4;
    correctAltitude: boolean;
    overlay: AtmosphereOverlay | null;
    shadow: AtmosphereShadow | null;
    shadowLength: AtmosphereShadowLength | null;
    constructor(camera?: Camera, options?: AerialPerspectiveEffectOptions, atmosphere?: AtmosphereParameters);
    get mainCamera(): Camera;
    set mainCamera(value: Camera);
    private copyCameraSettings;
    private updateComposition;
    update(renderer: WebGLRenderer, inputBuffer: WebGLRenderTarget, deltaTime?: number): void;
    get normalBuffer(): Texture | null;
    set normalBuffer(value: Texture | null);
    octEncodedNormal: boolean;
    reconstructNormal: boolean;
    get irradianceTexture(): DataTexture | null;
    set irradianceTexture(value: DataTexture | null);
    get scatteringTexture(): Data3DTexture | null;
    set scatteringTexture(value: Data3DTexture | null);
    get transmittanceTexture(): DataTexture | null;
    set transmittanceTexture(value: DataTexture | null);
    get ellipsoid(): Ellipsoid;
    set ellipsoid(value: Ellipsoid);
    get ellipsoidCenter(): Vector3;
    correctGeometricError: boolean;
    photometric: boolean;
    get sunDirection(): Vector3;
    sunIrradiance: boolean;
    skyIrradiance: boolean;
    transmittance: boolean;
    inscatter: boolean;
    get irradianceScale(): number;
    set irradianceScale(value: number);
    sky: boolean;
    sun: boolean;
    moon: boolean;
    get moonDirection(): Vector3;
    get moonAngularRadius(): number;
    set moonAngularRadius(value: number);
    get lunarRadianceScale(): number;
    set lunarRadianceScale(value: number);
    get stbnTexture(): Data3DTexture | null;
    set stbnTexture(value: Data3DTexture | null);
    get shadowRadius(): number;
    set shadowRadius(value: number);
    shadowSampleCount: number;
}
