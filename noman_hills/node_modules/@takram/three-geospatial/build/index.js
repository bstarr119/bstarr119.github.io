import { Loader as qt, FileLoader as _i, BufferGeometry as bi, BufferAttribute as zr, Box3 as Ni, Vector3 as Re, Sphere as Oi, ByteType as mi, UnsignedByteType as kr, ShortType as Ui, UnsignedShortType as Ci, IntType as Ri, UnsignedIntType as xi, HalfFloatType as lt, FloatType as ft, LinearFilter as zt, RGBAFormat as ln, Data3DTexture as un, DataTexture as Fi, MathUtils as ye, Material as Vt, REVISION as Li, DataTextureLoader as Pi, RedFormat as hn, DataUtils as Zr, Quaternion as Mi, Matrix4 as Di, Ray as Bi, RepeatWrapping as sr, NearestFilter as Hr, Vector2 as fn } from "three";
import { E as Gr, G as st } from "./shared.js";
import { a as oa } from "./shared.js";
var zi = process.env.NODE_ENV === "production", Wr = "Invariant failed";
function vn(r, e) {
  if (!r) {
    if (zi)
      throw new Error(Wr);
    var i = Wr;
    throw new Error(i);
  }
}
class ki extends qt {
  load(e, i, s, o) {
    const c = new _i(this.manager);
    c.setResponseType("arraybuffer"), c.setRequestHeader(this.requestHeader), c.setPath(this.path), c.setWithCredentials(this.withCredentials), c.load(
      e,
      (l) => {
        vn(l instanceof ArrayBuffer);
        try {
          i(l);
        } catch (v) {
          o != null ? o(v) : console.error(v), this.manager.itemError(e);
        }
      },
      s,
      o
    );
  }
}
function go(r) {
}
function So(r) {
  var c;
  const { attributes: e, index: i, boundingBox: s, boundingSphere: o } = r;
  return [
    { attributes: e, index: i, boundingBox: s, boundingSphere: o },
    [
      ...Object.values(r.attributes).map(
        (l) => l.array.buffer
      ),
      (c = r.index) == null ? void 0 : c.array.buffer
    ].filter((l) => l != null)
  ];
}
function To(r, e = new bi()) {
  for (const [i, s] of Object.entries(r.attributes))
    e.setAttribute(
      i,
      new zr(
        s.array,
        s.itemSize,
        s.normalized
      )
    );
  if (e.index = r.index != null ? new zr(
    r.index.array,
    r.index.itemSize,
    r.index.normalized
  ) : null, r.boundingBox != null) {
    const { min: i, max: s } = r.boundingBox;
    e.boundingBox = new Ni(
      new Re(i.x, i.y, i.z),
      new Re(s.x, s.y, s.z)
    );
  }
  if (r.boundingSphere != null) {
    const { center: i, radius: s } = r.boundingSphere;
    e.boundingSphere = new Oi(
      new Re(i.x, i.y, i.z),
      s
    );
  }
  return e;
}
const Zi = 128, Hi = 128, Gi = 64, Wi = "9627216cc50057994c98a2118f3c4a23765d43b9", Eo = `https://media.githubusercontent.com/media/takram-design-engineering/three-geospatial/${Wi}/packages/core/assets/stbn.bin`, Xi = "This is not an object", Yi = "This is not a Float16Array object", Xr = "This constructor is not a subclass of Float16Array", yn = "The constructor property value is not an object", qi = "Species constructor didn't return TypedArray object", Vi = "Derived constructor created TypedArray object which was too small length", vt = "Attempting to access detached ArrayBuffer", yr = "Cannot convert undefined or null to object", pr = "Cannot mix BigInt and other types, use explicit conversions", Yr = "@@iterator property is not callable", qr = "Reduce of empty array with no initial value", Ji = "The comparison function must be either a function or undefined", or = "Offset is out of bounds";
function Z(r) {
  return (e, ...i) => ie(r, e, i);
}
function $e(r, e) {
  return Z(
    Ye(
      r,
      e
    ).get
  );
}
const {
  apply: ie,
  construct: ut,
  defineProperty: Vr,
  get: ar,
  getOwnPropertyDescriptor: Ye,
  getPrototypeOf: At,
  has: dr,
  ownKeys: pn,
  set: Jr,
  setPrototypeOf: dn
} = Reflect, $i = Proxy, {
  EPSILON: Qi,
  MAX_SAFE_INTEGER: $r,
  isFinite: wn,
  isNaN: qe
} = Number, {
  iterator: Ie,
  species: ji,
  toStringTag: Ir,
  for: Ki
} = Symbol, Ve = Object, {
  create: Jt,
  defineProperty: gt,
  freeze: es,
  is: Qr
} = Ve, wr = Ve.prototype, ts = (
  /** @type {any} */
  wr.__lookupGetter__ ? Z(
    /** @type {any} */
    wr.__lookupGetter__
  ) : (r, e) => {
    if (r == null)
      throw X(
        yr
      );
    let i = Ve(r);
    do {
      const s = Ye(i, e);
      if (s !== void 0)
        return Ce(s, "get") ? s.get : void 0;
    } while ((i = At(i)) !== null);
  }
), Ce = (
  /** @type {any} */
  Ve.hasOwn || Z(wr.hasOwnProperty)
), An = Array, gn = An.isArray, $t = An.prototype, rs = Z($t.join), ns = Z($t.push), is = Z(
  $t.toLocaleString
), _r = $t[Ie], ss = Z(_r), {
  abs: os,
  trunc: Sn
} = Math, Qt = ArrayBuffer, as = Qt.isView, Tn = Qt.prototype, cs = Z(Tn.slice), ls = $e(Tn, "byteLength"), Ar = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : null, us = Ar && $e(Ar.prototype, "byteLength"), br = At(Uint8Array), hs = br.from, Q = br.prototype, fs = Q[Ie], vs = Z(Q.keys), ys = Z(
  Q.values
), ps = Z(
  Q.entries
), ds = Z(Q.set), jr = Z(
  Q.reverse
), ws = Z(Q.fill), As = Z(
  Q.copyWithin
), Kr = Z(Q.sort), ot = Z(Q.slice), gs = Z(
  Q.subarray
), $ = $e(
  Q,
  "buffer"
), Be = $e(
  Q,
  "byteOffset"
), x = $e(
  Q,
  "length"
), En = $e(
  Q,
  Ir
), Ss = Uint8Array, ce = Uint16Array, en = (...r) => ie(hs, ce, r), Nr = Uint32Array, Ts = Float32Array, ze = At([][Ie]()), jt = Z(ze.next), Es = Z(function* () {
}().next), Is = At(ze), _s = DataView.prototype, bs = Z(
  _s.getUint16
), X = TypeError, cr = RangeError, In = WeakSet, _n = In.prototype, Ns = Z(_n.add), Os = Z(_n.has), Kt = WeakMap, Or = Kt.prototype, kt = Z(Or.get), ms = Z(Or.has), mr = Z(Or.set), bn = new Kt(), Us = Jt(null, {
  next: {
    value: function() {
      const e = kt(bn, this);
      return jt(e);
    }
  },
  [Ie]: {
    value: function() {
      return this;
    }
  }
});
function ht(r) {
  if (r[Ie] === _r && ze.next === jt)
    return r;
  const e = Jt(Us);
  return mr(bn, e, ss(r)), e;
}
const Nn = new Kt(), On = Jt(Is, {
  next: {
    value: function() {
      const e = kt(Nn, this);
      return Es(e);
    },
    writable: !0,
    configurable: !0
  }
});
for (const r of pn(ze))
  r !== "next" && gt(On, r, Ye(ze, r));
function tn(r) {
  const e = Jt(On);
  return mr(Nn, e, r), e;
}
function Zt(r) {
  return r !== null && typeof r == "object" || typeof r == "function";
}
function rn(r) {
  return r !== null && typeof r == "object";
}
function Ht(r) {
  return En(r) !== void 0;
}
function gr(r) {
  const e = En(r);
  return e === "BigInt64Array" || e === "BigUint64Array";
}
function Cs(r) {
  try {
    return gn(r) ? !1 : (ls(
      /** @type {any} */
      r
    ), !0);
  } catch {
    return !1;
  }
}
function mn(r) {
  if (Ar === null)
    return !1;
  try {
    return us(
      /** @type {any} */
      r
    ), !0;
  } catch {
    return !1;
  }
}
function Rs(r) {
  return Cs(r) || mn(r);
}
function nn(r) {
  return gn(r) ? r[Ie] === _r && ze.next === jt : !1;
}
function xs(r) {
  return Ht(r) ? r[Ie] === fs && ze.next === jt : !1;
}
function xt(r) {
  if (typeof r != "string")
    return !1;
  const e = +r;
  return r !== e + "" || !wn(e) ? !1 : e === Sn(e);
}
const Gt = Ki("__Float16Array__");
function Fs(r) {
  if (!rn(r))
    return !1;
  const e = At(r);
  if (!rn(e))
    return !1;
  const i = e.constructor;
  if (i === void 0)
    return !1;
  if (!Zt(i))
    throw X(yn);
  return dr(i, Gt);
}
const Sr = 1 / Qi;
function Ls(r) {
  return r + Sr - Sr;
}
const Un = 6103515625e-14, Ps = 65504, Cn = 9765625e-10, sn = Cn * Un, Ms = Cn * Sr;
function Ds(r) {
  const e = +r;
  if (!wn(e) || e === 0)
    return e;
  const i = e > 0 ? 1 : -1, s = os(e);
  if (s < Un)
    return i * Ls(s / sn) * sn;
  const o = (1 + Ms) * s, c = o - (o - s);
  return c > Ps || qe(c) ? i * (1 / 0) : i * c;
}
const Rn = new Qt(4), xn = new Ts(Rn), Fn = new Nr(Rn), we = new ce(512), Ae = new Ss(512);
for (let r = 0; r < 256; ++r) {
  const e = r - 127;
  e < -24 ? (we[r] = 0, we[r | 256] = 32768, Ae[r] = 24, Ae[r | 256] = 24) : e < -14 ? (we[r] = 1024 >> -e - 14, we[r | 256] = 1024 >> -e - 14 | 32768, Ae[r] = -e - 1, Ae[r | 256] = -e - 1) : e <= 15 ? (we[r] = e + 15 << 10, we[r | 256] = e + 15 << 10 | 32768, Ae[r] = 13, Ae[r | 256] = 13) : e < 128 ? (we[r] = 31744, we[r | 256] = 64512, Ae[r] = 24, Ae[r | 256] = 24) : (we[r] = 31744, we[r | 256] = 64512, Ae[r] = 13, Ae[r | 256] = 13);
}
function Ee(r) {
  xn[0] = Ds(r);
  const e = Fn[0], i = e >> 23 & 511;
  return we[i] + ((e & 8388607) >> Ae[i]);
}
const Ur = new Nr(2048);
for (let r = 1; r < 1024; ++r) {
  let e = r << 13, i = 0;
  for (; (e & 8388608) === 0; )
    e <<= 1, i -= 8388608;
  e &= -8388609, i += 947912704, Ur[r] = e | i;
}
for (let r = 1024; r < 2048; ++r)
  Ur[r] = 939524096 + (r - 1024 << 13);
const Qe = new Nr(64);
for (let r = 1; r < 31; ++r)
  Qe[r] = r << 23;
Qe[31] = 1199570944;
Qe[32] = 2147483648;
for (let r = 33; r < 63; ++r)
  Qe[r] = 2147483648 + (r - 32 << 23);
Qe[63] = 3347054592;
const Ln = new ce(64);
for (let r = 1; r < 64; ++r)
  r !== 32 && (Ln[r] = 1024);
function L(r) {
  const e = r >> 10;
  return Fn[0] = Ur[Ln[e] + (r & 1023)] + Qe[e], xn[0];
}
function Ue(r) {
  const e = +r;
  return qe(e) || e === 0 ? 0 : Sn(e);
}
function lr(r) {
  const e = Ue(r);
  return e < 0 ? 0 : e < $r ? e : $r;
}
function Ft(r, e) {
  if (!Zt(r))
    throw X(Xi);
  const i = r.constructor;
  if (i === void 0)
    return e;
  if (!Zt(i))
    throw X(yn);
  const s = i[ji];
  return s ?? e;
}
function yt(r) {
  if (mn(r))
    return !1;
  try {
    return cs(r, 0, 0), !1;
  } catch {
  }
  return !0;
}
function on(r, e) {
  const i = qe(r), s = qe(e);
  if (i && s)
    return 0;
  if (i)
    return 1;
  if (s || r < e)
    return -1;
  if (r > e)
    return 1;
  if (r === 0 && e === 0) {
    const o = Qr(r, 0), c = Qr(e, 0);
    if (!o && c)
      return -1;
    if (o && !c)
      return 1;
  }
  return 0;
}
const Cr = 2, Wt = new Kt();
function Xe(r) {
  return ms(Wt, r) || !as(r) && Fs(r);
}
function R(r) {
  if (!Xe(r))
    throw X(Yi);
}
function Lt(r, e) {
  const i = Xe(r), s = Ht(r);
  if (!i && !s)
    throw X(qi);
  if (typeof e == "number") {
    let o;
    if (i) {
      const c = O(r);
      o = x(c);
    } else
      o = x(r);
    if (o < e)
      throw X(
        Vi
      );
  }
  if (gr(r))
    throw X(pr);
}
function O(r) {
  const e = kt(Wt, r);
  if (e !== void 0) {
    const o = $(e);
    if (yt(o))
      throw X(vt);
    return e;
  }
  const i = (
    /** @type {any} */
    r.buffer
  );
  if (yt(i))
    throw X(vt);
  const s = ut(B, [
    i,
    /** @type {any} */
    r.byteOffset,
    /** @type {any} */
    r.length
  ], r.constructor);
  return kt(Wt, s);
}
function an(r) {
  const e = x(r), i = [];
  for (let s = 0; s < e; ++s)
    i[s] = L(r[s]);
  return i;
}
const Pn = new In();
for (const r of pn(Q)) {
  if (r === Ir)
    continue;
  const e = Ye(Q, r);
  Ce(e, "get") && typeof e.get == "function" && Ns(Pn, e.get);
}
const Bs = es(
  /** @type {ProxyHandler<Float16BitsArray>} */
  {
    get(r, e, i) {
      return xt(e) && Ce(r, e) ? L(ar(r, e)) : Os(Pn, ts(r, e)) ? ar(r, e) : ar(r, e, i);
    },
    set(r, e, i, s) {
      return xt(e) && Ce(r, e) ? Jr(r, e, Ee(i)) : Jr(r, e, i, s);
    },
    getOwnPropertyDescriptor(r, e) {
      if (xt(e) && Ce(r, e)) {
        const i = Ye(r, e);
        return i.value = L(i.value), i;
      }
      return Ye(r, e);
    },
    defineProperty(r, e, i) {
      return xt(e) && Ce(r, e) && Ce(i, "value") && (i.value = Ee(i.value)), Vr(r, e, i);
    }
  }
);
class B {
  /** @see https://tc39.es/ecma262/#sec-typedarray */
  constructor(e, i, s) {
    let o;
    if (Xe(e))
      o = ut(ce, [O(e)], new.target);
    else if (Zt(e) && !Rs(e)) {
      let l, v;
      if (Ht(e)) {
        l = e, v = x(e);
        const y = $(e);
        if (yt(y))
          throw X(vt);
        if (gr(e))
          throw X(pr);
        const E = new Qt(
          v * Cr
        );
        o = ut(ce, [E], new.target);
      } else {
        const y = e[Ie];
        if (y != null && typeof y != "function")
          throw X(Yr);
        y != null ? nn(e) ? (l = e, v = e.length) : (l = [.../** @type {Iterable<unknown>} */
        e], v = l.length) : (l = /** @type {ArrayLike<unknown>} */
        e, v = lr(l.length)), o = ut(ce, [v], new.target);
      }
      for (let y = 0; y < v; ++y)
        o[y] = Ee(l[y]);
    } else
      o = ut(ce, arguments, new.target);
    const c = (
      /** @type {any} */
      new $i(o, Bs)
    );
    return mr(Wt, c, o), c;
  }
  /**
   * limitation: `Object.getOwnPropertyNames(Float16Array)` or `Reflect.ownKeys(Float16Array)` include this key
   * @see https://tc39.es/ecma262/#sec-%typedarray%.from
   */
  static from(e, ...i) {
    const s = this;
    if (!dr(s, Gt))
      throw X(
        Xr
      );
    if (s === B) {
      if (Xe(e) && i.length === 0) {
        const b = O(e), U = new ce(
          $(b),
          Be(b),
          x(b)
        );
        return new B(
          $(ot(U))
        );
      }
      if (i.length === 0)
        return new B(
          $(
            en(e, Ee)
          )
        );
      const y = i[0], E = i[1];
      return new B(
        $(
          en(e, function(b, ...U) {
            return Ee(
              ie(y, this, [b, ...ht(U)])
            );
          }, E)
        )
      );
    }
    let o, c;
    const l = e[Ie];
    if (l != null && typeof l != "function")
      throw X(Yr);
    if (l != null)
      nn(e) ? (o = e, c = e.length) : xs(e) ? (o = e, c = x(e)) : (o = [...e], c = o.length);
    else {
      if (e == null)
        throw X(
          yr
        );
      o = Ve(e), c = lr(o.length);
    }
    const v = new s(c);
    if (i.length === 0)
      for (let y = 0; y < c; ++y)
        v[y] = /** @type {number} */
        o[y];
    else {
      const y = i[0], E = i[1];
      for (let b = 0; b < c; ++b)
        v[b] = ie(y, E, [o[b], b]);
    }
    return v;
  }
  /**
   * limitation: `Object.getOwnPropertyNames(Float16Array)` or `Reflect.ownKeys(Float16Array)` include this key
   * @see https://tc39.es/ecma262/#sec-%typedarray%.of
   */
  static of(...e) {
    const i = this;
    if (!dr(i, Gt))
      throw X(
        Xr
      );
    const s = e.length;
    if (i === B) {
      const c = new B(s), l = O(c);
      for (let v = 0; v < s; ++v)
        l[v] = Ee(e[v]);
      return c;
    }
    const o = new i(s);
    for (let c = 0; c < s; ++c)
      o[c] = e[c];
    return o;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.keys */
  keys() {
    R(this);
    const e = O(this);
    return vs(e);
  }
  /**
   * limitation: returns a object whose prototype is not `%ArrayIteratorPrototype%`
   * @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.values
   */
  values() {
    R(this);
    const e = O(this);
    return tn(function* () {
      for (const i of ys(e))
        yield L(i);
    }());
  }
  /**
   * limitation: returns a object whose prototype is not `%ArrayIteratorPrototype%`
   * @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.entries
   */
  entries() {
    R(this);
    const e = O(this);
    return tn(function* () {
      for (const [i, s] of ps(e))
        yield (
          /** @type {[number, number]} */
          [i, L(s)]
        );
    }());
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.at */
  at(e) {
    R(this);
    const i = O(this), s = x(i), o = Ue(e), c = o >= 0 ? o : s + o;
    if (!(c < 0 || c >= s))
      return L(i[c]);
  }
  /** @see https://tc39.es/proposal-change-array-by-copy/#sec-%typedarray%.prototype.with */
  with(e, i) {
    R(this);
    const s = O(this), o = x(s), c = Ue(e), l = c >= 0 ? c : o + c, v = +i;
    if (l < 0 || l >= o)
      throw cr(or);
    const y = new ce(
      $(s),
      Be(s),
      x(s)
    ), E = new B(
      $(
        ot(y)
      )
    ), b = O(E);
    return b[l] = Ee(v), E;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.map */
  map(e, ...i) {
    R(this);
    const s = O(this), o = x(s), c = i[0], l = Ft(s, B);
    if (l === B) {
      const y = new B(o), E = O(y);
      for (let b = 0; b < o; ++b) {
        const U = L(s[b]);
        E[b] = Ee(
          ie(e, c, [U, b, this])
        );
      }
      return y;
    }
    const v = new l(o);
    Lt(v, o);
    for (let y = 0; y < o; ++y) {
      const E = L(s[y]);
      v[y] = ie(e, c, [E, y, this]);
    }
    return (
      /** @type {any} */
      v
    );
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.filter */
  filter(e, ...i) {
    R(this);
    const s = O(this), o = x(s), c = i[0], l = [];
    for (let E = 0; E < o; ++E) {
      const b = L(s[E]);
      ie(e, c, [b, E, this]) && ns(l, b);
    }
    const v = Ft(s, B), y = new v(l);
    return Lt(y), /** @type {any} */
    y;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduce */
  reduce(e, ...i) {
    R(this);
    const s = O(this), o = x(s);
    if (o === 0 && i.length === 0)
      throw X(qr);
    let c, l;
    i.length === 0 ? (c = L(s[0]), l = 1) : (c = i[0], l = 0);
    for (let v = l; v < o; ++v)
      c = e(
        c,
        L(s[v]),
        v,
        this
      );
    return c;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduceright */
  reduceRight(e, ...i) {
    R(this);
    const s = O(this), o = x(s);
    if (o === 0 && i.length === 0)
      throw X(qr);
    let c, l;
    i.length === 0 ? (c = L(s[o - 1]), l = o - 2) : (c = i[0], l = o - 1);
    for (let v = l; v >= 0; --v)
      c = e(
        c,
        L(s[v]),
        v,
        this
      );
    return c;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.foreach */
  forEach(e, ...i) {
    R(this);
    const s = O(this), o = x(s), c = i[0];
    for (let l = 0; l < o; ++l)
      ie(e, c, [
        L(s[l]),
        l,
        this
      ]);
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.find */
  find(e, ...i) {
    R(this);
    const s = O(this), o = x(s), c = i[0];
    for (let l = 0; l < o; ++l) {
      const v = L(s[l]);
      if (ie(e, c, [v, l, this]))
        return v;
    }
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.findindex */
  findIndex(e, ...i) {
    R(this);
    const s = O(this), o = x(s), c = i[0];
    for (let l = 0; l < o; ++l) {
      const v = L(s[l]);
      if (ie(e, c, [v, l, this]))
        return l;
    }
    return -1;
  }
  /** @see https://tc39.es/proposal-array-find-from-last/index.html#sec-%typedarray%.prototype.findlast */
  findLast(e, ...i) {
    R(this);
    const s = O(this), o = x(s), c = i[0];
    for (let l = o - 1; l >= 0; --l) {
      const v = L(s[l]);
      if (ie(e, c, [v, l, this]))
        return v;
    }
  }
  /** @see https://tc39.es/proposal-array-find-from-last/index.html#sec-%typedarray%.prototype.findlastindex */
  findLastIndex(e, ...i) {
    R(this);
    const s = O(this), o = x(s), c = i[0];
    for (let l = o - 1; l >= 0; --l) {
      const v = L(s[l]);
      if (ie(e, c, [v, l, this]))
        return l;
    }
    return -1;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.every */
  every(e, ...i) {
    R(this);
    const s = O(this), o = x(s), c = i[0];
    for (let l = 0; l < o; ++l)
      if (!ie(e, c, [
        L(s[l]),
        l,
        this
      ]))
        return !1;
    return !0;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.some */
  some(e, ...i) {
    R(this);
    const s = O(this), o = x(s), c = i[0];
    for (let l = 0; l < o; ++l)
      if (ie(e, c, [
        L(s[l]),
        l,
        this
      ]))
        return !0;
    return !1;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.set */
  set(e, ...i) {
    R(this);
    const s = O(this), o = Ue(i[0]);
    if (o < 0)
      throw cr(or);
    if (e == null)
      throw X(
        yr
      );
    if (gr(e))
      throw X(
        pr
      );
    if (Xe(e))
      return ds(
        O(this),
        O(e),
        o
      );
    if (Ht(e)) {
      const y = $(e);
      if (yt(y))
        throw X(vt);
    }
    const c = x(s), l = Ve(e), v = lr(l.length);
    if (o === 1 / 0 || v + o > c)
      throw cr(or);
    for (let y = 0; y < v; ++y)
      s[y + o] = Ee(l[y]);
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.reverse */
  reverse() {
    R(this);
    const e = O(this);
    return jr(e), this;
  }
  /** @see https://tc39.es/proposal-change-array-by-copy/#sec-%typedarray%.prototype.toReversed */
  toReversed() {
    R(this);
    const e = O(this), i = new ce(
      $(e),
      Be(e),
      x(e)
    ), s = new B(
      $(
        ot(i)
      )
    ), o = O(s);
    return jr(o), s;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.fill */
  fill(e, ...i) {
    R(this);
    const s = O(this);
    return ws(
      s,
      Ee(e),
      ...ht(i)
    ), this;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.copywithin */
  copyWithin(e, i, ...s) {
    R(this);
    const o = O(this);
    return As(o, e, i, ...ht(s)), this;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.sort */
  sort(e) {
    R(this);
    const i = O(this), s = e !== void 0 ? e : on;
    return Kr(i, (o, c) => s(L(o), L(c))), this;
  }
  /** @see https://tc39.es/proposal-change-array-by-copy/#sec-%typedarray%.prototype.toSorted */
  toSorted(e) {
    R(this);
    const i = O(this);
    if (e !== void 0 && typeof e != "function")
      throw new X(Ji);
    const s = e !== void 0 ? e : on, o = new ce(
      $(i),
      Be(i),
      x(i)
    ), c = new B(
      $(
        ot(o)
      )
    ), l = O(c);
    return Kr(l, (v, y) => s(L(v), L(y))), c;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.slice */
  slice(e, i) {
    R(this);
    const s = O(this), o = Ft(s, B);
    if (o === B) {
      const Ze = new ce(
        $(s),
        Be(s),
        x(s)
      );
      return new B(
        $(
          ot(Ze, e, i)
        )
      );
    }
    const c = x(s), l = Ue(e), v = i === void 0 ? c : Ue(i);
    let y;
    l === -1 / 0 ? y = 0 : l < 0 ? y = c + l > 0 ? c + l : 0 : y = c < l ? c : l;
    let E;
    v === -1 / 0 ? E = 0 : v < 0 ? E = c + v > 0 ? c + v : 0 : E = c < v ? c : v;
    const b = E - y > 0 ? E - y : 0, U = new o(b);
    if (Lt(U, b), b === 0)
      return U;
    const q = $(s);
    if (yt(q))
      throw X(vt);
    let se = 0;
    for (; y < E; )
      U[se] = L(s[y]), ++y, ++se;
    return (
      /** @type {any} */
      U
    );
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.subarray */
  subarray(e, i) {
    R(this);
    const s = O(this), o = Ft(s, B), c = new ce(
      $(s),
      Be(s),
      x(s)
    ), l = gs(c, e, i), v = new o(
      $(l),
      Be(l),
      x(l)
    );
    return Lt(v), /** @type {any} */
    v;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.indexof */
  indexOf(e, ...i) {
    R(this);
    const s = O(this), o = x(s);
    let c = Ue(i[0]);
    if (c === 1 / 0)
      return -1;
    c < 0 && (c += o, c < 0 && (c = 0));
    for (let l = c; l < o; ++l)
      if (Ce(s, l) && L(s[l]) === e)
        return l;
    return -1;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.lastindexof */
  lastIndexOf(e, ...i) {
    R(this);
    const s = O(this), o = x(s);
    let c = i.length >= 1 ? Ue(i[0]) : o - 1;
    if (c === -1 / 0)
      return -1;
    c >= 0 ? c = c < o - 1 ? c : o - 1 : c += o;
    for (let l = c; l >= 0; --l)
      if (Ce(s, l) && L(s[l]) === e)
        return l;
    return -1;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.includes */
  includes(e, ...i) {
    R(this);
    const s = O(this), o = x(s);
    let c = Ue(i[0]);
    if (c === 1 / 0)
      return !1;
    c < 0 && (c += o, c < 0 && (c = 0));
    const l = qe(e);
    for (let v = c; v < o; ++v) {
      const y = L(s[v]);
      if (l && qe(y) || y === e)
        return !0;
    }
    return !1;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.join */
  join(e) {
    R(this);
    const i = O(this), s = an(i);
    return rs(s, e);
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.tolocalestring */
  toLocaleString(...e) {
    R(this);
    const i = O(this), s = an(i);
    return is(s, ...ht(e));
  }
  /** @see https://tc39.es/ecma262/#sec-get-%typedarray%.prototype-@@tostringtag */
  get [Ir]() {
    if (Xe(this))
      return (
        /** @type {any} */
        "Float16Array"
      );
  }
}
gt(B, "BYTES_PER_ELEMENT", {
  value: Cr
});
gt(B, Gt, {});
dn(B, br);
const Xt = B.prototype;
gt(Xt, "BYTES_PER_ELEMENT", {
  value: Cr
});
gt(Xt, Ie, {
  value: Xt.values,
  writable: !0,
  configurable: !0
});
dn(Xt, Q);
function zs(r, e, ...i) {
  return L(
    bs(r, e, ...ht(i))
  );
}
function Io(r) {
  return r instanceof Int8Array || r instanceof Uint8Array || r instanceof Uint8ClampedArray || r instanceof Int16Array || r instanceof Uint16Array || r instanceof Int32Array || r instanceof Uint32Array || r instanceof B || r instanceof Float32Array || r instanceof Float64Array;
}
class ks extends qt {
  load(e, i, s, o) {
    const c = new ki(this.manager);
    c.setRequestHeader(this.requestHeader), c.setPath(this.path), c.setWithCredentials(this.withCredentials), c.load(
      e,
      (l) => {
        try {
          i(this.parseTypedArray(l));
        } catch (v) {
          o != null ? o(v) : console.error(v), this.manager.itemError(e);
        }
      },
      s,
      o
    );
  }
}
function Mn(r) {
  return class extends ks {
    constructor() {
      super(...arguments), this.parseTypedArray = r;
    }
  };
}
function _o(r) {
  return new (Mn(r))();
}
function Zs(r) {
  const e = r instanceof Int8Array ? mi : r instanceof Uint8Array ? kr : r instanceof Uint8ClampedArray ? kr : r instanceof Int16Array ? Ui : r instanceof Uint16Array ? Ci : r instanceof Int32Array ? Ri : r instanceof Uint32Array ? xi : r instanceof B ? lt : r instanceof Float32Array ? ft : r instanceof Float64Array ? ft : null;
  return vn(e != null), e;
}
const Hs = {
  format: ln,
  minFilter: zt,
  magFilter: zt
};
class Gs extends qt {
  constructor() {
    super(...arguments), this.parameters = {};
  }
  load(e, i, s, o) {
    const c = new this.Texture(), l = new this.TypedArrayLoader(this.manager);
    l.setRequestHeader(this.requestHeader), l.setPath(this.path), l.setWithCredentials(this.withCredentials), l.load(
      e,
      (v) => {
        c.image.data = v instanceof B ? new Uint16Array(v.buffer) : v;
        const { width: y, height: E, depth: b, ...U } = this.parameters;
        y != null && (c.image.width = y), E != null && (c.image.height = E), "depth" in c.image && b != null && (c.image.depth = b), c.type = Zs(v), Object.assign(c, U), c.needsUpdate = !0, i(c);
      },
      s,
      o
    );
  }
}
function Dn(r, e, i) {
  return class extends Gs {
    constructor() {
      super(...arguments), this.Texture = r, this.TypedArrayLoader = Mn(e), this.parameters = {
        ...Hs,
        ...i
      };
    }
  };
}
function Bn(r, e) {
  return Dn(un, r, e);
}
function Ws(r, e) {
  return Dn(Fi, r, e);
}
function bo(r, e) {
  return new (Bn(r, e))();
}
function No(r, e) {
  return new (Ws(r, e))();
}
const Je = ye.clamp, Oo = ye.euclideanModulo, mo = ye.inverseLerp, Uo = ye.lerp, Co = ye.degToRad, Ro = ye.radToDeg, xo = ye.isPowerOfTwo, Fo = ye.ceilPowerOfTwo, Lo = ye.floorPowerOfTwo, Po = ye.normalize;
function Mo(r, e, i, s = 0, o = 1) {
  return ye.mapLinear(r, e, i, s, o);
}
function Do(r, e, i, s = 0, o = 1) {
  return Je(ye.mapLinear(r, e, i, s, o), s, o);
}
function Bo(r, e, i) {
  return i <= r ? 0 : i >= e ? 1 : (i = (i - r) / (e - r), i * i * (3 - 2 * i));
}
function zo(r) {
  return Math.min(Math.max(r, 0), 1);
}
function ko(r, e, i, s = i) {
  const o = Math.abs(r - e);
  return o <= s || o <= i * Math.max(Math.abs(r), Math.abs(e));
}
function Zo(r) {
  return (e, i) => {
    e instanceof Vt ? Object.defineProperty(e, i, {
      enumerable: !0,
      get() {
        var s;
        return ((s = this.defines) == null ? void 0 : s[r]) != null;
      },
      set(s) {
        var o;
        s !== this[i] && (s ? (this.defines ?? (this.defines = {}), this.defines[r] = "1") : (o = this.defines) == null || delete o[r], this.needsUpdate = !0);
      }
    }) : Object.defineProperty(e, i, {
      enumerable: !0,
      get() {
        return this.defines.has(r);
      },
      set(s) {
        s !== this[i] && (s ? this.defines.set(r, "1") : this.defines.delete(r), this.setChanged());
      }
    });
  };
}
function Ho(r, {
  min: e = Number.MIN_SAFE_INTEGER,
  max: i = Number.MAX_SAFE_INTEGER
} = {}) {
  return (s, o) => {
    s instanceof Vt ? Object.defineProperty(s, o, {
      enumerable: !0,
      get() {
        var l;
        const c = (l = this.defines) == null ? void 0 : l[r];
        return c != null ? parseInt(c) : 0;
      },
      set(c) {
        const l = this[o];
        c !== l && (this.defines ?? (this.defines = {}), this.defines[r] = Je(c, e, i).toFixed(0), this.needsUpdate = !0);
      }
    }) : Object.defineProperty(s, o, {
      enumerable: !0,
      get() {
        const c = this.defines.get(r);
        return c != null ? parseInt(c) : 0;
      },
      set(c) {
        const l = this[o];
        c !== l && (this.defines.set(r, Je(c, e, i).toFixed(0)), this.setChanged());
      }
    });
  };
}
function Go(r, {
  min: e = -1 / 0,
  max: i = 1 / 0,
  precision: s = 7
} = {}) {
  return (o, c) => {
    o instanceof Vt ? Object.defineProperty(o, c, {
      enumerable: !0,
      get() {
        var v;
        const l = (v = this.defines) == null ? void 0 : v[r];
        return l != null ? parseFloat(l) : 0;
      },
      set(l) {
        const v = this[c];
        l !== v && (this.defines ?? (this.defines = {}), this.defines[r] = Je(l, e, i).toFixed(s), this.needsUpdate = !0);
      }
    }) : Object.defineProperty(o, c, {
      enumerable: !0,
      get() {
        const l = this.defines.get(r);
        return l != null ? parseFloat(l) : 0;
      },
      set(l) {
        const v = this[c];
        l !== v && (this.defines.set(r, Je(l, e, i).toFixed(s)), this.setChanged());
      }
    });
  };
}
function Wo(r, { validate: e } = {}) {
  return (i, s) => {
    i instanceof Vt ? Object.defineProperty(i, s, {
      enumerable: !0,
      get() {
        var o;
        return ((o = this.defines) == null ? void 0 : o[r]) ?? "";
      },
      set(o) {
        if (o !== this[s]) {
          if ((e == null ? void 0 : e(o)) === !1) {
            console.error(`Expression validation failed: ${o}`);
            return;
          }
          this.defines ?? (this.defines = {}), this.defines[r] = o, this.needsUpdate = !0;
        }
      }
    }) : Object.defineProperty(i, s, {
      enumerable: !0,
      get() {
        return this.defines.get(r) ?? "";
      },
      set(o) {
        if (o !== this[s]) {
          if ((e == null ? void 0 : e(o)) === !1) {
            console.error(`Expression validation failed: ${o}`);
            return;
          }
          this.defines.set(r, o), this.setChanged();
        }
      }
    });
  };
}
function Xo(r, ...e) {
  const i = {};
  for (let s = 0; s < e.length; s += 2) {
    const o = e[s], c = e[s + 1];
    for (const l of c)
      i[l] = {
        enumerable: !0,
        get: () => o[l],
        set: (v) => {
          o[l] = v;
        }
      };
  }
  return Object.defineProperties(r, i), r;
}
function Yo(r, e, i) {
  const s = {};
  for (const o of i)
    s[o] = {
      enumerable: !0,
      get: () => e.uniforms[o].value,
      set: (c) => {
        e.uniforms[o].value = c;
      }
    };
  return Object.defineProperties(r, s), r;
}
const Xs = parseInt(Li.replace(/\D+/g, ""));
var ve = Uint8Array, Le = Uint16Array, Tr = Uint32Array, zn = new ve([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), kn = new ve([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), Ys = new ve([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), Zn = function(r, e) {
  for (var i = new Le(31), s = 0; s < 31; ++s)
    i[s] = e += 1 << r[s - 1];
  for (var o = new Tr(i[30]), s = 1; s < 30; ++s)
    for (var c = i[s]; c < i[s + 1]; ++c)
      o[c] = c - i[s] << 5 | s;
  return [i, o];
}, Hn = Zn(zn, 2), Gn = Hn[0], qs = Hn[1];
Gn[28] = 258, qs[258] = 28;
var Vs = Zn(kn, 0), Js = Vs[0], Er = new Le(32768);
for (var G = 0; G < 32768; ++G) {
  var Fe = (G & 43690) >>> 1 | (G & 21845) << 1;
  Fe = (Fe & 52428) >>> 2 | (Fe & 13107) << 2, Fe = (Fe & 61680) >>> 4 | (Fe & 3855) << 4, Er[G] = ((Fe & 65280) >>> 8 | (Fe & 255) << 8) >>> 1;
}
var pt = function(r, e, i) {
  for (var s = r.length, o = 0, c = new Le(e); o < s; ++o)
    ++c[r[o] - 1];
  var l = new Le(e);
  for (o = 0; o < e; ++o)
    l[o] = l[o - 1] + c[o - 1] << 1;
  var v;
  if (i) {
    v = new Le(1 << e);
    var y = 15 - e;
    for (o = 0; o < s; ++o)
      if (r[o])
        for (var E = o << 4 | r[o], b = e - r[o], U = l[r[o] - 1]++ << b, q = U | (1 << b) - 1; U <= q; ++U)
          v[Er[U] >>> y] = E;
  } else
    for (v = new Le(s), o = 0; o < s; ++o)
      r[o] && (v[o] = Er[l[r[o] - 1]++] >>> 15 - r[o]);
  return v;
}, St = new ve(288);
for (var G = 0; G < 144; ++G)
  St[G] = 8;
for (var G = 144; G < 256; ++G)
  St[G] = 9;
for (var G = 256; G < 280; ++G)
  St[G] = 7;
for (var G = 280; G < 288; ++G)
  St[G] = 8;
var Wn = new ve(32);
for (var G = 0; G < 32; ++G)
  Wn[G] = 5;
var $s = /* @__PURE__ */ pt(St, 9, 1), Qs = /* @__PURE__ */ pt(Wn, 5, 1), ur = function(r) {
  for (var e = r[0], i = 1; i < r.length; ++i)
    r[i] > e && (e = r[i]);
  return e;
}, de = function(r, e, i) {
  var s = e / 8 | 0;
  return (r[s] | r[s + 1] << 8) >> (e & 7) & i;
}, hr = function(r, e) {
  var i = e / 8 | 0;
  return (r[i] | r[i + 1] << 8 | r[i + 2] << 16) >> (e & 7);
}, js = function(r) {
  return (r / 8 | 0) + (r & 7 && 1);
}, Ks = function(r, e, i) {
  (i == null || i > r.length) && (i = r.length);
  var s = new (r instanceof Le ? Le : r instanceof Tr ? Tr : ve)(i - e);
  return s.set(r.subarray(e, i)), s;
}, eo = function(r, e, i) {
  var s = r.length;
  if (!s || i && !i.l && s < 5)
    return e || new ve(0);
  var o = !e || i, c = !i || i.i;
  i || (i = {}), e || (e = new ve(s * 3));
  var l = function(P) {
    var be = e.length;
    if (P > be) {
      var Ne = new ve(Math.max(be * 2, P));
      Ne.set(e), e = Ne;
    }
  }, v = i.f || 0, y = i.p || 0, E = i.b || 0, b = i.l, U = i.d, q = i.m, se = i.n, Ze = s * 8;
  do {
    if (!b) {
      i.f = v = de(r, y, 1);
      var Tt = de(r, y + 1, 3);
      if (y += 3, Tt)
        if (Tt == 1)
          b = $s, U = Qs, q = 9, se = 5;
        else if (Tt == 2) {
          var _t = de(r, y, 31) + 257, er = de(r, y + 10, 15) + 4, tr = _t + de(r, y + 5, 31) + 1;
          y += 14;
          for (var He = new ve(tr), bt = new ve(19), oe = 0; oe < er; ++oe)
            bt[Ys[oe]] = de(r, y + oe * 3, 7);
          y += er * 3;
          for (var Nt = ur(bt), rr = (1 << Nt) - 1, nr = pt(bt, Nt, 1), oe = 0; oe < tr; ) {
            var le = nr[de(r, y, rr)];
            y += le & 15;
            var pe = le >>> 4;
            if (pe < 16)
              He[oe++] = pe;
            else {
              var _e = 0, ge = 0;
              for (pe == 16 ? (ge = 3 + de(r, y, 3), y += 2, _e = He[oe - 1]) : pe == 17 ? (ge = 3 + de(r, y, 7), y += 3) : pe == 18 && (ge = 11 + de(r, y, 127), y += 7); ge--; )
                He[oe++] = _e;
            }
          }
          var Ot = He.subarray(0, _t), Se = He.subarray(_t);
          q = ur(Ot), se = ur(Se), b = pt(Ot, q, 1), U = pt(Se, se, 1);
        } else
          throw "invalid block type";
      else {
        var pe = js(y) + 4, Et = r[pe - 4] | r[pe - 3] << 8, It = pe + Et;
        if (It > s) {
          if (c)
            throw "unexpected EOF";
          break;
        }
        o && l(E + Et), e.set(r.subarray(pe, It), E), i.b = E += Et, i.p = y = It * 8;
        continue;
      }
      if (y > Ze) {
        if (c)
          throw "unexpected EOF";
        break;
      }
    }
    o && l(E + 131072);
    for (var mt = (1 << q) - 1, Ut = (1 << se) - 1, je = y; ; je = y) {
      var _e = b[hr(r, y) & mt], ee = _e >>> 4;
      if (y += _e & 15, y > Ze) {
        if (c)
          throw "unexpected EOF";
        break;
      }
      if (!_e)
        throw "invalid length/literal";
      if (ee < 256)
        e[E++] = ee;
      else if (ee == 256) {
        je = y, b = null;
        break;
      } else {
        var Ge = ee - 254;
        if (ee > 264) {
          var oe = ee - 257, re = zn[oe];
          Ge = de(r, y, (1 << re) - 1) + Gn[oe], y += re;
        }
        var Pe = U[hr(r, y) & Ut], Me = Pe >>> 4;
        if (!Pe)
          throw "invalid distance";
        y += Pe & 15;
        var Se = Js[Me];
        if (Me > 3) {
          var re = kn[Me];
          Se += hr(r, y) & (1 << re) - 1, y += re;
        }
        if (y > Ze) {
          if (c)
            throw "unexpected EOF";
          break;
        }
        o && l(E + 131072);
        for (var Ke = E + Ge; E < Ke; E += 4)
          e[E] = e[E - Se], e[E + 1] = e[E + 1 - Se], e[E + 2] = e[E + 2 - Se], e[E + 3] = e[E + 3 - Se];
        E = Ke;
      }
    }
    i.l = b, i.p = je, i.b = E, b && (v = 1, i.m = q, i.d = U, i.n = se);
  } while (!v);
  return E == e.length ? e : Ks(e, 0, E);
}, to = /* @__PURE__ */ new ve(0), ro = function(r) {
  if ((r[0] & 15) != 8 || r[0] >>> 4 > 7 || (r[0] << 8 | r[1]) % 31)
    throw "invalid zlib data";
  if (r[1] & 32)
    throw "invalid zlib data: preset dictionaries not supported";
};
function Pt(r, e) {
  return eo((ro(r), r.subarray(2, -4)), e);
}
var no = typeof TextDecoder < "u" && /* @__PURE__ */ new TextDecoder(), io = 0;
try {
  no.decode(to, { stream: !0 }), io = 1;
} catch {
}
const at = Xs >= 152;
class so extends Pi {
  constructor(e) {
    super(e), this.type = lt;
  }
  parse(e) {
    const Nt = Math.pow(2.7182818, 2.2);
    function rr(t, n) {
      for (var a = 0, u = 0; u < 65536; ++u)
        (u == 0 || t[u >> 3] & 1 << (u & 7)) && (n[a++] = u);
      for (var h = a - 1; a < 65536; )
        n[a++] = 0;
      return h;
    }
    function nr(t) {
      for (var n = 0; n < 16384; n++)
        t[n] = {}, t[n].len = 0, t[n].lit = 0, t[n].p = null;
    }
    const le = { l: 0, c: 0, lc: 0 };
    function _e(t, n, a, u, h) {
      for (; a < t; )
        n = n << 8 | Dr(u, h), a += 8;
      a -= t, le.l = n >> a & (1 << t) - 1, le.c = n, le.lc = a;
    }
    const ge = new Array(59);
    function Ot(t) {
      for (var n = 0; n <= 58; ++n)
        ge[n] = 0;
      for (var n = 0; n < 65537; ++n)
        ge[t[n]] += 1;
      for (var a = 0, n = 58; n > 0; --n) {
        var u = a + ge[n] >> 1;
        ge[n] = a, a = u;
      }
      for (var n = 0; n < 65537; ++n) {
        var h = t[n];
        h > 0 && (t[n] = h | ge[h]++ << 6);
      }
    }
    function Se(t, n, a, u, h, f, d) {
      for (var p = a, g = 0, A = 0; h <= f; h++) {
        if (p.value - a.value > u)
          return !1;
        _e(6, g, A, t, p);
        var S = le.l;
        if (g = le.c, A = le.lc, d[h] = S, S == 63) {
          if (p.value - a.value > u)
            throw "Something wrong with hufUnpackEncTable";
          _e(8, g, A, t, p);
          var w = le.l + 6;
          if (g = le.c, A = le.lc, h + w > f + 1)
            throw "Something wrong with hufUnpackEncTable";
          for (; w--; )
            d[h++] = 0;
          h--;
        } else if (S >= 59) {
          var w = S - 59 + 2;
          if (h + w > f + 1)
            throw "Something wrong with hufUnpackEncTable";
          for (; w--; )
            d[h++] = 0;
          h--;
        }
      }
      Ot(d);
    }
    function mt(t) {
      return t & 63;
    }
    function Ut(t) {
      return t >> 6;
    }
    function je(t, n, a, u) {
      for (; n <= a; n++) {
        var h = Ut(t[n]), f = mt(t[n]);
        if (h >> f)
          throw "Invalid table entry";
        if (f > 14) {
          var d = u[h >> f - 14];
          if (d.len)
            throw "Invalid table entry";
          if (d.lit++, d.p) {
            var p = d.p;
            d.p = new Array(d.lit);
            for (var g = 0; g < d.lit - 1; ++g)
              d.p[g] = p[g];
          } else
            d.p = new Array(1);
          d.p[d.lit - 1] = n;
        } else if (f)
          for (var A = 0, g = 1 << 14 - f; g > 0; g--) {
            var d = u[(h << 14 - f) + A];
            if (d.len || d.p)
              throw "Invalid table entry";
            d.len = f, d.lit = n, A++;
          }
      }
      return !0;
    }
    const ee = { c: 0, lc: 0 };
    function Ge(t, n, a, u) {
      t = t << 8 | Dr(a, u), n += 8, ee.c = t, ee.lc = n;
    }
    const re = { c: 0, lc: 0 };
    function Pe(t, n, a, u, h, f, d, p, g, A) {
      if (t == n) {
        u < 8 && (Ge(a, u, h, d), a = ee.c, u = ee.lc), u -= 8;
        var S = a >> u, S = new Uint8Array([S])[0];
        if (g.value + S > A)
          return !1;
        for (var w = p[g.value - 1]; S-- > 0; )
          p[g.value++] = w;
      } else if (g.value < A)
        p[g.value++] = t;
      else
        return !1;
      re.c = a, re.lc = u;
    }
    function Me(t) {
      return t & 65535;
    }
    function Ke(t) {
      var n = Me(t);
      return n > 32767 ? n - 65536 : n;
    }
    const P = { a: 0, b: 0 };
    function be(t, n) {
      var a = Ke(t), u = Ke(n), h = u, f = a + (h & 1) + (h >> 1), d = f, p = f - h;
      P.a = d, P.b = p;
    }
    function Ne(t, n) {
      var a = Me(t), u = Me(n), h = a - (u >> 1) & 65535, f = u + h - 32768 & 65535;
      P.a = f, P.b = h;
    }
    function Vn(t, n, a, u, h, f, d) {
      for (var p = d < 16384, g = a > h ? h : a, A = 1, S; A <= g; )
        A <<= 1;
      for (A >>= 1, S = A, A >>= 1; A >= 1; ) {
        for (var w = 0, Y = w + f * (h - S), I = f * A, _ = f * S, N = u * A, m = u * S, M, z, V, te; w <= Y; w += _) {
          for (var k = w, Te = w + u * (a - S); k <= Te; k += m) {
            var H = k + N, J = k + I, Oe = J + N;
            p ? (be(t[k + n], t[J + n]), M = P.a, V = P.b, be(t[H + n], t[Oe + n]), z = P.a, te = P.b, be(M, z), t[k + n] = P.a, t[H + n] = P.b, be(V, te), t[J + n] = P.a, t[Oe + n] = P.b) : (Ne(t[k + n], t[J + n]), M = P.a, V = P.b, Ne(t[H + n], t[Oe + n]), z = P.a, te = P.b, Ne(M, z), t[k + n] = P.a, t[H + n] = P.b, Ne(V, te), t[J + n] = P.a, t[Oe + n] = P.b);
          }
          if (a & A) {
            var J = k + I;
            p ? be(t[k + n], t[J + n]) : Ne(t[k + n], t[J + n]), M = P.a, t[J + n] = P.b, t[k + n] = M;
          }
        }
        if (h & A)
          for (var k = w, Te = w + u * (a - S); k <= Te; k += m) {
            var H = k + N;
            p ? be(t[k + n], t[H + n]) : Ne(t[k + n], t[H + n]), M = P.a, t[H + n] = P.b, t[k + n] = M;
          }
        S = A, A >>= 1;
      }
      return w;
    }
    function Jn(t, n, a, u, h, f, d, p, g, A) {
      for (var S = 0, w = 0, Y = p, I = Math.trunc(h.value + (f + 7) / 8); h.value < I; )
        for (Ge(S, w, a, h), S = ee.c, w = ee.lc; w >= 14; ) {
          var _ = S >> w - 14 & 16383, N = n[_];
          if (N.len)
            w -= N.len, Pe(N.lit, d, S, w, a, u, h, g, A, Y), S = re.c, w = re.lc;
          else {
            if (!N.p)
              throw "hufDecode issues";
            var m;
            for (m = 0; m < N.lit; m++) {
              for (var M = mt(t[N.p[m]]); w < M && h.value < I; )
                Ge(S, w, a, h), S = ee.c, w = ee.lc;
              if (w >= M && Ut(t[N.p[m]]) == (S >> w - M & (1 << M) - 1)) {
                w -= M, Pe(
                  N.p[m],
                  d,
                  S,
                  w,
                  a,
                  u,
                  h,
                  g,
                  A,
                  Y
                ), S = re.c, w = re.lc;
                break;
              }
            }
            if (m == N.lit)
              throw "hufDecode issues";
          }
        }
      var z = 8 - f & 7;
      for (S >>= z, w -= z; w > 0; ) {
        var N = n[S << 14 - w & 16383];
        if (N.len)
          w -= N.len, Pe(N.lit, d, S, w, a, u, h, g, A, Y), S = re.c, w = re.lc;
        else
          throw "hufDecode issues";
      }
      return !0;
    }
    function Rr(t, n, a, u, h, f) {
      var d = { value: 0 }, p = a.value, g = ne(n, a), A = ne(n, a);
      a.value += 4;
      var S = ne(n, a);
      if (a.value += 4, g < 0 || g >= 65537 || A < 0 || A >= 65537)
        throw "Something wrong with HUF_ENCSIZE";
      var w = new Array(65537), Y = new Array(16384);
      nr(Y);
      var I = u - (a.value - p);
      if (Se(t, n, a, I, g, A, w), S > 8 * (u - (a.value - p)))
        throw "Something wrong with hufUncompress";
      je(w, g, A, Y), Jn(w, Y, t, n, a, S, A, f, h, d);
    }
    function $n(t, n, a) {
      for (var u = 0; u < a; ++u)
        n[u] = t[n[u]];
    }
    function xr(t) {
      for (var n = 1; n < t.length; n++) {
        var a = t[n - 1] + t[n] - 128;
        t[n] = a;
      }
    }
    function Fr(t, n) {
      for (var a = 0, u = Math.floor((t.length + 1) / 2), h = 0, f = t.length - 1; !(h > f || (n[h++] = t[a++], h > f)); )
        n[h++] = t[u++];
    }
    function Lr(t) {
      for (var n = t.byteLength, a = new Array(), u = 0, h = new DataView(t); n > 0; ) {
        var f = h.getInt8(u++);
        if (f < 0) {
          var d = -f;
          n -= d + 1;
          for (var p = 0; p < d; p++)
            a.push(h.getUint8(u++));
        } else {
          var d = f;
          n -= 2;
          for (var g = h.getUint8(u++), p = 0; p < d + 1; p++)
            a.push(g);
        }
      }
      return a;
    }
    function Qn(t, n, a, u, h, f) {
      var H = new DataView(f.buffer), d = a[t.idx[0]].width, p = a[t.idx[0]].height, g = 3, A = Math.floor(d / 8), S = Math.ceil(d / 8), w = Math.ceil(p / 8), Y = d - (S - 1) * 8, I = p - (w - 1) * 8, _ = { value: 0 }, N = new Array(g), m = new Array(g), M = new Array(g), z = new Array(g), V = new Array(g);
      for (let D = 0; D < g; ++D)
        V[D] = n[t.idx[D]], N[D] = D < 1 ? 0 : N[D - 1] + S * w, m[D] = new Float32Array(64), M[D] = new Uint16Array(64), z[D] = new Uint16Array(S * 64);
      for (let D = 0; D < w; ++D) {
        var te = 8;
        D == w - 1 && (te = I);
        var k = 8;
        for (let W = 0; W < S; ++W) {
          W == S - 1 && (k = Y);
          for (let F = 0; F < g; ++F)
            M[F].fill(0), M[F][0] = h[N[F]++], jn(_, u, M[F]), Kn(M[F], m[F]), ei(m[F]);
          ti(m);
          for (let F = 0; F < g; ++F)
            ri(m[F], z[F], W * 64);
        }
        let K = 0;
        for (let W = 0; W < g; ++W) {
          const F = a[t.idx[W]].type;
          for (let fe = 8 * D; fe < 8 * D + te; ++fe) {
            K = V[W][fe];
            for (let De = 0; De < A; ++De) {
              const ae = De * 64 + (fe & 7) * 8;
              H.setUint16(K + 0 * 2 * F, z[W][ae + 0], !0), H.setUint16(K + 1 * 2 * F, z[W][ae + 1], !0), H.setUint16(K + 2 * 2 * F, z[W][ae + 2], !0), H.setUint16(K + 3 * 2 * F, z[W][ae + 3], !0), H.setUint16(K + 4 * 2 * F, z[W][ae + 4], !0), H.setUint16(K + 5 * 2 * F, z[W][ae + 5], !0), H.setUint16(K + 6 * 2 * F, z[W][ae + 6], !0), H.setUint16(K + 7 * 2 * F, z[W][ae + 7], !0), K += 8 * 2 * F;
            }
          }
          if (A != S)
            for (let fe = 8 * D; fe < 8 * D + te; ++fe) {
              const De = V[W][fe] + 8 * A * 2 * F, ae = A * 64 + (fe & 7) * 8;
              for (let xe = 0; xe < k; ++xe)
                H.setUint16(De + xe * 2 * F, z[W][ae + xe], !0);
            }
        }
      }
      for (var Te = new Uint16Array(d), H = new DataView(f.buffer), J = 0; J < g; ++J) {
        a[t.idx[J]].decoded = !0;
        var Oe = a[t.idx[J]].type;
        if (a[J].type == 2)
          for (var it = 0; it < p; ++it) {
            const D = V[J][it];
            for (var he = 0; he < d; ++he)
              Te[he] = H.getUint16(D + he * 2 * Oe, !0);
            for (var he = 0; he < d; ++he)
              H.setFloat32(D + he * 2 * Oe, T(Te[he]), !0);
          }
      }
    }
    function jn(t, n, a) {
      for (var u, h = 1; h < 64; )
        u = n[t.value], u == 65280 ? h = 64 : u >> 8 == 255 ? h += u & 255 : (a[h] = u, h++), t.value++;
    }
    function Kn(t, n) {
      n[0] = T(t[0]), n[1] = T(t[1]), n[2] = T(t[5]), n[3] = T(t[6]), n[4] = T(t[14]), n[5] = T(t[15]), n[6] = T(t[27]), n[7] = T(t[28]), n[8] = T(t[2]), n[9] = T(t[4]), n[10] = T(t[7]), n[11] = T(t[13]), n[12] = T(t[16]), n[13] = T(t[26]), n[14] = T(t[29]), n[15] = T(t[42]), n[16] = T(t[3]), n[17] = T(t[8]), n[18] = T(t[12]), n[19] = T(t[17]), n[20] = T(t[25]), n[21] = T(t[30]), n[22] = T(t[41]), n[23] = T(t[43]), n[24] = T(t[9]), n[25] = T(t[11]), n[26] = T(t[18]), n[27] = T(t[24]), n[28] = T(t[31]), n[29] = T(t[40]), n[30] = T(t[44]), n[31] = T(t[53]), n[32] = T(t[10]), n[33] = T(t[19]), n[34] = T(t[23]), n[35] = T(t[32]), n[36] = T(t[39]), n[37] = T(t[45]), n[38] = T(t[52]), n[39] = T(t[54]), n[40] = T(t[20]), n[41] = T(t[22]), n[42] = T(t[33]), n[43] = T(t[38]), n[44] = T(t[46]), n[45] = T(t[51]), n[46] = T(t[55]), n[47] = T(t[60]), n[48] = T(t[21]), n[49] = T(t[34]), n[50] = T(t[37]), n[51] = T(t[47]), n[52] = T(t[50]), n[53] = T(t[56]), n[54] = T(t[59]), n[55] = T(t[61]), n[56] = T(t[35]), n[57] = T(t[36]), n[58] = T(t[48]), n[59] = T(t[49]), n[60] = T(t[57]), n[61] = T(t[58]), n[62] = T(t[62]), n[63] = T(t[63]);
    }
    function ei(t) {
      const n = 0.5 * Math.cos(0.7853975), a = 0.5 * Math.cos(3.14159 / 16), u = 0.5 * Math.cos(3.14159 / 8), h = 0.5 * Math.cos(3 * 3.14159 / 16), f = 0.5 * Math.cos(5 * 3.14159 / 16), d = 0.5 * Math.cos(3 * 3.14159 / 8), p = 0.5 * Math.cos(7 * 3.14159 / 16);
      for (var g = new Array(4), A = new Array(4), S = new Array(4), w = new Array(4), Y = 0; Y < 8; ++Y) {
        var I = Y * 8;
        g[0] = u * t[I + 2], g[1] = d * t[I + 2], g[2] = u * t[I + 6], g[3] = d * t[I + 6], A[0] = a * t[I + 1] + h * t[I + 3] + f * t[I + 5] + p * t[I + 7], A[1] = h * t[I + 1] - p * t[I + 3] - a * t[I + 5] - f * t[I + 7], A[2] = f * t[I + 1] - a * t[I + 3] + p * t[I + 5] + h * t[I + 7], A[3] = p * t[I + 1] - f * t[I + 3] + h * t[I + 5] - a * t[I + 7], S[0] = n * (t[I + 0] + t[I + 4]), S[3] = n * (t[I + 0] - t[I + 4]), S[1] = g[0] + g[3], S[2] = g[1] - g[2], w[0] = S[0] + S[1], w[1] = S[3] + S[2], w[2] = S[3] - S[2], w[3] = S[0] - S[1], t[I + 0] = w[0] + A[0], t[I + 1] = w[1] + A[1], t[I + 2] = w[2] + A[2], t[I + 3] = w[3] + A[3], t[I + 4] = w[3] - A[3], t[I + 5] = w[2] - A[2], t[I + 6] = w[1] - A[1], t[I + 7] = w[0] - A[0];
      }
      for (var _ = 0; _ < 8; ++_)
        g[0] = u * t[16 + _], g[1] = d * t[16 + _], g[2] = u * t[48 + _], g[3] = d * t[48 + _], A[0] = a * t[8 + _] + h * t[24 + _] + f * t[40 + _] + p * t[56 + _], A[1] = h * t[8 + _] - p * t[24 + _] - a * t[40 + _] - f * t[56 + _], A[2] = f * t[8 + _] - a * t[24 + _] + p * t[40 + _] + h * t[56 + _], A[3] = p * t[8 + _] - f * t[24 + _] + h * t[40 + _] - a * t[56 + _], S[0] = n * (t[_] + t[32 + _]), S[3] = n * (t[_] - t[32 + _]), S[1] = g[0] + g[3], S[2] = g[1] - g[2], w[0] = S[0] + S[1], w[1] = S[3] + S[2], w[2] = S[3] - S[2], w[3] = S[0] - S[1], t[0 + _] = w[0] + A[0], t[8 + _] = w[1] + A[1], t[16 + _] = w[2] + A[2], t[24 + _] = w[3] + A[3], t[32 + _] = w[3] - A[3], t[40 + _] = w[2] - A[2], t[48 + _] = w[1] - A[1], t[56 + _] = w[0] - A[0];
    }
    function ti(t) {
      for (var n = 0; n < 64; ++n) {
        var a = t[0][n], u = t[1][n], h = t[2][n];
        t[0][n] = a + 1.5747 * h, t[1][n] = a - 0.1873 * u - 0.4682 * h, t[2][n] = a + 1.8556 * u;
      }
    }
    function ri(t, n, a) {
      for (var u = 0; u < 64; ++u)
        n[a + u] = Zr.toHalfFloat(ni(t[u]));
    }
    function ni(t) {
      return t <= 1 ? Math.sign(t) * Math.pow(Math.abs(t), 2.2) : Math.sign(t) * Math.pow(Nt, Math.abs(t) - 1);
    }
    function Pr(t) {
      return new DataView(t.array.buffer, t.offset.value, t.size);
    }
    function ii(t) {
      var n = t.viewer.buffer.slice(t.offset.value, t.offset.value + t.size), a = new Uint8Array(Lr(n)), u = new Uint8Array(a.length);
      return xr(a), Fr(a, u), new DataView(u.buffer);
    }
    function ir(t) {
      var n = t.array.slice(t.offset.value, t.offset.value + t.size), a = Pt(n), u = new Uint8Array(a.length);
      return xr(a), Fr(a, u), new DataView(u.buffer);
    }
    function si(t) {
      for (var n = t.viewer, a = { value: t.offset.value }, u = new Uint16Array(t.width * t.scanlineBlockSize * (t.channels * t.type)), h = new Uint8Array(8192), f = 0, d = new Array(t.channels), p = 0; p < t.channels; p++)
        d[p] = {}, d[p].start = f, d[p].end = d[p].start, d[p].nx = t.width, d[p].ny = t.lines, d[p].size = t.type, f += d[p].nx * d[p].ny * d[p].size;
      var g = tt(n, a), A = tt(n, a);
      if (A >= 8192)
        throw "Something is wrong with PIZ_COMPRESSION BITMAP_SIZE";
      if (g <= A)
        for (var p = 0; p < A - g + 1; p++)
          h[p + g] = We(n, a);
      var S = new Uint16Array(65536), w = rr(h, S), Y = ne(n, a);
      Rr(t.array, n, a, Y, u, f);
      for (var p = 0; p < t.channels; ++p)
        for (var I = d[p], _ = 0; _ < d[p].size; ++_)
          Vn(u, I.start + _, I.nx, I.size, I.ny, I.nx * I.size, w);
      $n(S, u, f);
      for (var N = 0, m = new Uint8Array(u.buffer.byteLength), M = 0; M < t.lines; M++)
        for (var z = 0; z < t.channels; z++) {
          var I = d[z], V = I.nx * I.size, te = new Uint8Array(u.buffer, I.end * 2, V * 2);
          m.set(te, N), N += V * 2, I.end += V;
        }
      return new DataView(m.buffer);
    }
    function oi(t) {
      var n = t.array.slice(t.offset.value, t.offset.value + t.size), a = Pt(n);
      const u = t.lines * t.channels * t.width, h = t.type == 1 ? new Uint16Array(u) : new Uint32Array(u);
      let f = 0, d = 0;
      const p = new Array(4);
      for (let g = 0; g < t.lines; g++)
        for (let A = 0; A < t.channels; A++) {
          let S = 0;
          switch (t.type) {
            case 1:
              p[0] = f, p[1] = p[0] + t.width, f = p[1] + t.width;
              for (let w = 0; w < t.width; ++w) {
                const Y = a[p[0]++] << 8 | a[p[1]++];
                S += Y, h[d] = S, d++;
              }
              break;
            case 2:
              p[0] = f, p[1] = p[0] + t.width, p[2] = p[1] + t.width, f = p[2] + t.width;
              for (let w = 0; w < t.width; ++w) {
                const Y = a[p[0]++] << 24 | a[p[1]++] << 16 | a[p[2]++] << 8;
                S += Y, h[d] = S, d++;
              }
              break;
          }
        }
      return new DataView(h.buffer);
    }
    function Mr(t) {
      var n = t.viewer, a = { value: t.offset.value }, u = new Uint8Array(t.width * t.lines * (t.channels * t.type * 2)), h = {
        version: ue(n, a),
        unknownUncompressedSize: ue(n, a),
        unknownCompressedSize: ue(n, a),
        acCompressedSize: ue(n, a),
        dcCompressedSize: ue(n, a),
        rleCompressedSize: ue(n, a),
        rleUncompressedSize: ue(n, a),
        rleRawSize: ue(n, a),
        totalAcUncompressedCount: ue(n, a),
        totalDcUncompressedCount: ue(n, a),
        acCompression: ue(n, a)
      };
      if (h.version < 2)
        throw "EXRLoader.parse: " + nt.compression + " version " + h.version + " is unsupported";
      for (var f = new Array(), d = tt(n, a) - 2; d > 0; ) {
        var p = Ct(n.buffer, a), g = We(n, a), A = g >> 2 & 3, S = (g >> 4) - 1, w = new Int8Array([S])[0], Y = We(n, a);
        f.push({
          name: p,
          index: w,
          type: Y,
          compression: A
        }), d -= p.length + 3;
      }
      for (var I = nt.channels, _ = new Array(t.channels), N = 0; N < t.channels; ++N) {
        var m = _[N] = {}, M = I[N];
        m.name = M.name, m.compression = 0, m.decoded = !1, m.type = M.pixelType, m.pLinear = M.pLinear, m.width = t.width, m.height = t.lines;
      }
      for (var z = {
        idx: new Array(3)
      }, V = 0; V < t.channels; ++V)
        for (var m = _[V], N = 0; N < f.length; ++N) {
          var te = f[N];
          m.name == te.name && (m.compression = te.compression, te.index >= 0 && (z.idx[te.index] = V), m.offset = V);
        }
      if (h.acCompressedSize > 0)
        switch (h.acCompression) {
          case 0:
            var H = new Uint16Array(h.totalAcUncompressedCount);
            Rr(
              t.array,
              n,
              a,
              h.acCompressedSize,
              H,
              h.totalAcUncompressedCount
            );
            break;
          case 1:
            var k = t.array.slice(a.value, a.value + h.totalAcUncompressedCount), Te = Pt(k), H = new Uint16Array(Te.buffer);
            a.value += h.totalAcUncompressedCount;
            break;
        }
      if (h.dcCompressedSize > 0) {
        var J = {
          array: t.array,
          offset: a,
          size: h.dcCompressedSize
        }, Oe = new Uint16Array(ir(J).buffer);
        a.value += h.dcCompressedSize;
      }
      if (h.rleRawSize > 0) {
        var k = t.array.slice(a.value, a.value + h.rleCompressedSize), Te = Pt(k), it = Lr(Te.buffer);
        a.value += h.rleCompressedSize;
      }
      for (var he = 0, D = new Array(_.length), N = 0; N < D.length; ++N)
        D[N] = new Array();
      for (var K = 0; K < t.lines; ++K)
        for (var W = 0; W < _.length; ++W)
          D[W].push(he), he += _[W].width * t.type * 2;
      Qn(z, D, _, H, Oe, u);
      for (var N = 0; N < _.length; ++N) {
        var m = _[N];
        if (!m.decoded)
          switch (m.compression) {
            case 2:
              for (var F = 0, fe = 0, K = 0; K < t.lines; ++K) {
                for (var De = D[N][F], ae = 0; ae < m.width; ++ae) {
                  for (var xe = 0; xe < 2 * m.type; ++xe)
                    u[De++] = it[fe + xe * m.width * m.height];
                  fe++;
                }
                F++;
              }
              break;
            case 1:
            default:
              throw "EXRLoader.parse: unsupported channel compression";
          }
      }
      return new DataView(u.buffer);
    }
    function Ct(t, n) {
      for (var a = new Uint8Array(t), u = 0; a[n.value + u] != 0; )
        u += 1;
      var h = new TextDecoder().decode(a.slice(n.value, n.value + u));
      return n.value = n.value + u + 1, h;
    }
    function ai(t, n, a) {
      var u = new TextDecoder().decode(new Uint8Array(t).slice(n.value, n.value + a));
      return n.value = n.value + a, u;
    }
    function ci(t, n) {
      var a = et(t, n), u = ne(t, n);
      return [a, u];
    }
    function li(t, n) {
      var a = ne(t, n), u = ne(t, n);
      return [a, u];
    }
    function et(t, n) {
      var a = t.getInt32(n.value, !0);
      return n.value = n.value + 4, a;
    }
    function ne(t, n) {
      var a = t.getUint32(n.value, !0);
      return n.value = n.value + 4, a;
    }
    function Dr(t, n) {
      var a = t[n.value];
      return n.value = n.value + 1, a;
    }
    function We(t, n) {
      var a = t.getUint8(n.value);
      return n.value = n.value + 1, a;
    }
    const ue = function(t, n) {
      let a;
      return "getBigInt64" in DataView.prototype ? a = Number(t.getBigInt64(n.value, !0)) : a = t.getUint32(n.value + 4, !0) + Number(t.getUint32(n.value, !0) << 32), n.value += 8, a;
    };
    function j(t, n) {
      var a = t.getFloat32(n.value, !0);
      return n.value += 4, a;
    }
    function ui(t, n) {
      return Zr.toHalfFloat(j(t, n));
    }
    function T(t) {
      var n = (t & 31744) >> 10, a = t & 1023;
      return (t >> 15 ? -1 : 1) * (n ? n === 31 ? a ? NaN : 1 / 0 : Math.pow(2, n - 15) * (1 + a / 1024) : 6103515625e-14 * (a / 1024));
    }
    function tt(t, n) {
      var a = t.getUint16(n.value, !0);
      return n.value += 2, a;
    }
    function hi(t, n) {
      return T(tt(t, n));
    }
    function fi(t, n, a, u) {
      for (var h = a.value, f = []; a.value < h + u - 1; ) {
        var d = Ct(n, a), p = et(t, a), g = We(t, a);
        a.value += 3;
        var A = et(t, a), S = et(t, a);
        f.push({
          name: d,
          pixelType: p,
          pLinear: g,
          xSampling: A,
          ySampling: S
        });
      }
      return a.value += 1, f;
    }
    function vi(t, n) {
      var a = j(t, n), u = j(t, n), h = j(t, n), f = j(t, n), d = j(t, n), p = j(t, n), g = j(t, n), A = j(t, n);
      return {
        redX: a,
        redY: u,
        greenX: h,
        greenY: f,
        blueX: d,
        blueY: p,
        whiteX: g,
        whiteY: A
      };
    }
    function yi(t, n) {
      var a = [
        "NO_COMPRESSION",
        "RLE_COMPRESSION",
        "ZIPS_COMPRESSION",
        "ZIP_COMPRESSION",
        "PIZ_COMPRESSION",
        "PXR24_COMPRESSION",
        "B44_COMPRESSION",
        "B44A_COMPRESSION",
        "DWAA_COMPRESSION",
        "DWAB_COMPRESSION"
      ], u = We(t, n);
      return a[u];
    }
    function pi(t, n) {
      var a = ne(t, n), u = ne(t, n), h = ne(t, n), f = ne(t, n);
      return { xMin: a, yMin: u, xMax: h, yMax: f };
    }
    function di(t, n) {
      var a = ["INCREASING_Y"], u = We(t, n);
      return a[u];
    }
    function wi(t, n) {
      var a = j(t, n), u = j(t, n);
      return [a, u];
    }
    function Ai(t, n) {
      var a = j(t, n), u = j(t, n), h = j(t, n);
      return [a, u, h];
    }
    function gi(t, n, a, u, h) {
      if (u === "string" || u === "stringvector" || u === "iccProfile")
        return ai(n, a, h);
      if (u === "chlist")
        return fi(t, n, a, h);
      if (u === "chromaticities")
        return vi(t, a);
      if (u === "compression")
        return yi(t, a);
      if (u === "box2i")
        return pi(t, a);
      if (u === "lineOrder")
        return di(t, a);
      if (u === "float")
        return j(t, a);
      if (u === "v2f")
        return wi(t, a);
      if (u === "v3f")
        return Ai(t, a);
      if (u === "int")
        return et(t, a);
      if (u === "rational")
        return ci(t, a);
      if (u === "timecode")
        return li(t, a);
      if (u === "preview")
        return a.value += h, "skipped";
      a.value += h;
    }
    function Si(t, n, a) {
      const u = {};
      if (t.getUint32(0, !0) != 20000630)
        throw "THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.";
      u.version = t.getUint8(4);
      const h = t.getUint8(5);
      u.spec = {
        singleTile: !!(h & 2),
        longName: !!(h & 4),
        deepFormat: !!(h & 8),
        multiPart: !!(h & 16)
      }, a.value = 8;
      for (var f = !0; f; ) {
        var d = Ct(n, a);
        if (d == 0)
          f = !1;
        else {
          var p = Ct(n, a), g = ne(t, a), A = gi(t, n, a, p, g);
          A === void 0 ? console.warn(`EXRLoader.parse: skipped unknown header attribute type '${p}'.`) : u[d] = A;
        }
      }
      if ((h & -5) != 0)
        throw console.error("EXRHeader:", u), "THREE.EXRLoader: provided file is currently unsupported.";
      return u;
    }
    function Ti(t, n, a, u, h) {
      const f = {
        size: 0,
        viewer: n,
        array: a,
        offset: u,
        width: t.dataWindow.xMax - t.dataWindow.xMin + 1,
        height: t.dataWindow.yMax - t.dataWindow.yMin + 1,
        channels: t.channels.length,
        bytesPerLine: null,
        lines: null,
        inputSize: null,
        type: t.channels[0].pixelType,
        uncompress: null,
        getter: null,
        format: null,
        [at ? "colorSpace" : "encoding"]: null
      };
      switch (t.compression) {
        case "NO_COMPRESSION":
          f.lines = 1, f.uncompress = Pr;
          break;
        case "RLE_COMPRESSION":
          f.lines = 1, f.uncompress = ii;
          break;
        case "ZIPS_COMPRESSION":
          f.lines = 1, f.uncompress = ir;
          break;
        case "ZIP_COMPRESSION":
          f.lines = 16, f.uncompress = ir;
          break;
        case "PIZ_COMPRESSION":
          f.lines = 32, f.uncompress = si;
          break;
        case "PXR24_COMPRESSION":
          f.lines = 16, f.uncompress = oi;
          break;
        case "DWAA_COMPRESSION":
          f.lines = 32, f.uncompress = Mr;
          break;
        case "DWAB_COMPRESSION":
          f.lines = 256, f.uncompress = Mr;
          break;
        default:
          throw "EXRLoader.parse: " + t.compression + " is unsupported";
      }
      if (f.scanlineBlockSize = f.lines, f.type == 1)
        switch (h) {
          case ft:
            f.getter = hi, f.inputSize = 2;
            break;
          case lt:
            f.getter = tt, f.inputSize = 2;
            break;
        }
      else if (f.type == 2)
        switch (h) {
          case ft:
            f.getter = j, f.inputSize = 4;
            break;
          case lt:
            f.getter = ui, f.inputSize = 4;
        }
      else
        throw "EXRLoader.parse: unsupported pixelType " + f.type + " for " + t.compression + ".";
      f.blockCount = (t.dataWindow.yMax + 1) / f.scanlineBlockSize;
      for (var d = 0; d < f.blockCount; d++)
        ue(n, u);
      f.outputChannels = f.channels == 3 ? 4 : f.channels;
      const p = f.width * f.height * f.outputChannels;
      switch (h) {
        case ft:
          f.byteArray = new Float32Array(p), f.channels < f.outputChannels && f.byteArray.fill(1, 0, p);
          break;
        case lt:
          f.byteArray = new Uint16Array(p), f.channels < f.outputChannels && f.byteArray.fill(15360, 0, p);
          break;
        default:
          console.error("THREE.EXRLoader: unsupported type: ", h);
          break;
      }
      return f.bytesPerLine = f.width * f.inputSize * f.channels, f.outputChannels == 4 ? f.format = ln : f.format = hn, at ? f.colorSpace = "srgb-linear" : f.encoding = 3e3, f;
    }
    const Rt = new DataView(e), Ei = new Uint8Array(e), rt = { value: 0 }, nt = Si(Rt, e, rt), C = Ti(nt, Rt, Ei, rt, this.type), Br = { value: 0 }, Ii = { R: 0, G: 1, B: 2, A: 3, Y: 0 };
    for (let t = 0; t < C.height / C.scanlineBlockSize; t++) {
      const n = ne(Rt, rt);
      C.size = ne(Rt, rt), C.lines = n + C.scanlineBlockSize > C.height ? C.height - n : C.scanlineBlockSize;
      const u = C.size < C.lines * C.bytesPerLine ? C.uncompress(C) : Pr(C);
      rt.value += C.size;
      for (let h = 0; h < C.scanlineBlockSize; h++) {
        const f = h + t * C.scanlineBlockSize;
        if (f >= C.height)
          break;
        for (let d = 0; d < C.channels; d++) {
          const p = Ii[nt.channels[d].name];
          for (let g = 0; g < C.width; g++) {
            Br.value = (h * (C.channels * C.width) + d * C.width + g) * C.inputSize;
            const A = (C.height - 1 - f) * (C.width * C.outputChannels) + g * C.outputChannels + p;
            C.byteArray[A] = C.getter(u, Br);
          }
        }
      }
    }
    return {
      header: nt,
      width: C.width,
      height: C.height,
      data: C.byteArray,
      format: C.format,
      [at ? "colorSpace" : "encoding"]: C[at ? "colorSpace" : "encoding"],
      type: this.type
    };
  }
  setDataType(e) {
    return this.type = e, this;
  }
  load(e, i, s, o) {
    function c(l, v) {
      at ? l.colorSpace = v.colorSpace : l.encoding = v.encoding, l.minFilter = zt, l.magFilter = zt, l.generateMipmaps = !1, l.flipY = !1, i && i(l, v);
    }
    return super.load(e, c, s, o);
  }
}
class qo extends qt {
  setDepth(e) {
    return this.depth = e, this;
  }
  load(e, i, s, o) {
    const c = new so(this.manager);
    c.setRequestHeader(this.requestHeader), c.setPath(this.path), c.setWithCredentials(this.withCredentials), c.load(
      e,
      (l) => {
        const { data: v, width: y, height: E } = l.image, b = this.depth ?? Math.sqrt(E), U = new un(v, y, E / b, b);
        U.type = l.type, U.format = l.format, U.colorSpace = l.colorSpace, U.needsUpdate = !0;
        try {
          i(U);
        } catch (q) {
          o != null ? o(q) : console.error(q), this.manager.itemError(e);
        }
      },
      s,
      o
    );
  }
}
const fr = 1e-6, Mt = /* @__PURE__ */ new Re(), Dt = /* @__PURE__ */ new Re(), me = /* @__PURE__ */ new Re(), ct = /* @__PURE__ */ new Re(), vr = /* @__PURE__ */ new Re(), oo = /* @__PURE__ */ new Re(), ao = /* @__PURE__ */ new Di(), co = /* @__PURE__ */ new Mi(), lo = /* @__PURE__ */ new Bi();
class Xn {
  constructor(e = 0, i = 0, s = 0, o = 0) {
    this.distance = e, this.heading = i, this.pitch = s, this.roll = o;
  }
  get distance() {
    return this._distance;
  }
  set distance(e) {
    this._distance = Math.max(e, fr);
  }
  get pitch() {
    return this._pitch;
  }
  set pitch(e) {
    this._pitch = Je(e, -Math.PI / 2 + fr, Math.PI / 2 - fr);
  }
  set(e, i, s, o) {
    return this.distance = e, this.heading = i, this.pitch = s, o != null && (this.roll = o), this;
  }
  clone() {
    return new Xn(this.distance, this.heading, this.pitch, this.roll);
  }
  copy(e) {
    return this.distance = e.distance, this.heading = e.heading, this.pitch = e.pitch, this.roll = e.roll, this;
  }
  equals(e) {
    return e.distance === this.distance && e.heading === this.heading && e.pitch === this.pitch && e.roll === this.roll;
  }
  decompose(e, i, s, o, c = Gr.WGS84) {
    c.getEastNorthUpVectors(
      e,
      Mt,
      Dt,
      me
    ), o == null || o.copy(me);
    const l = ct.copy(Mt).multiplyScalar(Math.cos(this.heading)).add(
      vr.copy(Dt).multiplyScalar(Math.sin(this.heading))
    ).multiplyScalar(Math.cos(this.pitch)).add(vr.copy(me).multiplyScalar(Math.sin(this.pitch))).normalize().multiplyScalar(this.distance);
    if (i.copy(e).sub(l), this.roll !== 0) {
      const v = ct.copy(e).sub(i).normalize();
      me.applyQuaternion(
        co.setFromAxisAngle(v, this.roll)
      );
    }
    s.setFromRotationMatrix(
      ao.lookAt(i, e, me)
    );
  }
  setFromCamera(e, i = Gr.WGS84) {
    const s = ct.setFromMatrixPosition(e.matrixWorld), o = vr.set(0, 0, 0.5).unproject(e).sub(s).normalize(), c = i.getIntersection(lo.set(s, o));
    if (c == null)
      return;
    this.distance = s.distanceTo(c), i.getEastNorthUpVectors(
      c,
      Mt,
      Dt,
      me
    ), this.heading = Math.atan2(
      Dt.dot(o),
      Mt.dot(o)
    ), this.pitch = Math.asin(me.dot(o));
    const l = ct.copy(e.up).applyQuaternion(e.quaternion), v = oo.copy(o).multiplyScalar(-l.dot(o)).add(l).normalize(), y = ct.copy(o).multiplyScalar(-me.dot(o)).add(me).normalize(), E = y.dot(v), b = o.dot(y.cross(v));
    return this.roll = Math.atan2(b, E), this;
  }
}
const dt = class dt {
  constructor(e = 0, i = 0, s = 0, o = 0) {
    this.west = e, this.south = i, this.east = s, this.north = o;
  }
  get width() {
    let e = this.east;
    return e < this.west && (e += Math.PI * 2), e - this.west;
  }
  get height() {
    return this.north - this.south;
  }
  set(e, i, s, o) {
    return this.west = e, this.south = i, this.east = s, this.north = o, this;
  }
  clone() {
    return new dt(this.west, this.south, this.east, this.north);
  }
  copy(e) {
    return this.west = e.west, this.south = e.south, this.east = e.east, this.north = e.north, this;
  }
  equals(e) {
    return e.west === this.west && e.south === this.south && e.east === this.east && e.north === this.north;
  }
  at(e, i, s = new st()) {
    return s.set(
      this.west + (this.east - this.west) * e,
      this.north + (this.south - this.north) * i
    );
  }
  fromArray(e, i = 0) {
    return this.west = e[i], this.south = e[i + 1], this.east = e[i + 2], this.north = e[i + 3], this;
  }
  toArray(e = [], i = 0) {
    return e[i] = this.west, e[i + 1] = this.south, e[i + 2] = this.east, e[i + 3] = this.north, e;
  }
  *[Symbol.iterator]() {
    yield this.west, yield this.south, yield this.east, yield this.north;
  }
};
dt.MAX = /* @__PURE__ */ new dt(
  st.MIN_LONGITUDE,
  st.MIN_LATITUDE,
  st.MAX_LONGITUDE,
  st.MAX_LATITUDE
);
let Yt = dt;
const uo = /^[ \t]*#include +"([\w\d./]+)"/gm;
function ho(r, e) {
  return r.replace(uo, (i, s) => {
    const c = s.split("/").reduce(
      (l, v) => typeof l != "string" && l != null ? l[v] : void 0,
      e
    );
    if (typeof c != "string")
      throw new Error(`Could not find include for ${s}.`);
    return ho(c, e);
  });
}
let Bt;
function fo() {
  if (Bt != null)
    return Bt;
  const r = new Uint32Array([268435456]);
  return Bt = new Uint8Array(r.buffer, r.byteOffset, r.byteLength)[0] === 0, Bt;
}
function ke(r, e, i, s = !0) {
  if (s === fo())
    return new e(r);
  const o = Object.assign(new DataView(r), {
    getFloat16(l, v) {
      return zs(this, l, v);
    }
  }), c = new e(o.byteLength / e.BYTES_PER_ELEMENT);
  for (let l = 0, v = 0; l < c.length; ++l, v += e.BYTES_PER_ELEMENT)
    c[l] = o[i](v, s);
  return c;
}
const vo = (r) => new Uint8Array(r), Vo = (r) => new Int8Array(r), Jo = (r, e) => ke(r, Uint16Array, "getUint16", e), $o = (r, e) => ke(r, Int16Array, "getInt16", e), Qo = (r, e) => ke(r, Int32Array, "getInt32", e), jo = (r, e) => ke(r, Uint32Array, "getUint32", e), Ko = (r, e) => ke(r, B, "getFloat16", e), ea = (r, e) => ke(r, Float32Array, "getFloat32", e), ta = (r, e) => ke(r, Float64Array, "getFloat64", e), ra = Bn(vo, {
  format: hn,
  minFilter: Hr,
  magFilter: Hr,
  wrapS: sr,
  wrapT: sr,
  wrapR: sr,
  width: Zi,
  height: Hi,
  depth: Gi
});
function* Yn(r, e, i, s, o) {
  if (i >= s)
    return;
  const c = 2 ** i, l = i + 1, v = 2 ** l, y = Math.floor(r / c * v), E = Math.floor(e / c * v), b = [
    [y, E, l],
    [y + 1, E, l],
    [y, E + 1, l],
    [y + 1, E + 1, l]
  ];
  if (l < s)
    for (const U of b)
      for (const q of Yn(...U, s, o))
        yield q;
  else
    for (const U of b)
      yield (o ?? new wt()).set(...U);
}
class wt {
  constructor(e = 0, i = 0, s = 0) {
    this.x = e, this.y = i, this.z = s;
  }
  set(e, i, s) {
    return this.x = e, this.y = i, s != null && (this.z = s), this;
  }
  clone() {
    return new wt(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  getParent(e = new wt()) {
    const i = 2 ** this.z, s = this.x / i, o = this.y / i, c = this.z - 1, l = 2 ** c;
    return e.set(Math.floor(s * l), Math.floor(o * l), c);
  }
  *traverseChildren(e, i) {
    const { x: s, y: o, z: c } = this;
    for (const l of Yn(s, o, c, c + e, i))
      yield l;
  }
  fromArray(e, i = 0) {
    return this.x = e[i], this.y = e[i + 1], this.z = e[i + 2], this;
  }
  toArray(e = [], i = 0) {
    return e[i] = this.x, e[i + 1] = this.y, e[i + 2] = this.z, e;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const cn = /* @__PURE__ */ new fn();
class qn {
  constructor(e = 2, i = 1, s = Yt.MAX) {
    this.width = e, this.height = i, this.rectangle = s;
  }
  clone() {
    return new qn(this.width, this.height, this.rectangle.clone());
  }
  copy(e) {
    return this.width = e.width, this.height = e.height, this.rectangle.copy(e.rectangle), this;
  }
  getSize(e, i = new fn()) {
    return i.set(this.width << e, this.height << e);
  }
  // Reference: https://github.com/CesiumGS/cesium/blob/1.122/packages/engine/Source/Core/GeographicTilingScheme.js#L210
  getTile(e, i, s = new wt()) {
    const o = this.getSize(i, cn), { rectangle: c } = this, l = c.width / o.x, v = c.height / o.y, { west: y, south: E, east: b } = c;
    let U = e.longitude;
    b < y && (U += Math.PI * 2);
    let q = Math.floor((U - y) / l);
    q >= o.x && (q = o.x - 1);
    let se = Math.floor((e.latitude - E) / v);
    return se >= o.y && (se = o.y - 1), s.x = q, s.y = se, s.z = i, s;
  }
  // Reference: https://github.com/CesiumGS/cesium/blob/1.122/packages/engine/Source/Core/GeographicTilingScheme.js#L169
  getRectangle(e, i = new Yt()) {
    const s = this.getSize(e.z, cn), { rectangle: o } = this, c = o.width / s.x, l = o.height / s.y, { west: v, north: y } = o;
    return i.west = e.x * c + v, i.east = (e.x + 1) * c + v, i.north = y - (s.y - e.y - 1) * l, i.south = y - (s.y - e.y) * l, i;
  }
}
const yo = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*(?:i\s*\+\+|\+\+\s*i)\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function po(r, e, i, s) {
  let o = "";
  for (let c = parseInt(e); c < parseInt(i); ++c)
    o += s.replace(/\[\s*i\s*\]/g, "[" + c + "]").replace(/UNROLLED_LOOP_INDEX/g, `${c}`);
  return o;
}
function na(r) {
  return r.replace(yo, po);
}
export {
  ki as ArrayBufferLoader,
  Eo as DEFAULT_STBN_URL,
  Gs as DataLoader,
  qo as EXR3DLoader,
  Gr as Ellipsoid,
  oa as EllipsoidGeometry,
  B as Float16Array,
  st as Geodetic,
  Xn as PointOfView,
  Yt as Rectangle,
  ra as STBNLoader,
  Gi as STBN_TEXTURE_DEPTH,
  Hi as STBN_TEXTURE_HEIGHT,
  Zi as STBN_TEXTURE_WIDTH,
  wt as TileCoordinate,
  qn as TilingScheme,
  ks as TypedArrayLoader,
  go as assertType,
  Fo as ceilPowerOfTwo,
  Je as clamp,
  ko as closeTo,
  bo as createData3DTextureLoader,
  Bn as createData3DTextureLoaderClass,
  No as createDataTextureLoader,
  Ws as createDataTextureLoaderClass,
  _o as createTypedArrayLoader,
  Mn as createTypedArrayLoaderClass,
  Zo as define,
  Wo as defineExpression,
  Go as defineFloat,
  Ho as defineInt,
  Xo as definePropertyShorthand,
  Yo as defineUniformShorthand,
  Ro as degrees,
  Oo as euclideanModulo,
  Lo as floorPowerOfTwo,
  To as fromBufferGeometryLike,
  mo as inverseLerp,
  xo as isPowerOfTwo,
  Io as isTypedArray,
  Uo as lerp,
  Po as normalize,
  Ko as parseFloat16Array,
  ea as parseFloat32Array,
  ta as parseFloat64Array,
  $o as parseInt16Array,
  Qo as parseInt32Array,
  Vo as parseInt8Array,
  Jo as parseUint16Array,
  jo as parseUint32Array,
  vo as parseUint8Array,
  Co as radians,
  Mo as remap,
  Do as remapClamped,
  ho as resolveIncludes,
  zo as saturate,
  Bo as smoothstep,
  So as toBufferGeometryLike,
  na as unrollLoops
};
//# sourceMappingURL=index.js.map
