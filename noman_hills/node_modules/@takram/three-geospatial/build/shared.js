import { Vector3 as h, Matrix4 as j, BufferGeometry as B, BufferAttribute as b } from "three";
const W = /* @__PURE__ */ new h();
function C(E, t, i = new h(), s) {
  const { x: r, y: e, z: n } = E, o = t.x, a = t.y, y = t.z, u = r * r * o, d = e * e * a, c = n * n * y, l = u + d + c, p = Math.sqrt(1 / l);
  if (!Number.isFinite(p))
    return;
  const x = W.copy(E).multiplyScalar(p);
  if (l < ((s == null ? void 0 : s.centerTolerance) ?? 0.1))
    return i.copy(x);
  const f = x.multiply(t).multiplyScalar(2);
  let m = (1 - p) * E.length() / (f.length() / 2), I = 0, M, w, g, v;
  do {
    m -= I, M = 1 / (1 + m * o), w = 1 / (1 + m * a), g = 1 / (1 + m * y);
    const V = M * M, F = w * w, L = g * g, D = V * M, G = F * w, P = L * g;
    v = u * V + d * F + c * L - 1, I = v / ((u * D * o + d * G * a + c * P * y) * -2);
  } while (Math.abs(v) > 1e-12);
  return i.set(r * M, e * w, n * g);
}
const A = /* @__PURE__ */ new h(), T = /* @__PURE__ */ new h(), U = /* @__PURE__ */ new h(), S = class S {
  constructor(t, i, s) {
    this.radii = new h(t, i, s);
  }
  get minimumRadius() {
    return Math.min(this.radii.x, this.radii.y, this.radii.z);
  }
  get maximumRadius() {
    return Math.max(this.radii.x, this.radii.y, this.radii.z);
  }
  reciprocalRadii(t = new h()) {
    const { x: i, y: s, z: r } = this.radii;
    return t.set(1 / i, 1 / s, 1 / r);
  }
  reciprocalRadiiSquared(t = new h()) {
    const { x: i, y: s, z: r } = this.radii;
    return t.set(1 / i ** 2, 1 / s ** 2, 1 / r ** 2);
  }
  projectOnSurface(t, i = new h(), s) {
    return C(
      t,
      this.reciprocalRadiiSquared(),
      i,
      s
    );
  }
  getSurfaceNormal(t, i = new h()) {
    return i.multiplyVectors(this.reciprocalRadiiSquared(A), t).normalize();
  }
  getEastNorthUpVectors(t, i = new h(), s = new h(), r = new h()) {
    this.getSurfaceNormal(t, r), i.set(-t.y, t.x, 0).normalize(), s.crossVectors(r, i).normalize();
  }
  getEastNorthUpFrame(t, i = new j()) {
    const s = A, r = T, e = U;
    return this.getEastNorthUpVectors(t, s, r, e), i.makeBasis(s, r, e).setPosition(t);
  }
  getIntersection(t, i = new h()) {
    const s = this.reciprocalRadii(A), r = T.copy(s).multiply(t.origin), e = U.copy(s).multiply(t.direction), n = r.lengthSq(), o = e.lengthSq(), a = r.dot(e), y = a ** 2 - o * (n - 1);
    if (n === 1)
      return i.copy(t.origin);
    if (n > 1) {
      if (a >= 0 || y < 0)
        return;
      const u = Math.sqrt(y), d = (-a - u) / o, c = (-a + u) / o;
      return t.at(Math.min(d, c), i);
    }
    if (n < 1) {
      const u = a ** 2 - o * (n - 1), d = Math.sqrt(u), c = (-a + d) / o;
      return t.at(c, i);
    }
    if (a < 0)
      return t.at(-a / o, i);
  }
  getOsculatingSphereCenter(t, i, s = new h()) {
    const r = this.radii.x ** 2, e = A.set(
      t.x / r,
      t.y / r,
      t.z / this.radii.z ** 2
    ).normalize();
    return s.copy(e.multiplyScalar(-i).add(t));
  }
};
S.WGS84 = /* @__PURE__ */ new S(
  6378137,
  6378137,
  6356752314245179e-9
);
let N = S;
class Q extends B {
  constructor(t = new h(1, 1, 1), i = 32, s = 16) {
    super(), this.type = "EllipsoidGeometry", this.parameters = {
      radii: t,
      longitudeSegments: i,
      latitudeSegments: s
    }, i = Math.max(3, Math.floor(i)), s = Math.max(2, Math.floor(s));
    const r = (i + 1) * (s + 1), e = new h(), n = new h(), o = new Float32Array(r * 3), a = new Float32Array(r * 3), y = new Float32Array(r * 2), u = [], d = [];
    for (let c = 0, l = 0, p = 0, x = 0; c <= s; ++c) {
      const f = [], m = c / s, I = m * Math.PI;
      let M = 0;
      c === 0 ? M = 0.5 / i : c === s && (M = -0.5 / i);
      for (let w = 0; w <= i; ++w, l += 3, p += 2, ++x) {
        const g = w / i, v = g * Math.PI * 2;
        e.x = t.x * Math.cos(v) * Math.sin(I), e.y = t.y * Math.sin(v) * Math.sin(I), e.z = t.z * Math.cos(I), o[l] = e.x, o[l + 1] = e.y, o[l + 2] = e.z, n.copy(e).normalize(), a[l] = n.x, a[l + 1] = n.y, a[l + 2] = n.z, y[p] = g + M, y[p + 1] = 1 - m, f.push(x);
      }
      u.push(f);
    }
    for (let c = 0; c < s; ++c)
      for (let l = 0; l < i; ++l) {
        const p = u[c][l + 1], x = u[c][l], f = u[c + 1][l], m = u[c + 1][l + 1];
        c !== 0 && d.push(p, x, m), c !== s - 1 && d.push(x, f, m);
      }
    this.setIndex(d), this.setAttribute("position", new b(o, 3)), this.setAttribute("normal", new b(a, 3)), this.setAttribute("uv", new b(y, 2));
  }
  copy(t) {
    return super.copy(t), this.parameters = { ...t.parameters }, this;
  }
}
const q = /* @__PURE__ */ new h(), O = /* @__PURE__ */ new h(), z = class z {
  constructor(t = 0, i = 0, s = 0) {
    this.longitude = t, this.latitude = i, this.height = s;
  }
  set(t, i, s) {
    return this.longitude = t, this.latitude = i, s != null && (this.height = s), this;
  }
  clone() {
    return new z(this.longitude, this.latitude, this.height);
  }
  copy(t) {
    return this.longitude = t.longitude, this.latitude = t.latitude, this.height = t.height, this;
  }
  equals(t) {
    return t.longitude === this.longitude && t.latitude === this.latitude && t.height === this.height;
  }
  setLongitude(t) {
    return this.longitude = t, this;
  }
  setLatitude(t) {
    return this.latitude = t, this;
  }
  setHeight(t) {
    return this.height = t, this;
  }
  normalize() {
    return this.longitude < z.MIN_LONGITUDE && (this.longitude += Math.PI * 2), this;
  }
  // See: https://en.wikipedia.org/wiki/Geographic_coordinate_conversion
  // Reference: https://github.com/CesiumGS/cesium/blob/1.122/packages/engine/Source/Core/Geodetic.js#L119
  setFromECEF(t, i) {
    const r = ((i == null ? void 0 : i.ellipsoid) ?? N.WGS84).reciprocalRadiiSquared(q), e = C(
      t,
      r,
      O,
      i
    );
    if (e == null)
      throw new Error(
        `Could not project position to ellipsoid surface: ${t.toArray()}`
      );
    const n = q.multiplyVectors(e, r).normalize();
    this.longitude = Math.atan2(n.y, n.x), this.latitude = Math.asin(n.z);
    const o = q.subVectors(t, e);
    return this.height = Math.sign(o.dot(t)) * o.length(), this;
  }
  // See: https://en.wikipedia.org/wiki/Geographic_coordinate_conversion
  // Reference: https://github.com/CesiumGS/cesium/blob/1.122/packages/engine/Source/Core/Cartesian3.js#L916
  toECEF(t = new h(), i) {
    const s = (i == null ? void 0 : i.ellipsoid) ?? N.WGS84, r = q.multiplyVectors(
      s.radii,
      s.radii
    ), e = Math.cos(this.latitude), n = O.set(
      e * Math.cos(this.longitude),
      e * Math.sin(this.longitude),
      Math.sin(this.latitude)
    ).normalize();
    return t.multiplyVectors(r, n), t.divideScalar(Math.sqrt(n.dot(t))).add(n.multiplyScalar(this.height));
  }
  fromArray(t, i = 0) {
    return this.longitude = t[i], this.latitude = t[i + 1], this.height = t[i + 2], this;
  }
  toArray(t = [], i = 0) {
    return t[i] = this.longitude, t[i + 1] = this.latitude, t[i + 2] = this.height, t;
  }
  *[Symbol.iterator]() {
    yield this.longitude, yield this.latitude, yield this.height;
  }
};
z.MIN_LONGITUDE = -Math.PI, z.MAX_LONGITUDE = Math.PI, z.MIN_LATITUDE = -Math.PI / 2, z.MAX_LATITUDE = Math.PI / 2;
let R = z;
export {
  N as E,
  R as G,
  Q as a
};
//# sourceMappingURL=shared.js.map
