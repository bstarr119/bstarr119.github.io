"use strict";const c=require("three"),D=new c.Vector3;function O(A,t,i=new c.Vector3,e){const{x:r,y:s,z:n}=A,h=t.x,a=t.y,y=t.z,u=r*r*h,d=s*s*a,o=n*n*y,l=u+d+o,p=Math.sqrt(1/l);if(!Number.isFinite(p))return;const x=D.copy(A).multiplyScalar(p);if(l<((e==null?void 0:e.centerTolerance)??.1))return i.copy(x);const f=x.multiply(t).multiplyScalar(2);let m=(1-p)*A.length()/(f.length()/2),z=0,M,w,V,I;do{m-=z,M=1/(1+m*h),w=1/(1+m*a),V=1/(1+m*y);const S=M*M,T=w*w,F=V*V,G=S*M,B=T*w,C=F*V;I=u*S+d*T+o*F-1,z=I/((u*G*h+d*B*a+o*C*y)*-2)}while(Math.abs(I)>1e-12);return i.set(r*M,s*w,n*V)}const v=new c.Vector3,L=new c.Vector3,R=new c.Vector3,b=class b{constructor(t,i,e){this.radii=new c.Vector3(t,i,e)}get minimumRadius(){return Math.min(this.radii.x,this.radii.y,this.radii.z)}get maximumRadius(){return Math.max(this.radii.x,this.radii.y,this.radii.z)}reciprocalRadii(t=new c.Vector3){const{x:i,y:e,z:r}=this.radii;return t.set(1/i,1/e,1/r)}reciprocalRadiiSquared(t=new c.Vector3){const{x:i,y:e,z:r}=this.radii;return t.set(1/i**2,1/e**2,1/r**2)}projectOnSurface(t,i=new c.Vector3,e){return O(t,this.reciprocalRadiiSquared(),i,e)}getSurfaceNormal(t,i=new c.Vector3){return i.multiplyVectors(this.reciprocalRadiiSquared(v),t).normalize()}getEastNorthUpVectors(t,i=new c.Vector3,e=new c.Vector3,r=new c.Vector3){this.getSurfaceNormal(t,r),i.set(-t.y,t.x,0).normalize(),e.crossVectors(r,i).normalize()}getEastNorthUpFrame(t,i=new c.Matrix4){const e=v,r=L,s=R;return this.getEastNorthUpVectors(t,e,r,s),i.makeBasis(e,r,s).setPosition(t)}getIntersection(t,i=new c.Vector3){const e=this.reciprocalRadii(v),r=L.copy(e).multiply(t.origin),s=R.copy(e).multiply(t.direction),n=r.lengthSq(),h=s.lengthSq(),a=r.dot(s),y=a**2-h*(n-1);if(n===1)return i.copy(t.origin);if(n>1){if(a>=0||y<0)return;const u=Math.sqrt(y),d=(-a-u)/h,o=(-a+u)/h;return t.at(Math.min(d,o),i)}if(n<1){const u=a**2-h*(n-1),d=Math.sqrt(u),o=(-a+d)/h;return t.at(o,i)}if(a<0)return t.at(-a/h,i)}getOsculatingSphereCenter(t,i,e=new c.Vector3){const r=this.radii.x**2,s=v.set(t.x/r,t.y/r,t.z/this.radii.z**2).normalize();return e.copy(s.multiplyScalar(-i).add(t))}};b.WGS84=new b(6378137,6378137,6356752314245179e-9);let E=b;class P extends c.BufferGeometry{constructor(t=new c.Vector3(1,1,1),i=32,e=16){super(),this.type="EllipsoidGeometry",this.parameters={radii:t,longitudeSegments:i,latitudeSegments:e},i=Math.max(3,Math.floor(i)),e=Math.max(2,Math.floor(e));const r=(i+1)*(e+1),s=new c.Vector3,n=new c.Vector3,h=new Float32Array(r*3),a=new Float32Array(r*3),y=new Float32Array(r*2),u=[],d=[];for(let o=0,l=0,p=0,x=0;o<=e;++o){const f=[],m=o/e,z=m*Math.PI;let M=0;o===0?M=.5/i:o===e&&(M=-.5/i);for(let w=0;w<=i;++w,l+=3,p+=2,++x){const V=w/i,I=V*Math.PI*2;s.x=t.x*Math.cos(I)*Math.sin(z),s.y=t.y*Math.sin(I)*Math.sin(z),s.z=t.z*Math.cos(z),h[l]=s.x,h[l+1]=s.y,h[l+2]=s.z,n.copy(s).normalize(),a[l]=n.x,a[l+1]=n.y,a[l+2]=n.z,y[p]=V+M,y[p+1]=1-m,f.push(x)}u.push(f)}for(let o=0;o<e;++o)for(let l=0;l<i;++l){const p=u[o][l+1],x=u[o][l],f=u[o+1][l],m=u[o+1][l+1];o!==0&&d.push(p,x,m),o!==e-1&&d.push(x,f,m)}this.setIndex(d),this.setAttribute("position",new c.BufferAttribute(h,3)),this.setAttribute("normal",new c.BufferAttribute(a,3)),this.setAttribute("uv",new c.BufferAttribute(y,2))}copy(t){return super.copy(t),this.parameters={...t.parameters},this}}const q=new c.Vector3,U=new c.Vector3,g=class g{constructor(t=0,i=0,e=0){this.longitude=t,this.latitude=i,this.height=e}set(t,i,e){return this.longitude=t,this.latitude=i,e!=null&&(this.height=e),this}clone(){return new g(this.longitude,this.latitude,this.height)}copy(t){return this.longitude=t.longitude,this.latitude=t.latitude,this.height=t.height,this}equals(t){return t.longitude===this.longitude&&t.latitude===this.latitude&&t.height===this.height}setLongitude(t){return this.longitude=t,this}setLatitude(t){return this.latitude=t,this}setHeight(t){return this.height=t,this}normalize(){return this.longitude<g.MIN_LONGITUDE&&(this.longitude+=Math.PI*2),this}setFromECEF(t,i){const r=((i==null?void 0:i.ellipsoid)??E.WGS84).reciprocalRadiiSquared(q),s=O(t,r,U,i);if(s==null)throw new Error(`Could not project position to ellipsoid surface: ${t.toArray()}`);const n=q.multiplyVectors(s,r).normalize();this.longitude=Math.atan2(n.y,n.x),this.latitude=Math.asin(n.z);const h=q.subVectors(t,s);return this.height=Math.sign(h.dot(t))*h.length(),this}toECEF(t=new c.Vector3,i){const e=(i==null?void 0:i.ellipsoid)??E.WGS84,r=q.multiplyVectors(e.radii,e.radii),s=Math.cos(this.latitude),n=U.set(s*Math.cos(this.longitude),s*Math.sin(this.longitude),Math.sin(this.latitude)).normalize();return t.multiplyVectors(r,n),t.divideScalar(Math.sqrt(n.dot(t))).add(n.multiplyScalar(this.height))}fromArray(t,i=0){return this.longitude=t[i],this.latitude=t[i+1],this.height=t[i+2],this}toArray(t=[],i=0){return t[i]=this.longitude,t[i+1]=this.latitude,t[i+2]=this.height,t}*[Symbol.iterator](){yield this.longitude,yield this.latitude,yield this.height}};g.MIN_LONGITUDE=-Math.PI,g.MAX_LONGITUDE=Math.PI,g.MIN_LATITUDE=-Math.PI/2,g.MAX_LATITUDE=Math.PI/2;let N=g;exports.Ellipsoid=E;exports.EllipsoidGeometry=P;exports.Geodetic=N;
//# sourceMappingURL=shared.cjs.map
