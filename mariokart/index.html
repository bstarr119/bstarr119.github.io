<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mario Kart 3D</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #87CEEB; /* Sky blue background */
        }
        canvas {
            width: 100%;
            height: 100%;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 16px;
            text-shadow: 1px 1px 2px black;
        }
        #controls {
            display: none; /* Hidden by default on desktop */
        }
        @media (max-width: 600px) {
            #controls {
                display: block;
                position: absolute;
                bottom: 10px;
                width: 100%;
                text-align: center;
            }
            #controls button {
                width: 60px;
                height: 60px;
                margin: 5px;
                font-size: 12px;
                background: #ffffff;
                border: 2px solid #000;
                border-radius: 10px;
                cursor: pointer;
                opacity: 0.8;
            }
            #controls button:active {
                background: #cccccc;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="ui">
        <p id="speed">Speed: 0</p>
        <p id="time">Time: 0</p>
    </div>
    <div id="controls">
        <button id="left">Left</button>
        <button id="right">Right</button>
        <button id="accelerate">Go</button>
        <button id="brake">Brake</button>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script>
        // Scene Setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas') });
        renderer.setSize(window.innerWidth, window.innerHeight);

        // Physics World
        const world = new CANNON.World();
        world.gravity.set(0, -9.82, 0);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(0, 50, 50);
        scene.add(directionalLight);

        // Track
        const trackGeometry = new THREE.PlaneGeometry(200, 200);
        const trackMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
        const track = new THREE.Mesh(trackGeometry, trackMaterial);
        track.rotation.x = -Math.PI / 2;
        scene.add(track);

        const trackBody = new CANNON.Body({ mass: 0 });
        trackBody.addShape(new CANNON.Plane());
        trackBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
        world.addBody(trackBody);

        // Walls
        const wallGeometry = new THREE.BoxGeometry(2, 2, 200);
        const wallMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        
        const leftWall = new THREE.Mesh(wallGeometry, wallMaterial);
        leftWall.position.set(-100, 1, 0);
        scene.add(leftWall);
        
        const rightWall = new THREE.Mesh(wallGeometry, wallMaterial);
        rightWall.position.set(100, 1, 0);
        scene.add(rightWall);

        const wallShape = new CANNON.Box(new CANNON.Vec3(1, 1, 100));
        const leftWallBody = new CANNON.Body({ mass: 0 });
        leftWallBody.addShape(wallShape);
        leftWallBody.position.set(-100, 1, 0);
        world.addBody(leftWallBody);

        const rightWallBody = new CANNON.Body({ mass: 0 });
        rightWallBody.addShape(wallShape);
        rightWallBody.position.set(100, 1, 0);
        world.addBody(rightWallBody);

        // Kart
        const kartGeometry = new THREE.BoxGeometry(2, 1, 4);
        const kartMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const kart = new THREE.Mesh(kartGeometry, kartMaterial);
        scene.add(kart);

        const chassisShape = new CANNON.Box(new CANNON.Vec3(1, 0.5, 2));
        const chassisBody = new CANNON.Body({ mass: 1 });
        chassisBody.addShape(chassisShape);
        chassisBody.position.set(0, 2, 0);
        world.addBody(chassisBody);

        const vehicle = new CANNON.RaycastVehicle({ chassisBody });
        const wheelOptions = {
            radius: 0.5,
            directionLocal: new CANNON.Vec3(0, -1, 0),
            suspensionStiffness: 30,
            suspensionRestLength: 0.3,
            frictionSlip: 5,
            dampingRelaxation: 2.3,
            dampingCompression: 4.4,
            maxSuspensionForce: 100000,
            rollInfluence: 0.01,
            axleLocal: new CANNON.Vec3(1, 0, 0),
            chassisConnectionPointLocal: new CANNON.Vec3(),
            maxSuspensionTravel: 0.3,
            customSlidingRotationalSpeed: -30,
            useCustomSlidingRotationalSpeed: true
        };

        wheelOptions.chassisConnectionPointLocal.set(-1, 0, 1.5); // Front left
        vehicle.addWheel(wheelOptions);
        wheelOptions.chassisConnectionPointLocal.set(1, 0, 1.5);  // Front right
        vehicle.addWheel(wheelOptions);
        wheelOptions.chassisConnectionPointLocal.set(-1, 0, -1.5); // Rear left
        vehicle.addWheel(wheelOptions);
        wheelOptions.chassisConnectionPointLocal.set(1, 0, -1.5);  // Rear right
        vehicle.addWheel(wheelOptions);

        vehicle.addToWorld(world);

        // Power-Up
        const powerUpGeometry = new THREE.SphereGeometry(1, 32, 32);
        const powerUpMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        const powerUp = new THREE.Mesh(powerUpGeometry, powerUpMaterial);
        powerUp.position.set(0, 1, 50);
        scene.add(powerUp);

        const powerUpShape = new CANNON.Sphere(1);
        const powerUpBody = new CANNON.Body({ mass: 0 });
        powerUpBody.addShape(powerUpShape);
        powerUpBody.position.set(0, 1, 50);
        world.addBody(powerUpBody);

        // Input Handling
        const keys = {};
        window.addEventListener('keydown', (e) => { keys[e.key] = true; });
        window.addEventListener('keyup', (e) => { keys[e.key] = false; });

        // Touch Controls
        document.getElementById('left').addEventListener('touchstart', () => { keys['ArrowLeft'] = true; });
        document.getElementById('left').addEventListener('touchend', () => { keys['ArrowLeft'] = false; });
        document.getElementById('right').addEventListener('touchstart', () => { keys['ArrowRight'] = true; });
        document.getElementById('right').addEventListener('touchend', () => { keys['ArrowRight'] = false; });
        document.getElementById('accelerate').addEventListener('touchstart', () => { keys['ArrowUp'] = true; });
        document.getElementById('accelerate').addEventListener('touchend', () => { keys['ArrowUp'] = false; });
        document.getElementById('brake').addEventListener('touchstart', () => { keys['ArrowDown'] = true; });
        document.getElementById('brake').addEventListener('touchend', () => { keys['ArrowDown'] = false; });

        // UI Elements
        const speedText = document.getElementById('speed');
        const timeText = document.getElementById('time');
        let startTime = Date.now();

        // Power-Up Collision
        chassisBody.addEventListener('collide', (event) => {
            if (event.body === powerUpBody) {
                vehicle.applyEngineForce(-200, 2);
                vehicle.applyEngineForce(-200, 3);
                scene.remove(powerUp); // Remove power-up visually
                world.removeBody(powerUpBody); // Remove from physics
                setTimeout(() => {
                    vehicle.applyEngineForce(0, 2);
                    vehicle.applyEngineForce(0, 3);
                }, 2000); // Boost lasts 2 seconds
            }
        });

        // Camera Follow
        function updateCamera() {
            const offset = new THREE.Vector3(0, 5, 10);
            const kartMatrix = new THREE.Matrix4().makeRotationFromQuaternion(kart.quaternion);
            const cameraPosition = kart.position.clone().add(offset.applyMatrix4(kartMatrix));
            camera.position.copy(cameraPosition);
            camera.lookAt(kart.position);
        }

        // Game Loop
        function update() {
            world.step(1 / 60);

            // Vehicle Controls
            if (keys['ArrowUp']) {
                vehicle.applyEngineForce(-100, 2);
                vehicle.applyEngineForce(-100, 3);
            } else if (keys['ArrowDown']) {
                vehicle.applyEngineForce(100, 2);
                vehicle.applyEngineForce(100, 3);
            } else {
                vehicle.applyEngineForce(0, 2);
                vehicle.applyEngineForce(0, 3);
            }

            if (keys['ArrowLeft']) {
                vehicle.setSteeringValue(0.35, 0);
                vehicle.setSteeringValue(0.35, 1);
            } else if (keys['ArrowRight']) {
                vehicle.setSteeringValue(-0.35, 0);
                vehicle.setSteeringValue(-0.35, 1);
            } else {
                vehicle.setSteeringValue(0, 0);
                vehicle.setSteeringValue(0, 1);
            }

            // Sync Kart with Physics
            kart.position.copy(chassisBody.position);
            kart.quaternion.copy(chassisBody.quaternion);

            // Update Camera
            updateCamera();

            // Update UI
            const speed = chassisBody.velocity.length();
            speedText.textContent = `Speed: ${speed.toFixed(2)}`;
            const elapsed = (Date.now() - startTime) / 1000;
            timeText.textContent = `Time: ${elapsed.toFixed(2)} s`;

            renderer.render(scene, camera);
            requestAnimationFrame(update);
        }

        update();

        // Handle Window Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
