<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mario Kart 3D</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #ui { position: absolute; top: 10px; left: 10px; color: white; font-family: Arial, sans-serif; }
        #controls { position: absolute; bottom: 10px; width: 100%; display: flex; justify-content: space-around; }
        .button { width: 60px; height: 60px; background: rgba(200, 200, 200, 0.7); text-align: center; line-height: 60px; font-size: 16px; border-radius: 10px; user-select: none; }
    </style>
</head>
<body>
    <div id="ui">
        <div id="lap">Lap: 1/3</div>
        <div id="time">Time: 0:00</div>
    </div>
    <div id="controls">
        <div id="left" class="button">Left</div>
        <div id="right" class="button">Right</div>
        <div id="accelerate" class="button">Accel</div>
        <div id="brake" class="button">Brake</div>
        <div id="item" class="button">Item</div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene Setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(1, 1, 1).normalize();
        scene.add(directionalLight);

        // Track Creation
        const trackPoints = [
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(50, 0, 0),
            new THREE.Vector3(100, 0, 50),
            new THREE.Vector3(50, 0, 100),
            new THREE.Vector3(0, 0, 100),
            new THREE.Vector3(-50, 0, 50),
            new THREE.Vector3(0, 0, 0)
        ];
        const trackSpline = new THREE.CatmullRomCurve3(trackPoints, true);
        const trackWidth = 10;
        const shape = new THREE.Shape();
        shape.moveTo(-trackWidth / 2, 0);
        shape.lineTo(trackWidth / 2, 0);
        shape.lineTo(trackWidth / 2, 0.1);
        shape.lineTo(-trackWidth / 2, 0.1);
        const extrudeSettings = { steps: 100, extrudePath: trackSpline };
        const trackGeometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        const trackMaterial = new THREE.MeshBasicMaterial({ color: 0x808080 });
        const track = new THREE.Mesh(trackGeometry, trackMaterial);
        scene.add(track);

        // Kart Creation
        function createKart() {
            const kart = new THREE.Group();
            const bodyGeometry = new THREE.BoxGeometry(2, 1, 1);
            const bodyMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            kart.add(body);
            const wheelGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.2, 16);
            const wheelMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const wheel1 = new THREE.Mesh(wheelGeometry, wheelMaterial);
            wheel1.position.set(1, -0.5, 0.5);
            wheel1.rotation.z = Math.PI / 2;
            kart.add(wheel1);
            const wheel2 = new THREE.Mesh(wheelGeometry, wheelMaterial);
            wheel2.position.set(1, -0.5, -0.5);
            wheel2.rotation.z = Math.PI / 2;
            kart.add(wheel2);
            const wheel3 = new THREE.Mesh(wheelGeometry, wheelMaterial);
            wheel3.position.set(-1, -0.5, 0.5);
            wheel3.rotation.z = Math.PI / 2;
            kart.add(wheel3);
            const wheel4 = new THREE.Mesh(wheelGeometry, wheelMaterial);
            wheel4.position.set(-1, -0.5, -0.5);
            wheel4.rotation.z = Math.PI / 2;
            kart.add(wheel4);
            return kart;
        }
        const playerKart = createKart();
        const startPosition = trackSpline.getPointAt(0);
        playerKart.position.set(startPosition.x, 0.5, startPosition.z);
        const tangent = trackSpline.getTangentAt(0).normalize();
        playerKart.lookAt(startPosition.clone().add(tangent));
        scene.add(playerKart);

        // Item Boxes
        const itemBoxGeometry = new THREE.BoxGeometry(1, 1, 1);
        const itemBoxMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        function createItemBox(t) {
            const position = trackSpline.getPointAt(t);
            const itemBox = new THREE.Mesh(itemBoxGeometry, itemBoxMaterial);
            itemBox.position.set(position.x, 1, position.z);
            itemBox.userData.t = t;
            scene.add(itemBox);
            return itemBox;
        }
        let itemBoxes = [createItemBox(0.25), createItemBox(0.5), createItemBox(0.75)];
        let playerItem = null;

        // Controls
        const keys = { left: false, right: false, up: false, down: false, space: false };
        window.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') keys.left = true;
            else if (e.key === 'ArrowRight') keys.right = true;
            else if (e.key === 'ArrowUp') keys.up = true;
            else if (e.key === 'ArrowDown') keys.down = true;
            else if (e.key === ' ') keys.space = true;
        });
        window.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft') keys.left = false;
            else if (e.key === 'ArrowRight') keys.right = false;
            else if (e.key === 'ArrowUp') keys.up = false;
            else if (e.key === 'ArrowDown') keys.down = false;
            else if (e.key === ' ') keys.space = false;
        });
        const leftButton = document.getElementById('left');
        const rightButton = document.getElementById('right');
        const accelerateButton = document.getElementById('accelerate');
        const brakeButton = document.getElementById('brake');
        const itemButton = document.getElementById('item');
        leftButton.addEventListener('touchstart', () => keys.left = true);
        leftButton.addEventListener('touchend', () => keys.left = false);
        rightButton.addEventListener('touchstart', () => keys.right = true);
        rightButton.addEventListener('touchend', () => keys.right = false);
        accelerateButton.addEventListener('touchstart', () => keys.up = true);
        accelerateButton.addEventListener('touchend', () => keys.up = false);
        brakeButton.addEventListener('touchstart', () => keys.down = true);
        brakeButton.addEventListener('touchend', () => keys.down = false);
        itemButton.addEventListener('touchstart', () => keys.space = true);
        itemButton.addEventListener('touchend', () => keys.space = false);

        // Kart Physics
        const maxSpeed = 0.5;
        const acceleration = 0.01;
        const steeringSpeed = 0.05;
        const maxSteeringAngle = Math.PI / 6;
        let currentSpeed = 0;
        let steeringAngle = 0;

        // Game State
        let gameState = 'racing';
        let lap = 1;
        const totalLaps = 3;
        let previousT = 0;
        let startTime = Date.now();

        // Functions
        function updateCamera() {
            const offset = new THREE.Vector3(0, 2, -5);
            const kartMatrix = new THREE.Matrix4().makeRotationFromQuaternion(playerKart.quaternion);
            const cameraOffset = offset.applyMatrix4(kartMatrix);
            camera.position.copy(playerKart.position).add(cameraOffset);
            camera.lookAt(playerKart.position);
        }

        function getClosestT(position) {
            let minDist = Infinity;
            let closestT = 0;
            for (let t = 0; t <= 1; t += 0.01) {
                const point = trackSpline.getPointAt(t);
                const dist = position.distanceTo(point);
                if (dist < minDist) {
                    minDist = dist;
                    closestT = t;
                }
            }
            return closestT;
        }

        function updatePlayerKart() {
            if (keys.up) {
                currentSpeed += acceleration;
                if (currentSpeed > maxSpeed) currentSpeed = maxSpeed;
            } else if (keys.down) {
                currentSpeed -= acceleration;
                if (currentSpeed < -maxSpeed / 2) currentSpeed = -maxSpeed / 2;
            } else {
                if (currentSpeed > 0) currentSpeed -= acceleration / 2;
                else if (currentSpeed < 0) currentSpeed += acceleration / 2;
                if (Math.abs(currentSpeed) < acceleration / 2) currentSpeed = 0;
            }
            if (keys.left) steeringAngle += steeringSpeed;
            else if (keys.right) steeringAngle -= steeringSpeed;
            else {
                if (steeringAngle > 0) steeringAngle -= steeringSpeed / 2;
                else if (steeringAngle < 0) steeringAngle += steeringSpeed / 2;
                if (Math.abs(steeringAngle) < steeringSpeed / 2) steeringAngle = 0;
            }
            steeringAngle = Math.max(-maxSteeringAngle, Math.min(maxSteeringAngle, steeringAngle));
            if (keys.space && playerItem === 'mushroom') {
                currentSpeed += 0.2;
                playerItem = null;
            }
            playerKart.rotateY(steeringAngle);
            const forward = playerKart.getWorldDirection(new THREE.Vector3()).negate();
            playerKart.position.add(forward.multiplyScalar(currentSpeed));
            playerKart.position.y = 0.5;
            const t = getClosestT(playerKart.position);
            const point = trackSpline.getPointAt(t);
            const distance = playerKart.position.distanceTo(point);
            if (distance > trackWidth / 2) currentSpeed *= 0.9;
        }

        function checkItemCollisions() {
            itemBoxes.forEach((box, index) => {
                const distance = playerKart.position.distanceTo(box.position);
                if (distance < 1 && playerItem === null) {
                    playerItem = 'mushroom';
                    scene.remove(box);
                    itemBoxes.splice(index, 1);
                    setTimeout(() => {
                        const newBox = createItemBox(box.userData.t);
                        itemBoxes.push(newBox);
                    }, 10000);
                }
            });
        }

        function updateLap() {
            const currentT = getClosestT(playerKart.position);
            if (previousT > 0.9 && currentT < 0.1) {
                lap++;
                if (lap > totalLaps) {
                    gameState = 'finished';
                    document.getElementById('ui').innerHTML = `Finished! Time: ${document.getElementById('time').textContent}`;
                    document.getElementById('controls').style.display = 'none';
                } else {
                    document.getElementById('lap').textContent = `Lap: ${lap}/${totalLaps}`;
                }
            }
            previousT = currentT;
        }

        function updateTime() {
            const elapsed = Date.now() - startTime;
            const minutes = Math.floor(elapsed / 60000);
            const seconds = Math.floor((elapsed % 60000) / 1000);
            document.getElementById('time').textContent = `Time: ${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        // Game Loop
        function gameLoop() {
            if (gameState === 'racing') {
                updatePlayerKart();
                updateCamera();
                checkItemCollisions();
                updateLap();
                updateTime();
                renderer.render(scene, camera);
            }
            requestAnimationFrame(gameLoop);
        }
        gameLoop();

        // Resize Handling
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
